{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":0},{"_id":"source/images/blossom-wallpaper.jpg","path":"images/blossom-wallpaper.jpg","modified":0,"renderable":0},{"_id":"source/images/snow_mountain.jpg","path":"images/snow_mountain.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-next-master/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/dist/APlayer.min.css","path":"dist/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/dist/APlayer.min.css.map","path":"dist/APlayer.min.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/dist/APlayer.min.js","path":"dist/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/dist/APlayer.min.js.map","path":"dist/APlayer.min.js.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/dist/music.js","path":"dist/music.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/blossom.jpg","path":"images/blossom.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/heart_bulb_stars_16x16.ico","path":"images/heart_bulb_stars_16x16.ico","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/heart_bulb_stars_32x32.ico","path":"images/heart_bulb_stars_32x32.ico","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/uploads/custom-logo.jpg","path":"uploads/custom-logo.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/cursor/clicklove.js","path":"js/cursor/clicklove.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/cursor/text.js","path":"js/cursor/text.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"source/images/sea-wave.jpg","path":"images/sea-wave.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"ba43a796648d64d74ed79d25eafeff9813e0da35","modified":1638328041035},{"_id":"source/_drafts/2022-TODO.md","hash":"2899311c6c264349b3af3b39c6b0147ea85c2c4c","modified":1644574310825},{"_id":"source/_drafts/21岁的最后半小时与22岁的第一个半小时.md","hash":"0991a13064f8b4dedba005efb454a2688d3cd480","modified":1638328041036},{"_id":"source/_drafts/月计划.md","hash":"b214fe7b086ddefc48d32ec41ca2062079a8c1f7","modified":1648436828714},{"_id":"source/_data/styles.styl","hash":"2d7b11609d91bfdf16c6b1af925e7325207fa730","modified":1658721935658},{"_id":"source/_drafts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1638328041037},{"_id":"source/_drafts/new-draft.md","hash":"e6caabc89c31ef4c4ab5e126616e625d12e5c535","modified":1638328041037},{"_id":"source/_drafts/编译原理实验-LR(1)分析.md","hash":"1c85b2c4f3b49705a4a88a2f9b653f3021a50861","modified":1638328041037},{"_id":"source/_data/project.json","hash":"3e397db3adfef9855043ab6dc664ecaa0c8ad514","modified":1638328041036},{"_id":"source/about/index.md","hash":"3e7ba11d181e829b0caba0cf71a154556a2c2dd8","modified":1638328041051},{"_id":"source/_posts/3月读书观影分享.md","hash":"c4eaf2ff8f5db5ecd9f68dee4e03bf6ce811b59d","modified":1638328041037},{"_id":"source/_posts/Coding0618.md","hash":"7e93951f1bb0855930d5052a0a53eed4403fb741","modified":1638328041038},{"_id":"source/_posts/Android新手路上一些坑-Android-Studio-Android-SDK-新手上路指南.md","hash":"0f1d5b28ab04f9f81d38b15eed466efec14b3225","modified":1638328041038},{"_id":"source/_posts/Coding0620.md","hash":"0759588e44b93abc159c1ceae965cc4fffc9d88f","modified":1638328041038},{"_id":"source/_posts/Colab运行python代码找不到路径.md","hash":"ee48eed36c353a1a8a21c95ae3082e3dda3ad466","modified":1638328041039},{"_id":"source/_posts/Leetcode-0106.md","hash":"b962abc76bfdcb9152c1d0257820e0bbfb82842c","modified":1638328041040},{"_id":"source/_posts/Java核心技术卷1笔记-2.md","hash":"5df4e948f5f88c79591d3c6cc61c17b7c268f9b1","modified":1639036265002},{"_id":"source/_posts/Leetcode-0221.md","hash":"9e65ba82c20d74c2ebf29541486110d0b6774cef","modified":1638328041040},{"_id":"source/_posts/Leetcode刷题之动态规划.md","hash":"7d0d98736350ee4f99667018b2a2c49f9999dafa","modified":1648997037683},{"_id":"source/_posts/Leetcode刷题之双指针.md","hash":"5e6592fc99e5e843f2f7512d9f88bb18bb46e237","modified":1644477812488},{"_id":"source/_posts/Java核心技术卷1笔记-1.md","hash":"8c19db15183dbdaac207fb9d7829be7c39cc19ce","modified":1638328041039},{"_id":"source/_posts/Deep-Learning学习笔记.md","hash":"be98055aeb6dba9709269e8e3a592a49a8cc7ac2","modified":1638328041039},{"_id":"source/_posts/Leetcode刷题之滑动窗口.md","hash":"9e4663320c25c0a4edec7b9caf5abab700a640bb","modified":1644681743409},{"_id":"source/_posts/Pycharm中打不开Python-Console-le.md","hash":"29be8a39ceaa83e809e00ba32dd3b34a71355ab0","modified":1638328041040},{"_id":"source/_posts/Python学习-Day2.md","hash":"22b0cec54a48b5066003276b963601e901bc0b60","modified":1638328041041},{"_id":"source/_posts/Python学习-Day1.md","hash":"7f89811ef9c08b474149e5217960d1516281c692","modified":1638328041041},{"_id":"source/_posts/Leetcode刷题之链表.md","hash":"28ed5d157bf8c65ef4e9d658f5edd064f003799a","modified":1647853069976},{"_id":"source/_posts/Leetcode刷题之模拟.md","hash":"66c21521af5a1df8cc71ca8e1cd64c00b1ee672b","modified":1641910923204},{"_id":"source/_posts/Reflect-on-2019-2019复盘-2020计划.md","hash":"66497f0e46f37e0316a0b765f3db3ad99025d159","modified":1638328041043},{"_id":"source/_posts/Python学习-Day3.md","hash":"78cee70fbdfe885c08229dbeb464777ec27c057e","modified":1638328041042},{"_id":"source/_posts/《数学之美》读书笔记-1.md","hash":"3c6d376e344c1c6233b1fb1bcdc855962bf357ad","modified":1638328041043},{"_id":"source/_posts/《流星雨》读书笔记.md","hash":"543d6b191d7b3d3641049151f676c6ab3ebb5663","modified":1638328041043},{"_id":"source/_posts/三月观影读书.md","hash":"ec56779845d23a0dbc99b3885cad877bd4fbddf8","modified":1638328041044},{"_id":"source/_posts/Python学习-Day4.md","hash":"a5a36708b39c9467c9692cefd1c8a75db28876d9","modified":1638328041042},{"_id":"source/_posts/九月观影看书.md","hash":"6dfa0fecc91b9f0fc41aca3951e53d8e6d07933c","modified":1638328041044},{"_id":"source/_posts/四月读书观影分享.md","hash":"23fd745a974baf392b0ef9fd08030f40a79d5d31","modified":1638328041045},{"_id":"source/_posts/二月观影看剧分享-影评-剧评.md","hash":"bc7ce7f9cfa6999b94efeb025de7aee895bd1537","modified":1638328041045},{"_id":"source/_posts/如何做文献阅读笔记.md","hash":"2b1ec0b9af91c4c07a304fa2df83201ae7b0257b","modified":1638328041046},{"_id":"source/_posts/在用hexo和github搭建个人博客中遇到的问题及解决办法.md","hash":"2f0e9646c6c35d2b3dde7842b685073cbf02b54c","modified":1638328041046},{"_id":"source/_posts/小样本数据扩增总结.md","hash":"4d0ed01d3fb92606732f35cf0dc6b3a58bcc5df1","modified":1638328041047},{"_id":"source/_posts/小李的新年flag-新年-新学期-21岁-目标-随感.md","hash":"94019a1fb69f458b025c3aa9808f120e161545b8","modified":1638328041046},{"_id":"source/_posts/操作系统课设-1.md","hash":"22f5a94e028a0711b3bf252cf4da5ef1a014f346","modified":1638328041047},{"_id":"source/_posts/最大匹配算法与隐马尔科夫模型-中文分词-NLP.md","hash":"883d2c3fd2ae29c7b89363c8e42b8699ab251c0c","modified":1638328041047},{"_id":"source/_posts/研究生生活的第一周.md","hash":"ab625d27b943868483ec9f51ff4936a8bb698ac3","modified":1638328041048},{"_id":"source/_posts/研究生生活的第二周.md","hash":"131354032f8e21f787b872a7ff8e1c2b0639c363","modified":1638328041048},{"_id":"source/_posts/第一篇文章.md","hash":"cd5941752c880d12c75f9e8a0e70eba0e49d9580","modified":1638328041049},{"_id":"source/_posts/组会笔记.md","hash":"58e80e406426524b51841785a8ff0d9d9cef7ccd","modified":1638328041049},{"_id":"source/_posts/编译原理之LR-1-分析.md","hash":"136834fc0b5c2811e137b762110c483e2469bcad","modified":1638328041049},{"_id":"source/_posts/脚本学习.md","hash":"8c7be5881f5e01a4fec31654c279e31058a5167c","modified":1638328041050},{"_id":"source/_posts/随笔0325.md","hash":"a0a06d5dbbe62a95d175aee6e212f22323f4d285","modified":1648303131475},{"_id":"source/_posts/随感0428.md","hash":"bcd0f7386c5b3eb3b92efe6e748f2f88cb89d886","modified":1638328041050},{"_id":"source/_posts/随感0609.md","hash":"ba318e0c7c9837d460aeb0c2b611df2053d4b6ba","modified":1638328041050},{"_id":"source/_posts/随感0705.md","hash":"4bd207864223bd2a1f8ec108991b3746debec6f9","modified":1638328041051},{"_id":"source/categories/index.md","hash":"e87c54d6afb22060a009fce17c6e8bb0decda1a6","modified":1638328041051},{"_id":"source/images/background.jpg","hash":"c5fd7060424906a97bf83dd256233f4ff6859c6b","modified":1638328041052},{"_id":"source/images/blossom-wallpaper.jpg","hash":"e5baacab9de10b85172d28fef9291f9ffef96b80","modified":1648223857893},{"_id":"source/tags/index.md","hash":"a52047e98023eb2eb086fde0af736053f572f3ac","modified":1638328041055},{"_id":"source/works/index.md","hash":"b14d18953e4f162e2d2e022ac8130ee0d165242c","modified":1638328041056},{"_id":"themes/hexo-theme-next-master/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1638328041058},{"_id":"themes/hexo-theme-next-master/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1638328041057},{"_id":"themes/hexo-theme-next-master/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1638328041058},{"_id":"themes/hexo-theme-next-master/.gitignore","hash":"4600f2b61b2fe0d61f824bda9aa2b5d072f0e635","modified":1638328041063},{"_id":"themes/hexo-theme-next-master/_vendors.yml","hash":"842505bac8e3174ca98c6c988fdd9d48bcbe6cf4","modified":1638328041065},{"_id":"themes/hexo-theme-next-master/_config.yml","hash":"98e2bed2c8c5ab2d46aab970a74cfa3269e8f2a2","modified":1649000723121},{"_id":"themes/hexo-theme-next-master/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1638328041064},{"_id":"themes/hexo-theme-next-master/README.md","hash":"de109b73e09826f6bccceae60c618739a794f8f7","modified":1638328041064},{"_id":"themes/hexo-theme-next-master/package.json","hash":"8cb368a627f118170d04cc4f100a958d60657b02","modified":1638328041092},{"_id":"themes/hexo-theme-next-master/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1638328041065},{"_id":"themes/hexo-theme-next-master/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1638328041064},{"_id":"themes/hexo-theme-next-master/.github/CODE_OF_CONDUCT.md","hash":"21cbff565a0445d3a880fff1ee417e309740a9ab","modified":1638328041059},{"_id":"themes/hexo-theme-next-master/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1638328041092},{"_id":"themes/hexo-theme-next-master/.github/PULL_REQUEST_TEMPLATE.md","hash":"3e9fbb78e3dee0ca1dc886d0c28b0148ba0ca499","modified":1638328041061},{"_id":"themes/hexo-theme-next-master/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1638328041061},{"_id":"themes/hexo-theme-next-master/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1638328041061},{"_id":"themes/hexo-theme-next-master/.github/CONTRIBUTING.md","hash":"eefd073dfb68884cd946f7ec6d3b3619031d7650","modified":1638328041059},{"_id":"themes/hexo-theme-next-master/.github/labeler.yml","hash":"e7033752b1f7c35adb61c2b38aad0a9202cdd19b","modified":1638328041061},{"_id":"themes/hexo-theme-next-master/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1638328041061},{"_id":"themes/hexo-theme-next-master/.github/release-drafter.yml","hash":"7662e31224a24154c4fe06b95ccbdff51ab8f2cc","modified":1638328041062},{"_id":"themes/hexo-theme-next-master/languages/ar.yml","hash":"7a62243ec54196e3d1bea7364f05aded490bc234","modified":1638328041069},{"_id":"themes/hexo-theme-next-master/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1638328041068},{"_id":"themes/hexo-theme-next-master/languages/de.yml","hash":"dc448f724c7d436233e9567711a09e0d56e60e3b","modified":1638328041069},{"_id":"themes/hexo-theme-next-master/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1638328041069},{"_id":"themes/hexo-theme-next-master/languages/fa.yml","hash":"649823297167b902455c0aec8ddebb462df71c7d","modified":1638328041070},{"_id":"themes/hexo-theme-next-master/languages/en.yml","hash":"48a76170d70ef7c1fac96720bc5064b43061708d","modified":1638328041069},{"_id":"themes/hexo-theme-next-master/languages/fr.yml","hash":"8ddfe98e7847ee8f1eaba9119f9fbdc42d7ec120","modified":1638328041070},{"_id":"themes/hexo-theme-next-master/languages/es.yml","hash":"c3506dfaa771e827ae6adb322477c6e835cd0f09","modified":1638328041070},{"_id":"themes/hexo-theme-next-master/languages/id.yml","hash":"ac018805190bc4bdc06091f5a6444e612fc700b0","modified":1638328041071},{"_id":"themes/hexo-theme-next-master/languages/ja.yml","hash":"99f6f84f5cb6631b7ae0b5594af2ea2940c3558e","modified":1638328041071},{"_id":"themes/hexo-theme-next-master/languages/it.yml","hash":"82a93c32b3fcf6517441cdc73f75bc6173beb392","modified":1638328041071},{"_id":"themes/hexo-theme-next-master/languages/nl.yml","hash":"0d3b56613197cb190900311507535db41daec7d4","modified":1638328041072},{"_id":"themes/hexo-theme-next-master/languages/pt-BR.yml","hash":"47daeaa23c4db073e77761c9a6f62d3932af06ec","modified":1638328041072},{"_id":"themes/hexo-theme-next-master/languages/ko.yml","hash":"8342df2f4190ba4ee004b70d1d6ccd341033dbe7","modified":1638328041072},{"_id":"themes/hexo-theme-next-master/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1638328041066},{"_id":"themes/hexo-theme-next-master/languages/pt.yml","hash":"e0e2675261e2e80f7ce7d19c945c08217b068d81","modified":1638328041073},{"_id":"themes/hexo-theme-next-master/languages/si.yml","hash":"0afecef3d81b880cc19769062968d8562a1cd93b","modified":1638328041073},{"_id":"themes/hexo-theme-next-master/languages/ru.yml","hash":"fdf5c623890db24cb56ab5ffe0c49db3542477c8","modified":1638328041073},{"_id":"themes/hexo-theme-next-master/languages/tr.yml","hash":"54de3d8d85e3c7b14b163c3d322411b7301a09b3","modified":1638328041073},{"_id":"themes/hexo-theme-next-master/languages/uk.yml","hash":"1c9a0b8d8160c77cc62064207d57f460f365cae9","modified":1638328041074},{"_id":"themes/hexo-theme-next-master/languages/vi.yml","hash":"1f9657b58e11db21f93eb895c90123b8f91751a7","modified":1638328041074},{"_id":"themes/hexo-theme-next-master/languages/zh-CN.yml","hash":"6f7c742316c96d5b71da50fddfb060ff7ec1ea99","modified":1638328041075},{"_id":"themes/hexo-theme-next-master/languages/zh-TW.yml","hash":"8d6f8d90aedcc5c844da93e196bfde0c0161385b","modified":1638328041075},{"_id":"themes/hexo-theme-next-master/languages/zh-HK.yml","hash":"38b99be8cea1cfd79f36deca13be665dedfad9c5","modified":1638328041075},{"_id":"themes/hexo-theme-next-master/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1638328041091},{"_id":"themes/hexo-theme-next-master/layout/_layout.njk","hash":"2aef6896cf84f0c29f5e50d5c6b8c0091d92531c","modified":1638328041076},{"_id":"themes/hexo-theme-next-master/layout/index.njk","hash":"37ec3d1bcd20b8ac1d18e0d68f990450890b46cd","modified":1638328041091},{"_id":"themes/hexo-theme-next-master/layout/category.njk","hash":"0a590e87af50e57b15fc37695c9a3bf4a97c3d92","modified":1638328041091},{"_id":"themes/hexo-theme-next-master/layout/page.njk","hash":"9cd3eca2c468bb46c7c5bf391bea4b025af178f6","modified":1638328041091},{"_id":"themes/hexo-theme-next-master/layout/tag.njk","hash":"6cd707f846bfd6becbcfb060c26958bb4015c31f","modified":1638328041092},{"_id":"themes/hexo-theme-next-master/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1638328041091},{"_id":"themes/hexo-theme-next-master/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1638328041066},{"_id":"themes/hexo-theme-next-master/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1638328041066},{"_id":"themes/hexo-theme-next-master/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1638328041134},{"_id":"themes/hexo-theme-next-master/.github/ISSUE_TEMPLATE/config.yml","hash":"c40ae7903b6cc99f94c9d45ac7ba8c2850bb1309","modified":1638328041060},{"_id":"themes/hexo-theme-next-master/.github/ISSUE_TEMPLATE/bug-report.md","hash":"fc4dce84ed9a5d21d3a8833ff6d776c46f876115","modified":1638328041059},{"_id":"themes/hexo-theme-next-master/.github/workflows/label-commenter.yml","hash":"a33cd7c7644c8e89c885545ddafc437274ff64ff","modified":1638328041062},{"_id":"themes/hexo-theme-next-master/.github/workflows/labeler.yml","hash":"8b73c439dc796be141d521a4546bcfb7a5485534","modified":1638328041062},{"_id":"themes/hexo-theme-next-master/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4ecac91716eac59d7c2bc53cf6e95612d44da97b","modified":1638328041060},{"_id":"themes/hexo-theme-next-master/.github/workflows/linter.yml","hash":"a3019edd2185c4c287a682fdd76043e107ed927b","modified":1638328041062},{"_id":"themes/hexo-theme-next-master/.github/ISSUE_TEMPLATE/other.md","hash":"8cc5b5c116f6a052865a324512362f145d699202","modified":1638328041060},{"_id":"themes/hexo-theme-next-master/.github/workflows/lock.yml","hash":"70bd0be3f33774e4b0ada3a59c901f8f9cff1013","modified":1638328041062},{"_id":"themes/hexo-theme-next-master/.github/workflows/stale.yml","hash":"e1d9cc9addc35cfb53f971f14d9d04065c941df0","modified":1638328041063},{"_id":"themes/hexo-theme-next-master/.github/workflows/tester.yml","hash":"22aaaa3eba1a7ebcf0f78417fd9a7113ee7b6c6c","modified":1638328041063},{"_id":"themes/hexo-theme-next-master/layout/_custom/custom.swig","hash":"157a51df2461338b291df9f169c30a2985c8c6b0","modified":1638328041076},{"_id":"themes/hexo-theme-next-master/.github/workflows/release-drafter.yml","hash":"4f3af81009cb922be91f718a67425377515ea69d","modified":1638328041063},{"_id":"themes/hexo-theme-next-master/docs/ru/README.md","hash":"63df0665005063108e1bc19df3cf8c4e46facb95","modified":1638328041067},{"_id":"themes/hexo-theme-next-master/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1638328041076},{"_id":"themes/hexo-theme-next-master/layout/_macro/post.njk","hash":"b106599106285ecd4c0c1e0ed11c46a36b5a69d5","modified":1638328041077},{"_id":"themes/hexo-theme-next-master/layout/_partials/footer.njk","hash":"d16fdaf94d66efc0242b0c26ed539017e3b4f795","modified":1638328041078},{"_id":"themes/hexo-theme-next-master/layout/_macro/sidebar.njk","hash":"cbf838ca59646f128c9111bb28921c1d04d8dcaf","modified":1638328041077},{"_id":"themes/hexo-theme-next-master/layout/_partials/comments.njk","hash":"334e8d8117a46c8c097788811322a62627952219","modified":1638328041077},{"_id":"themes/hexo-theme-next-master/layout/_partials/languages.njk","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1638328041080},{"_id":"themes/hexo-theme-next-master/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1638328041081},{"_id":"themes/hexo-theme-next-master/layout/_partials/widgets.njk","hash":"dfd91d64ebc06b5b139ee97424f4f93e66938e34","modified":1638328041084},{"_id":"themes/hexo-theme-next-master/layout/_scripts/index.njk","hash":"6f0433940680c0f9db37542ca36f76e4bb1c1d50","modified":1638328041084},{"_id":"themes/hexo-theme-next-master/layout/_scripts/noscript.njk","hash":"4f250d0bf80be06dd2c95c1d4c2ba2624b59cf2a","modified":1638328041084},{"_id":"themes/hexo-theme-next-master/layout/_scripts/vendors.njk","hash":"bada07da2a47ed6de6081796367b19dd9e906cfb","modified":1638328041084},{"_id":"themes/hexo-theme-next-master/layout/_third-party/index.njk","hash":"467b45a4912369bcba77908151e76a3f3ad0fed2","modified":1638328041087},{"_id":"themes/hexo-theme-next-master/layout/_third-party/nprogress.njk","hash":"271139c3896a6d294f46f767cb21b2e848050841","modified":1638328041088},{"_id":"themes/hexo-theme-next-master/layout/_scripts/pjax.njk","hash":"28a3bcb1ce50924a5a48b0f3756ac3a8736867f1","modified":1638328041084},{"_id":"themes/hexo-theme-next-master/layout/_third-party/quicklink.njk","hash":"294b7f6a4fa566e369d8be0ce7b28f35b6c14563","modified":1638328041088},{"_id":"themes/hexo-theme-next-master/layout/_third-party/rating.njk","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1638328041088},{"_id":"themes/hexo-theme-next-master/scripts/events/index.js","hash":"89091bc943cd8b8c63b8af3d26fb0a027048e9ba","modified":1638328041092},{"_id":"themes/hexo-theme-next-master/scripts/filters/locals.js","hash":"374c9211b3b6a5b2ad31f1bea69a22f2727f633a","modified":1638328041096},{"_id":"themes/hexo-theme-next-master/scripts/filters/minify.js","hash":"be0574c64a38210e449c99d38a760452015060a3","modified":1638328041096},{"_id":"themes/hexo-theme-next-master/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1638328041096},{"_id":"themes/hexo-theme-next-master/scripts/helpers/engine.js","hash":"0208f17281a1afe3da1298dd52350eb838098349","modified":1638328041097},{"_id":"themes/hexo-theme-next-master/scripts/filters/post.js","hash":"42a9b81c5449afa9d67770604478168333c93804","modified":1638328041097},{"_id":"themes/hexo-theme-next-master/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1638328041097},{"_id":"themes/hexo-theme-next-master/scripts/helpers/next-url.js","hash":"577c510374cf9bcfa8d3a1027e42411a9324805e","modified":1638328041098},{"_id":"themes/hexo-theme-next-master/scripts/helpers/next-config.js","hash":"413c51fa3caa87fe95d1d8f95e6023f096515632","modified":1638328041098},{"_id":"themes/hexo-theme-next-master/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1638328041098},{"_id":"themes/hexo-theme-next-master/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1638328041098},{"_id":"themes/hexo-theme-next-master/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1638328041098},{"_id":"themes/hexo-theme-next-master/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1638328041099},{"_id":"themes/hexo-theme-next-master/scripts/tags/group-pictures.js","hash":"79102d9e9bccff6224e77a77c4d2d363094ae3df","modified":1638328041099},{"_id":"themes/hexo-theme-next-master/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1638328041099},{"_id":"themes/hexo-theme-next-master/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1638328041100},{"_id":"themes/hexo-theme-next-master/scripts/tags/link-grid.js","hash":"9e2c58d1a4d1dd84fa86144e5b4576b2fd10a37f","modified":1638328041100},{"_id":"themes/hexo-theme-next-master/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1638328041100},{"_id":"themes/hexo-theme-next-master/scripts/tags/mermaid.js","hash":"464effc08e757ce8e1bb094707d06ad829af9d62","modified":1638328041100},{"_id":"themes/hexo-theme-next-master/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1638328041100},{"_id":"themes/hexo-theme-next-master/scripts/tags/tabs.js","hash":"2bf00d56b3b289a7dd27e9b5820430a2457a19f3","modified":1638328041101},{"_id":"themes/hexo-theme-next-master/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1638328041101},{"_id":"themes/hexo-theme-next-master/source/css/_colors.styl","hash":"b37f9847d2f95632e911df670b51921a7d748068","modified":1638328041101},{"_id":"themes/hexo-theme-next-master/source/css/_mixins.styl","hash":"6bca0a5dc96fea392a0da53e0566ec2a113ec382","modified":1638328041118},{"_id":"themes/hexo-theme-next-master/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1638328041124},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1638328041067},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/README.md","hash":"9abd8473985f2bf1557b1aac31b436c92d5450a7","modified":1638328041068},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/CONTRIBUTING.md","hash":"8ee5ca39ac4a372a5c0f16e344bbe578af4aeae4","modified":1638328041068},{"_id":"themes/hexo-theme-next-master/source/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1638328041125},{"_id":"themes/hexo-theme-next-master/source/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1638328041125},{"_id":"themes/hexo-theme-next-master/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1638328041126},{"_id":"themes/hexo-theme-next-master/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1638328041126},{"_id":"themes/hexo-theme-next-master/source/dist/music.js","hash":"c875ea9bf617bb7822a4da427130532a27137f66","modified":1638328041126},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1638328041130},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1638328041130},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1638328041130},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1638328041131},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1638328041131},{"_id":"themes/hexo-theme-next-master/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1638328041131},{"_id":"themes/hexo-theme-next-master/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1638328041131},{"_id":"themes/hexo-theme-next-master/source/images/heart_bulb_stars_16x16.ico","hash":"6e5d4b6104fc4a34095dbdd25aba28508ed9feba","modified":1638328041131},{"_id":"themes/hexo-theme-next-master/source/images/heart_bulb_stars_32x32.ico","hash":"ada310e120ce34cbc69fbd9d305d7454fdafee96","modified":1638328041131},{"_id":"themes/hexo-theme-next-master/source/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1638328041125},{"_id":"themes/hexo-theme-next-master/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1638328041131},{"_id":"themes/hexo-theme-next-master/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1638328041131},{"_id":"themes/hexo-theme-next-master/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1638328041131},{"_id":"themes/hexo-theme-next-master/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1638328041132},{"_id":"themes/hexo-theme-next-master/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1638328041132},{"_id":"themes/hexo-theme-next-master/source/js/next-boot.js","hash":"c2a04055d8edec03dc74e1c45d83bd3b51467de0","modified":1638328041133},{"_id":"themes/hexo-theme-next-master/source/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1638328041132},{"_id":"themes/hexo-theme-next-master/source/js/utils.js","hash":"fcb84304fc3ba06f8c4f840fe1e0843339e0899d","modified":1638328041133},{"_id":"themes/hexo-theme-next-master/source/js/algolia-search.js","hash":"a360423984cdd915d04365c51bcab440e52d7223","modified":1638328041132},{"_id":"themes/hexo-theme-next-master/source/js/schedule.js","hash":"71d62fc3584c47ff2d4cc945226e412264399be9","modified":1638328041133},{"_id":"themes/hexo-theme-next-master/source/js/local-search.js","hash":"da2051e7cab184ae4aa64457c5db7476b4645fdc","modified":1638328041132},{"_id":"themes/hexo-theme-next-master/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1638328041134},{"_id":"themes/hexo-theme-next-master/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1638328041134},{"_id":"themes/hexo-theme-next-master/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1638328041135},{"_id":"themes/hexo-theme-next-master/test/helpers/next-url.js","hash":"abc4ee5149df6172b2c36b6e85d1993ec748ddea","modified":1638328041134},{"_id":"themes/hexo-theme-next-master/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1638328041135},{"_id":"themes/hexo-theme-next-master/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1638328041135},{"_id":"themes/hexo-theme-next-master/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1638328041136},{"_id":"themes/hexo-theme-next-master/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1638328041135},{"_id":"themes/hexo-theme-next-master/test/tags/link-grid.js","hash":"88ec69e4dc1d493d21254ed9296a2514e91f0f8b","modified":1638328041136},{"_id":"themes/hexo-theme-next-master/test/tags/group-pictures.js","hash":"f41640e5d0f552c0b0c4ac8876a2edb0fcf54e56","modified":1638328041135},{"_id":"themes/hexo-theme-next-master/test/tags/mermaid.js","hash":"ed5b5a70ee49842501c952c4d62483f1fc8eba6b","modified":1638328041136},{"_id":"themes/hexo-theme-next-master/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1638328041136},{"_id":"themes/hexo-theme-next-master/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1638328041137},{"_id":"themes/hexo-theme-next-master/layout/_partials/head/head-unique.njk","hash":"37bdf020591feb0cf72327c9efd755bf78a0afd6","modified":1638328041078},{"_id":"themes/hexo-theme-next-master/layout/_partials/head/head.njk","hash":"8f6521714044676e15d924da387b2aef45fc8fe6","modified":1638328041078},{"_id":"themes/hexo-theme-next-master/layout/_partials/header/brand.njk","hash":"ffb6c69a9c90793cbe9bf0544b55f7a41c016d8f","modified":1638328041078},{"_id":"themes/hexo-theme-next-master/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1638328041079},{"_id":"themes/hexo-theme-next-master/layout/_partials/header/menu-item.njk","hash":"b46f412c0b4f775fd329d50357f722f5d7c1a3ba","modified":1638328041079},{"_id":"themes/hexo-theme-next-master/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1638328041079},{"_id":"themes/hexo-theme-next-master/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1638328041079},{"_id":"themes/hexo-theme-next-master/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":1638328041080},{"_id":"themes/hexo-theme-next-master/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1638328041080},{"_id":"themes/hexo-theme-next-master/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1638328041080},{"_id":"themes/hexo-theme-next-master/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1638328041081},{"_id":"themes/hexo-theme-next-master/layout/_partials/page/schedule.njk","hash":"9d650333160ad1977fe42d9770869ff1660a95fe","modified":1638328041081},{"_id":"themes/hexo-theme-next-master/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1638328041081},{"_id":"themes/hexo-theme-next-master/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1638328041082},{"_id":"themes/hexo-theme-next-master/layout/_partials/post/post-meta.njk","hash":"1410fad73e0a08a45166e4a055ba150fd06e8636","modified":1638328041082},{"_id":"themes/hexo-theme-next-master/layout/_partials/post/post-reward.njk","hash":"a9bb52d0537d27cfe670d80e716da6780786ab8a","modified":1638328041083},{"_id":"themes/hexo-theme-next-master/layout/_partials/post/post-footer.njk","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1638328041082},{"_id":"themes/hexo-theme-next-master/layout/_partials/post/post-related.njk","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1638328041082},{"_id":"themes/hexo-theme-next-master/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1638328041083},{"_id":"themes/hexo-theme-next-master/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1638328041083},{"_id":"themes/hexo-theme-next-master/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1638328041083},{"_id":"themes/hexo-theme-next-master/layout/_partials/sidebar/site-overview.njk","hash":"c419158e19805e2db614a5f5651e3e534e4a5e4e","modified":1638328041084},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/baidu-analytics.njk","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1638328041085},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/growingio.njk","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1638328041085},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":1638328041085},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/google-analytics.njk","hash":"ad197fd728dd7ac90f910fdf80ce848eab3ff187","modified":1638328041085},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/index.njk","hash":"2d36a481a70d5f450f1f166dc556ac1218b18537","modified":1638328041085},{"_id":"themes/hexo-theme-next-master/layout/_third-party/chat/tidio.njk","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1638328041085},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/changyan.njk","hash":"5c2cd9b6f02bcb6248d3f18638a58e329fe8c0d1","modified":1638328041086},{"_id":"themes/hexo-theme-next-master/layout/_third-party/chat/chatra.njk","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1638328041085},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/disqus.njk","hash":"cc1450d62d76e59968bdd25836694b8339207384","modified":1638328041086},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/disqusjs.njk","hash":"54eab4840443262432ec7c47e56e9859ace2a902","modified":1638328041086},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/isso.njk","hash":"c1bf0753fc4bc5f21d61eaffbcc915a462c7d830","modified":1638328041087},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/gitalk.njk","hash":"089e05126e7e4033eff90a26f946c419f2a1e87a","modified":1638328041086},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/utterances.njk","hash":"7a07bbfb09ddf70b919f0ebe1b00942c96152389","modified":1638328041087},{"_id":"themes/hexo-theme-next-master/layout/_third-party/math/index.njk","hash":"47a982aec8830c2f9711b2aff59ff83f09deb09e","modified":1638328041087},{"_id":"themes/hexo-theme-next-master/layout/_third-party/math/katex.njk","hash":"b6746dfad32cc8a46ff8f4194a7a16ca41744803","modified":1638328041088},{"_id":"themes/hexo-theme-next-master/layout/_third-party/math/mathjax.njk","hash":"f4fd63b9f9230dadd1190f79d59313751925ed90","modified":1638328041088},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/livere.njk","hash":"6252b0353c6a36d03c68ebec1073293442221bd1","modified":1638328041087},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/algolia-search.njk","hash":"97035261aa85c7d39c6ce1211cdefc6248c0446d","modified":1638328041089},{"_id":"themes/hexo-theme-next-master/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1638328041089},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/localsearch.njk","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1638328041089},{"_id":"themes/hexo-theme-next-master/layout/_third-party/statistics/firestore.njk","hash":"0ff61346dc1327054ea2c211ba6fb654cdcdfd8d","modified":1638328041089},{"_id":"themes/hexo-theme-next-master/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1638328041090},{"_id":"themes/hexo-theme-next-master/layout/_third-party/statistics/lean-analytics.njk","hash":"811a3ad58c0a15550100bdc199bef8add1ad526c","modified":1638328041090},{"_id":"themes/hexo-theme-next-master/layout/_third-party/tags/pdf.njk","hash":"b6241ebbb091ef18b3d06cba08ac2e04e3f67a7d","modified":1638328041090},{"_id":"themes/hexo-theme-next-master/layout/_third-party/tags/mermaid.njk","hash":"007da98b913a62946c03a87f8fa25b3db856caa1","modified":1638328041090},{"_id":"themes/hexo-theme-next-master/scripts/events/lib/config.js","hash":"09b58494e9d9d25542d1d218f2d0ffc4d2da9f30","modified":1638328041093},{"_id":"themes/hexo-theme-next-master/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1638328041093},{"_id":"themes/hexo-theme-next-master/scripts/events/lib/injects.js","hash":"7b0ea8d28ced63977dc6539920eb044b1098adcb","modified":1638328041093},{"_id":"themes/hexo-theme-next-master/scripts/events/lib/vendors.js","hash":"d1ecc44f9f6e236bf910e36150767d36be4658b2","modified":1638328041094},{"_id":"themes/hexo-theme-next-master/scripts/events/lib/utils.js","hash":"b281be775b693f9bf32766c8f6ef703c72ac9b00","modified":1638328041093},{"_id":"themes/hexo-theme-next-master/scripts/filters/comment/changyan.js","hash":"ecc93ba67af26b6715fc75001fa0c3131b726241","modified":1638328041094},{"_id":"themes/hexo-theme-next-master/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1638328041094},{"_id":"themes/hexo-theme-next-master/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1638328041094},{"_id":"themes/hexo-theme-next-master/scripts/filters/comment/disqus.js","hash":"cc1e2d5921c6990f94f3cf11b1ff7533a21da9b7","modified":1638328041095},{"_id":"themes/hexo-theme-next-master/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1638328041137},{"_id":"themes/hexo-theme-next-master/scripts/filters/comment/disqusjs.js","hash":"32a1d9ad50621a78d0243e176c8b05ff7866fd5b","modified":1638328041095},{"_id":"themes/hexo-theme-next-master/scripts/filters/comment/gitalk.js","hash":"7c0533bac4400689a0d5ab3a188ce42b9375de46","modified":1638328041095},{"_id":"themes/hexo-theme-next-master/scripts/filters/comment/livere.js","hash":"60be56c9ba590e5bcb80d1607ca7eeedde9fdfaa","modified":1638328041095},{"_id":"themes/hexo-theme-next-master/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1638328041095},{"_id":"themes/hexo-theme-next-master/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1638328041096},{"_id":"themes/hexo-theme-next-master/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1638328041137},{"_id":"themes/hexo-theme-next-master/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1638328041137},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1638328041123},{"_id":"themes/hexo-theme-next-master/source/js/cursor/clicklove.js","hash":"f6aafbb3cdbcb54acb66cad0e0ead2de1b46c486","modified":1638328041132},{"_id":"themes/hexo-theme-next-master/source/css/_variables/base.styl","hash":"32a1b73944561655087d80f025208a84e012b3cf","modified":1638328041124},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1638328041123},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1638328041123},{"_id":"themes/hexo-theme-next-master/source/js/schemes/muse.js","hash":"9d15d0d6a58b1df74827288f117af22b4b6aafe5","modified":1638328041133},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1638328041124},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/back-to-top.styl","hash":"ece860218125bdb2578f373ed4f5040c9670e4b1","modified":1638328041102},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/index.styl","hash":"3c7ae405dd30b9b46494a6b9a6cb1b7ec6138ba9","modified":1638328041102},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/index.styl","hash":"0c9f72ad98807521cbdcee7b5bbe2e884311db39","modified":1638328041110},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/back-to-top-sidebar.styl","hash":"d4809783ded05625675b1b4bbd9e99d7f5f7d7f9","modified":1638328041102},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1638328041113},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1638328041113},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/reading-progress.styl","hash":"ee8fb8348aa76a9b346927ba4cae5666d8d777f7","modified":1638328041106},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1638328041113},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1638328041115},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/base.styl","hash":"db5ddaa8fd2101b0fd7108ce4bbcb9f0649fa223","modified":1638328041113},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/pagination.styl","hash":"41cba8c4c5637a6b8f1b62e67673b33676f5d734","modified":1638328041115},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1638328041115},{"_id":"themes/hexo-theme-next-master/source/js/cursor/text.js","hash":"05d93476a210c60b3c09afdbf4ce04de5ff55115","modified":1638328041132},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/mobile.styl","hash":"9f88d350df8115d26c6adbc2025a27ef9a42d7ff","modified":1638328041110},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1638328041119},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1638328041119},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1638328041119},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1638328041120},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1638328041118},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1638328041120},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_menu.styl","hash":"8a70d51d8f7cd113e5fbc9f0e70c46a072f282c8","modified":1638328041120},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_sidebar.styl","hash":"87e163de866938c668ec33e6ff8972b7a968e0af","modified":1638328041121},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1638328041121},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1638328041121},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_header.styl","hash":"be5c46b983df08b9dbac1b4749b1a101b54b6b50","modified":1638328041121},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_menu.styl","hash":"357b899ac0f0dfbbbebf1ea972030c7cefa463ce","modified":1638328041119},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_posts-expand.styl","hash":"b332868d76d9f1651efd65abfc0d3c9d699b1a45","modified":1638328041119},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_menu.styl","hash":"dc68f16eceaa006e9735d7ff7821af7f4ef50979","modified":1638328041122},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1638328041120},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1638328041122},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1638328041102},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1638328041103},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1638328041103},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1638328041103},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-body.styl","hash":"5d61dedb3bec1021d52894f9b379e4d0953f6a35","modified":1638328041104},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1638328041103},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/index.styl","hash":"b3fa752f72ca1413289b76c56fbd33a00e3d25d7","modified":1638328041104},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1638328041105},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1638328041122},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1638328041105},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-header.styl","hash":"967021e5483495bdefac9e0b3e1c84c366c657fd","modified":1638328041105},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1638328041105},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-reward.styl","hash":"b1181c5f12a70b8bf710586fcb0d7959841ee512","modified":1638328041106},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1638328041106},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1638328041105},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/index.styl","hash":"b457756758f0632767e8a560e3033059cbe4a67b","modified":1638328041107},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/math.styl","hash":"83c6588c51cd418336f4945813410a100ddfe2a4","modified":1638328041107},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1638328041122},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-followme.styl","hash":"76d0dfb3a8b873a6180604ac6daecf38b6a963a2","modified":1638328041105},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/gitalk.styl","hash":"7102f8e819b62cf7d121fd063dc663fd068feaa6","modified":1638328041106},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/footer/index.styl","hash":"f11dca93e334b68a29e792f7abe682993fab7568","modified":1638328041108},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/related-posts.styl","hash":"2c534d2b2dbc932ad65d335a720a7ba9612bac04","modified":1638328041107},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/header/github-banner.styl","hash":"cf194bea1c9e67fde871a04de3bc81df72c54277","modified":1638328041109},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/header/index.styl","hash":"f1778d2c56974b96dae429456d5c55be325c4946","modified":1638328041109},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1638328041109},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_sidebar.styl","hash":"2d337a12c5c668ee64447bda5a9ed64eaed5b29e","modified":1638328041122},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/header/site-meta.styl","hash":"9a47c9045e443b8d20932f9c564a3a05fa4c6b51","modified":1638328041109},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/header/site-nav.styl","hash":"9c8abc55c9d94d384a245013951aba5ecca2f4fe","modified":1638328041109},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/sidebar/index.styl","hash":"d180871d4440090241fc988736c1f3a7efb4b1ba","modified":1638328041110},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1638328041110},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1638328041111},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1638328041110},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"ab715dbf2b98bfeb5e7b7c43e92e5c02496cc2ea","modified":1638328041111},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1638328041111},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"f7ff85fe6c4efb8ff036fab2c3277b7d8bed69a8","modified":1638328041112},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"6394340c28a21f6aa90e786f3bfe24fb26595653","modified":1638328041112},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"432e73bc4f99322af6af1852e0ea6e674919c31a","modified":1638328041112},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/sidebar/site-state.styl","hash":"69eb1c282a8fd5dbab606cc09c34c5dc8e44e753","modified":1638328041112},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/highlight/index.styl","hash":"08e79881d58d01afab6dbed37ab4f52356564d7e","modified":1638328041113},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/utterances.styl","hash":"bf88d9c585d7b00463c46352402cfea415c29493","modified":1638328041108},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"15a5e273a8137550c93c8d2a60f9fcf86e04a89e","modified":1638328041116},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1638328041116},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tags/index.styl","hash":"cef4e779473daa3761709958243c6b8a57bbd814","modified":1638328041116},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1638328041116},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tags/link-grid.styl","hash":"79ffcf92771cd48f4a686f9d8d7d610f39e9fc1f","modified":1638328041116},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/header/bookmark.styl","hash":"d6d60f02b5e9f89dbfce180b3884030898022664","modified":1638328041108},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1638328041113},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tags/note.styl","hash":"f53e6c12bd4805888f696386d00668f23cd335e7","modified":1638328041117},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tags/tabs.styl","hash":"50b00218e854200c4ec0573a841e226d49c45cba","modified":1638328041117},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tags/mermaid.styl","hash":"3c029a003e9bf747e1b9cc7c0c127f6028374876","modified":1638328041117},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/search.styl","hash":"2896840ab8ac8ab2a7f76d18df893f290ac31625","modified":1638328041107},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1638328041117},{"_id":"themes/hexo-theme-next-master/source/uploads/custom-logo.jpg","hash":"01198fcf3dedc45974246e35096f401efe27471d","modified":1638328041134},{"_id":"themes/hexo-theme-next-master/source/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1638328041126},{"_id":"themes/hexo-theme-next-master/source/images/blossom.jpg","hash":"ff616f49ef3b37a3a8c9b1737de78b18046e9b38","modified":1638950955585},{"_id":"source/images/snow_mountain.jpg","hash":"c2c540865483b3abf9ce087753d25bd6f437775f","modified":1638328041055},{"_id":"themes/hexo-theme-next-master/source/images/background.jpg","hash":"c2c540865483b3abf9ce087753d25bd6f437775f","modified":1638950955584},{"_id":"public/baidusitemap.xml","hash":"955968b30ae06f50fa94c91806a1641d367e0ccd","modified":1658720631708},{"_id":"public/sitemap.xml","hash":"a65713043de407d2a24cd519439f1050dd9c2870","modified":1658720631708},{"_id":"public/about/index.html","hash":"038c52c93cc067b6f26421a97531a41bf0866c3a","modified":1658720631708},{"_id":"public/tags/index.html","hash":"4d8a3caea394d9418bc63eaf1beda0133c3370a1","modified":1658720631708},{"_id":"public/categories/index.html","hash":"79d0f51cfcac6ec77651260d6ded4ba9d1e315cc","modified":1658720631708},{"_id":"public/works/index.html","hash":"e57b8d47548c819b9c727e399d0fa4c6d0a69ff4","modified":1658720631708},{"_id":"public/2020/03/18/Pycharm中打不开Python-Console-le/index.html","hash":"9a1f965278422d90559ae7f6e1a88e43925ce20f","modified":1658720631708},{"_id":"public/2019/04/28/随感0428/index.html","hash":"dea2121b298873fa2731413c02512967c5fcb096","modified":1658720631708},{"_id":"public/2018/07/05/随感0705/index.html","hash":"b5d55aaba3d944407a09e5e55b6b92aff858b8d9","modified":1658720631708},{"_id":"public/archives/page/5/index.html","hash":"b4a364d6528d7044f37cfe9c3491949b7370c558","modified":1658720631708},{"_id":"public/archives/2018/index.html","hash":"fd29005e31a09e0c914bab2fa1da39b193b96964","modified":1658720631708},{"_id":"public/archives/2018/04/index.html","hash":"1f0ef126b55808731cea0865a93df0d2c523b3af","modified":1658720631708},{"_id":"public/archives/2018/06/index.html","hash":"77fa12723510867385c0bda0a0244ab45a0984d8","modified":1658720631708},{"_id":"public/archives/2018/07/index.html","hash":"df935de731dde50b72a1ebd5aabafff336933ae4","modified":1658720631708},{"_id":"public/archives/2019/page/2/index.html","hash":"c0e2ef8d094ce15bcf5c486ca06dae91fb02708f","modified":1658720631708},{"_id":"public/archives/2019/02/index.html","hash":"7ab18e5e89796ba7fb496d667794080809800b99","modified":1658720631708},{"_id":"public/archives/2019/04/index.html","hash":"a4baed57461a553537604d73a2cda673581127e8","modified":1658720631708},{"_id":"public/archives/2019/05/index.html","hash":"3e72587586af26b47a499daee10b444c42bdf756","modified":1658720631708},{"_id":"public/archives/2019/06/index.html","hash":"0fc09347bacb2b942ffcd90ba70f757719a87a36","modified":1658720631708},{"_id":"public/archives/2019/09/index.html","hash":"2c77dd712032be198caf9a13ac8ebaa04c50c014","modified":1658720631708},{"_id":"public/archives/2019/10/index.html","hash":"f6b816532cfd9f02e24a1d12e0ed7b7d1d909717","modified":1658720631708},{"_id":"public/archives/2019/12/index.html","hash":"3a86dc969908ec31b42304c2d8a997b5483c2f36","modified":1658720631708},{"_id":"public/archives/2020/page/2/index.html","hash":"2761cefae09dc26c60e66c5220e55dce57a2dcb1","modified":1658720631708},{"_id":"public/archives/2020/01/index.html","hash":"0b3e9897f150cd23e4caf4323534a83cccef20d7","modified":1658720631708},{"_id":"public/archives/2020/02/index.html","hash":"c91e4c8bf43edab232247d12776491e7a22b1f41","modified":1658720631708},{"_id":"public/archives/2020/03/index.html","hash":"47701922a4772535aa3bcd2a394d00e735827633","modified":1658720631708},{"_id":"public/archives/2018/12/index.html","hash":"6019d8dfa9b8250b735bd7357cc93bc3482dea61","modified":1658720631708},{"_id":"public/archives/2020/04/index.html","hash":"69384d805e82d372b307ede59fad667da7f1b165","modified":1658720631708},{"_id":"public/archives/2020/07/index.html","hash":"83c1f5a9b60ea5332088a69fba8d0dae752563e4","modified":1658720631708},{"_id":"public/archives/2020/09/index.html","hash":"7fdaa55b6546eb4d2c43ce641ea1df7a2ba01742","modified":1658720631708},{"_id":"public/archives/2020/10/index.html","hash":"62d8c1573623d5703f836b17a53ac1a86c437807","modified":1658720631708},{"_id":"public/archives/2021/01/index.html","hash":"816bed045ca9f4224df6f27ba3e1192f26cf4d51","modified":1658720631708},{"_id":"public/archives/2021/02/index.html","hash":"d3941f31cdd6998bae954bfc5f8f6af1ac1ea355","modified":1658720631708},{"_id":"public/archives/2021/03/index.html","hash":"b7c9a61fe012265285b7bf223630fd6af3bb99f0","modified":1658720631708},{"_id":"public/archives/2021/04/index.html","hash":"b023715158f9a804538b3f13a1ad153676c77d68","modified":1658720631708},{"_id":"public/archives/2021/11/index.html","hash":"8a2ff5e5be098e7108fcc1eb023e71544bdb6251","modified":1658720631708},{"_id":"public/archives/2021/12/index.html","hash":"fe5c9908d871bd2faa25d0528b1fac5bd1c94c1e","modified":1658720631708},{"_id":"public/archives/2022/index.html","hash":"a9d936aa9b0a65075c02a834fd30fa9e8f869527","modified":1658720631708},{"_id":"public/archives/2022/01/index.html","hash":"b9b4a12cb2ed05ec70232ed24631d551c46d7609","modified":1658720631708},{"_id":"public/archives/2022/02/index.html","hash":"0e481b33e8268c2e183dda225e37ef7127029341","modified":1658720631708},{"_id":"public/archives/2022/03/index.html","hash":"13380ea69174a7165c617f4c2a6a7b0d6afc5524","modified":1658720631708},{"_id":"public/archives/2022/04/index.html","hash":"dfb9e8a7f0f195a76d3107c230400dc80eb17f19","modified":1658720631708},{"_id":"public/categories/生活Life/page/2/index.html","hash":"78b67b3f5e222916411293cb42e01dc6a3138aea","modified":1658720631708},{"_id":"public/categories/DailyCode/index.html","hash":"994be2265bc38e0753452c64c51d76846b7609ce","modified":1658720631708},{"_id":"public/categories/问题解决SolvedProblems/index.html","hash":"70896a8d039309405357ea857746b835b6993dd4","modified":1658720631708},{"_id":"public/categories/学习Learning/index.html","hash":"c4079ed6f301eda09ea6e9e838c5dc1d98c53251","modified":1658720631708},{"_id":"public/categories/Java/index.html","hash":"a470cb4cda4be292112b5d9083966d1a017559b6","modified":1658720631708},{"_id":"public/categories/刷题/index.html","hash":"ae436ee653a39720978f89c36375e57578f2ca59","modified":1658720631708},{"_id":"public/categories/读书笔记ReadingNotes/index.html","hash":"0c948415b54bcaed9c8c14888bf3ce37170555f1","modified":1658720631708},{"_id":"public/categories/科研Research/index.html","hash":"b9cb126a68a18487c042612307c06be6c125593f","modified":1658720631708},{"_id":"public/categories/ResearchLife/index.html","hash":"c8084958ef9be6abfcfb2f267ed7959c87298251","modified":1658720631708},{"_id":"public/categories/课程设计/index.html","hash":"c431bf9b20c7473ef25eda847068d4caeadfaf75","modified":1658720631708},{"_id":"public/categories/杂七杂八Unclassified/index.html","hash":"0161568702bc29c6665bb4c4c86b8e45c03483db","modified":1658720631708},{"_id":"public/categories/研究生生活/index.html","hash":"bb7cb5a5f30f17a5b1cdb8d7e49a3b0cbb4806b2","modified":1658720631708},{"_id":"public/categories/编译原理CompilerPrinciple/index.html","hash":"bf54960c0dca4cbf02a174bc097a633c78cd8835","modified":1658720631708},{"_id":"public/categories/学习LearnSomething/index.html","hash":"855b89c1972f2a4dc621c29b6a3c5c260c1553ce","modified":1658720631708},{"_id":"public/tags/Colab/index.html","hash":"9c1bddd89b4f51fcbacfe3a85d9ff268a2847d13","modified":1658720631708},{"_id":"public/tags/Python/index.html","hash":"469b2e4cb48123217bc34e20e67169cdd07c7d41","modified":1658720631708},{"_id":"public/tags/刷题/index.html","hash":"4eb8160ddf1f2b48542c0c514176a3a1597c337b","modified":1658720631708},{"_id":"public/tags/Leetcode简单题/index.html","hash":"acfb6ee8f6d19765c3fe0ed2f4ca1a70e5f2417a","modified":1658720631708},{"_id":"public/tags/模拟/index.html","hash":"445fe629d8ab9b384a3b1b451cfb3d5ab41f7491","modified":1658720631708},{"_id":"public/tags/滑动窗口/index.html","hash":"e152a5565d21b413bdf742797b776b604661f390","modified":1658720631708},{"_id":"public/tags/双指针/index.html","hash":"723a63066dbead7dbc605799e5f10aea531225f0","modified":1658720631708},{"_id":"public/tags/转载/index.html","hash":"c68a1d29d636ed912c8c9ac98a2ddb075d50b239","modified":1658720631708},{"_id":"public/tags/搭建博客/index.html","hash":"c17e8451e17d0acef1cc67125e66c3cbf20160ac","modified":1658720631708},{"_id":"public/tags/小样本/index.html","hash":"1b73e85cb5ef7a3a11384b9a333d41287d36b280","modified":1658720631708},{"_id":"public/tags/数据扩增/index.html","hash":"054270ef68fe94715ee118d822a567e51a528444","modified":1658720631708},{"_id":"public/2022/04/03/Leetcode刷题之动态规划/index.html","hash":"efa3bf74739559651e67d086be3ae74bab2a96cb","modified":1658720631708},{"_id":"public/2022/03/25/随笔0325/index.html","hash":"00cca644d5c83d009cb60fafa4975dea028d05f7","modified":1658720631708},{"_id":"public/2022/02/13/Leetcode刷题之滑动窗口/index.html","hash":"bfb0a31755fdd6172088446a72f25afa14b99692","modified":1658720631708},{"_id":"public/2022/02/10/Leetcode刷题之双指针/index.html","hash":"7e1eaf7acff7e160a9cc91dac9ca30d331d1478c","modified":1658720631708},{"_id":"public/2022/01/11/Leetcode刷题之模拟/index.html","hash":"71f2c5fd6dca77887479e4e42e204479746629e2","modified":1658720631708},{"_id":"public/2021/12/29/Leetcode刷题之链表/index.html","hash":"af069dfdb96fbc95c3b78c482699ae1173ab4e7d","modified":1658720631708},{"_id":"public/2021/12/08/Java核心技术卷1笔记-2/index.html","hash":"63005e1339de3869c2706cee4bdce0cc2f80fd4e","modified":1658720631708},{"_id":"public/2021/11/30/Java核心技术卷1笔记-1/index.html","hash":"d671f57a6039cf78cc9050b7fd21e40f881dbd66","modified":1658720631708},{"_id":"public/2021/04/11/如何做文献阅读笔记/index.html","hash":"7be171b76d33a77b3e34a1388d3e3a2edd7762ea","modified":1658720631708},{"_id":"public/2021/03/31/Colab运行python代码找不到路径/index.html","hash":"3f68000a91764a4e04616695a561ff551b4215e2","modified":1658720631708},{"_id":"public/2021/03/28/小样本数据扩增总结/index.html","hash":"e99ce20bed19df6f28011d6d4aff756698b826c2","modified":1658720631708},{"_id":"public/2021/02/21/Leetcode-0221/index.html","hash":"99e9807ec9e1d3be9de642f996d0dec25cdc6a8b","modified":1658720631708},{"_id":"public/2021/01/11/Leetcode-0106/index.html","hash":"b97648601149e7792a5947c51bbecabceec4df7c","modified":1658720631708},{"_id":"public/2020/10/05/研究生生活的第二周/index.html","hash":"65625ab5d37c49bd0327c9a8247076bf2e516c6c","modified":1658720631708},{"_id":"public/2020/09/27/研究生生活的第一周/index.html","hash":"44caa02f0dc45d4b4d1bd20702d576fab829996c","modified":1658720631708},{"_id":"public/2020/07/29/Deep-Learning学习笔记/index.html","hash":"31fe1d2441c2b2fec472e37f44f3ba794ad6bbf3","modified":1658720631708},{"_id":"public/2020/07/09/组会笔记/index.html","hash":"b6bad65cacb39b52670c2bcb38244c7deb98800e","modified":1658720631708},{"_id":"public/2020/04/07/三月观影读书/index.html","hash":"c3dda4b391ff2eca5464b4c7f62ed906d3677036","modified":1658720631708},{"_id":"public/2020/02/12/Python学习-Day4/index.html","hash":"70daed940525e008b3fdcecb90db6ab255c7c90e","modified":1658720631708},{"_id":"public/2020/02/08/Python学习-Day3/index.html","hash":"a18aaec1bc4f2624f6bef3bde4b321d692d97110","modified":1658720631708},{"_id":"public/2020/02/07/Python学习-Day2/index.html","hash":"afda020859e9ed6387c7bec2ad80e80695099b8d","modified":1658720631708},{"_id":"public/2020/02/06/Python学习-Day1/index.html","hash":"4458dbc79a5a8b5c34d07deb4fe74a631b4def3f","modified":1658720631708},{"_id":"public/2020/01/10/Reflect-on-2019-2019复盘-2020计划/index.html","hash":"2c1aa561d666b0577404e66fafd94a7b1989b132","modified":1658720631708},{"_id":"public/2019/12/10/《流星雨》读书笔记/index.html","hash":"0f1b5e43a4e5cc1166df7c5479e470e0937c176f","modified":1658720631708},{"_id":"public/2019/10/09/九月观影看书/index.html","hash":"592fec61fcdce6afc41633765e9d541152c97f88","modified":1658720631708},{"_id":"public/2019/09/13/《数学之美》读书笔记-1/index.html","hash":"d5332592b3daa9bbc378da23172165708b665d32","modified":1658720631708},{"_id":"public/2019/06/20/Coding0620/index.html","hash":"67f1530035e35d3bfb9c14f6c1b274ba864e402f","modified":1658720631708},{"_id":"public/2019/06/20/操作系统课设-1/index.html","hash":"769ec959ba6a776bbab38528c6fe28ffc0f369ec","modified":1658720631708},{"_id":"public/2019/06/18/Coding0618/index.html","hash":"ed23a82ba1ceed070fdaa5a761c4deeabed9d263","modified":1658720631708},{"_id":"public/2019/06/10/随感0609/index.html","hash":"ad0f001e97d3fc2753be600e1194462f874e2931","modified":1658720631708},{"_id":"public/2019/05/04/四月读书观影分享/index.html","hash":"685bba66531ca2f50ccfb0adc86a698009524269","modified":1658720631708},{"_id":"public/2019/04/26/最大匹配算法与隐马尔科夫模型-中文分词-NLP/index.html","hash":"9c5523ac36e9e111ac0bb880acd1aa9584e6fb0c","modified":1658720631708},{"_id":"public/2019/04/05/3月读书观影分享/index.html","hash":"f6c219ad2eddc6f11e9c1b748d96993fcad78f2a","modified":1658720631708},{"_id":"public/2019/02/28/二月观影看剧分享-影评-剧评/index.html","hash":"bb6d1cf1a73155b1834ecadb3d62f7bfdba54938","modified":1658720631708},{"_id":"public/2019/02/25/小李的新年flag-新年-新学期-21岁-目标-随感/index.html","hash":"bc0ff7a6efd8d6a823a21f74d6d66a1c59627585","modified":1658720631708},{"_id":"public/2019/02/15/Android新手路上一些坑-Android-Studio-Android-SDK-新手上路指南/index.html","hash":"c81b74c2da7783f0f28890c8605387eb8d7f4795","modified":1658720631708},{"_id":"public/2018/12/06/脚本学习/index.html","hash":"7bd03c5609ddc6706cf78385c31277342eee93a2","modified":1658720631708},{"_id":"public/2018/06/19/编译原理之LR-1-分析/index.html","hash":"107cd1eadeaf96641d3a0f624966de6933f9d4c1","modified":1658720631708},{"_id":"public/2018/04/16/在用hexo和github搭建个人博客中遇到的问题及解决办法/index.html","hash":"7de90a089f0c4c615ebcb2cb0d33111b6eb58881","modified":1658720631708},{"_id":"public/2018/04/15/第一篇文章/index.html","hash":"bf9c52cdb2a899c819a72b849386ae1109397dea","modified":1658720631708},{"_id":"public/archives/index.html","hash":"332ebec21853bc88e26f420f29785650253d5bb2","modified":1658720631708},{"_id":"public/archives/page/2/index.html","hash":"3e8995163171e596fd9a9fdf646831c7d0777ff6","modified":1658720631708},{"_id":"public/archives/page/3/index.html","hash":"b2175dce6d0d2b8bb015d528897c53c3d5b3859b","modified":1658720631708},{"_id":"public/archives/page/4/index.html","hash":"f9f976dd479dc37aeed3b1acdfacc429abf1fa90","modified":1658720631708},{"_id":"public/archives/2019/index.html","hash":"187686ec6db64cea51a5c7edd9fafdf4caf63cfe","modified":1658720631708},{"_id":"public/archives/2020/index.html","hash":"8e339d5aa0afec5d4961bbf6e01f06e8323f0075","modified":1658720631708},{"_id":"public/archives/2021/index.html","hash":"e92f0fe9595d4c7ea82840cbf57260af4613e040","modified":1658720631708},{"_id":"public/categories/生活Life/index.html","hash":"f6ec257d9bbdd445573d1aa21e7b6f9d00a6dd8f","modified":1658720631708},{"_id":"public/index.html","hash":"fe6e448aa01442a400207932b31f49cb09d618b1","modified":1658720631708},{"_id":"public/page/2/index.html","hash":"d0a89032df07d744460daebe978f66d6c97944c9","modified":1658720631708},{"_id":"public/page/3/index.html","hash":"335382a82d3d4bc7f5f6e39c32c798f8f92d95fd","modified":1658720631708},{"_id":"public/page/4/index.html","hash":"f9692b87a4b5f4f2fc9328aaf5664f939e38fcaf","modified":1658720631708},{"_id":"public/page/5/index.html","hash":"927050c30e2ad94b297bb3ff1525bc84672cf28c","modified":1658720631708},{"_id":"public/CNAME","hash":"ba43a796648d64d74ed79d25eafeff9813e0da35","modified":1648997087514},{"_id":"public/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1648997087514},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1648997087514},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1648997087514},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1648997087514},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1648997087514},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1648997087514},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1648997087514},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1648997087514},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1648997087514},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1648997087514},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1648997087514},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1648997087514},{"_id":"public/images/heart_bulb_stars_32x32.ico","hash":"ada310e120ce34cbc69fbd9d305d7454fdafee96","modified":1648997087514},{"_id":"public/images/heart_bulb_stars_16x16.ico","hash":"6e5d4b6104fc4a34095dbdd25aba28508ed9feba","modified":1648997087514},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1648997087514},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1648997087514},{"_id":"public/live2dw/assets/exp/f01.exp.json","hash":"84073a497ddb6e56c6cfc244a0fb217ba473abf9","modified":1648997087514},{"_id":"public/live2dw/assets/exp/f02.exp.json","hash":"241b6afafa2e25c6d7a54692a8b5aa060a137ab1","modified":1648997087514},{"_id":"public/live2dw/assets/exp/f03.exp.json","hash":"fbf7729e504f14f83f976827fcf62301a6579a34","modified":1648997087514},{"_id":"public/live2dw/assets/exp/f04.exp.json","hash":"35e746ede62e7090e7dfb08561d77772f58b4153","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/idle_00.mtn","hash":"378b4577217c604c9d28ab4edf8b707c8d8c2fbb","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/idle_01.mtn","hash":"88c2494655dbb712b842f03232b619f381753d52","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/idle_02.mtn","hash":"7f5d2cf8706007c8659938eba132a68c470a4c26","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/flickHead_00.mtn","hash":"f64c79c9171660db5c440bef229ac2e35a1597d5","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/pinchIn_00.mtn","hash":"70978b4c983f6a9fd6d3d9c24571586f7d6eac30","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/flickHead_02.mtn","hash":"d3c9c0acb4dc25a2274f3b9faa71e5ce60ad92e4","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/pinchOut_01.mtn","hash":"e05df948d08b17f34c993a9c1f901190509d5db0","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/pinchIn_02.mtn","hash":"aa0d66ca9b06c374577fd7e64e89756de1e1f2ae","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/pinchIn_01.mtn","hash":"a5fefb45115695db72b9499e627a51b2b9394f2c","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/flickHead_01.mtn","hash":"a1011d6bf397bcd3c3c968d9616f88fe1ffbc83c","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/pinchOut_00.mtn","hash":"e07fe8fd8c2810e3c1d28b730bd49c8c25849bad","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/shake_00.mtn","hash":"5185d02c7ab9f0bec3d4a890b54b2378e553373d","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/pinchOut_02.mtn","hash":"b323fd350d334b33bbdfb31194ae664089986c27","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/shake_02.mtn","hash":"2702970805e07777974c383613e631730982bcff","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/shake_01.mtn","hash":"e812985a56796e122018f9d57d1606a4866ff7d1","modified":1648997087514},{"_id":"public/live2dw/assets/shizuku.model.json","hash":"19a05bd41b806a935cea42c2000626fc82da2536","modified":1648997087514},{"_id":"public/live2dw/assets/shizuku.pose.json","hash":"ac5505efbf80ba0a2e5783d67fe232bc5c6f1f80","modified":1648997087514},{"_id":"public/live2dw/assets/shizuku.physics.json","hash":"6484d646e79a44c83784c6ae434cf7349746c5c8","modified":1648997087514},{"_id":"public/live2dw/assets/snd/flickHead_00.mp3","hash":"356388d939006b03cf9e6158c603b58d4800bec1","modified":1648997087514},{"_id":"public/live2dw/assets/snd/flickHead_01.mp3","hash":"436d0bbccf6e7a2744447554947eee4563608970","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/tapBody_02.mtn","hash":"a75acb51c1191ce5050d3ee1af6f2dcc787c7c5e","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/tapBody_00.mtn","hash":"835aa3d4a8fbd26c0bb66b164a19464fa3f17a99","modified":1648997087514},{"_id":"public/live2dw/assets/mtn/tapBody_01.mtn","hash":"78fca17436ab5e065e27f419f135aa6c0a0b52ef","modified":1648997087514},{"_id":"public/live2dw/assets/snd/flickHead_02.mp3","hash":"5f63477ce63f2073e24d68fea906fe136fe6349e","modified":1648997087514},{"_id":"public/live2dw/assets/snd/pinchIn_00.mp3","hash":"f9baa3b7cadec20b714135fc49cfab3ff6adeeb4","modified":1648997087514},{"_id":"public/live2dw/assets/snd/pinchIn_01.mp3","hash":"d5c8cc6f61b56222a83a5174f75006f83c3b88da","modified":1648997087514},{"_id":"public/live2dw/assets/snd/shake_00.mp3","hash":"f65dd58e7b44ec5c865d13c190316070b625b5fe","modified":1648997087514},{"_id":"public/live2dw/assets/snd/shake_01.mp3","hash":"c1e0e8a07ff268ee06c2b7825d1b645e193f21b9","modified":1648997087514},{"_id":"public/live2dw/assets/snd/tapBody_01.mp3","hash":"5314b50f153df71559e51e2586581c006df00722","modified":1648997087514},{"_id":"public/live2dw/assets/snd/tapBody_00.mp3","hash":"003e68a59a9c8392e230f34c91860efbd946277a","modified":1648997087514},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1648997087514},{"_id":"public/live2dw/assets/snd/shake_02.mp3","hash":"8882b94bce00f09232588b7301badb105fa8acab","modified":1648997087514},{"_id":"public/live2dw/assets/snd/tapBody_02.mp3","hash":"15e7815ed0a0e5164e18e0c53b97aedc742a134d","modified":1648997087514},{"_id":"public/images/blossom-wallpaper.jpg","hash":"e5baacab9de10b85172d28fef9291f9ffef96b80","modified":1648997087514},{"_id":"public/uploads/custom-logo.jpg","hash":"01198fcf3dedc45974246e35096f401efe27471d","modified":1648997087514},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_00.png","hash":"21bdb28b31783e23b26b3aa061e90be4088665aa","modified":1648997087514},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_03.png","hash":"07f568a2bb8045b6bdff7783fb4daf62c821f9ab","modified":1648997087514},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_05.png","hash":"0cd00007fb8bff62a2eb08e1d7c43abab8722224","modified":1648997087514},{"_id":"public/live2dw/assets/snd/pinchOut_02.mp3","hash":"554edb2f3838cbdc27d1a9c6b8a9cb6eb465cbdd","modified":1648997087514},{"_id":"public/live2dw/assets/snd/pinchOut_01.mp3","hash":"8a081030fd53c07bffe3edd48f87a371ca77296b","modified":1648997087514},{"_id":"public/live2dw/assets/snd/pinchOut_00.mp3","hash":"0654f38f6e9fd623eaf8be11b5d58c9d12991949","modified":1648997087514},{"_id":"public/live2dw/assets/snd/pinchIn_02.mp3","hash":"5b63e02607571ac601c500995e836e6c861b1c62","modified":1648997087514},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1648997087514},{"_id":"public/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1648997087514},{"_id":"public/images/blossom.jpg","hash":"ff616f49ef3b37a3a8c9b1737de78b18046e9b38","modified":1648997087514},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_01.png","hash":"3d0e745f3e560071ee08beeecde186e5ea35d99e","modified":1648997087514},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_04.png","hash":"f764d594841905db8b2998dd61c329866125ad97","modified":1648997087514},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1648997087514},{"_id":"public/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1648997087514},{"_id":"public/dist/music.js","hash":"c875ea9bf617bb7822a4da427130532a27137f66","modified":1648997087514},{"_id":"public/js/algolia-search.js","hash":"a360423984cdd915d04365c51bcab440e52d7223","modified":1648997087514},{"_id":"public/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1648997087514},{"_id":"public/js/local-search.js","hash":"da2051e7cab184ae4aa64457c5db7476b4645fdc","modified":1648997087514},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1648997087514},{"_id":"public/js/next-boot.js","hash":"c2a04055d8edec03dc74e1c45d83bd3b51467de0","modified":1648997087514},{"_id":"public/js/utils.js","hash":"fcb84304fc3ba06f8c4f840fe1e0843339e0899d","modified":1648997087514},{"_id":"public/js/schedule.js","hash":"71d62fc3584c47ff2d4cc945226e412264399be9","modified":1648997087514},{"_id":"public/js/cursor/clicklove.js","hash":"f6aafbb3cdbcb54acb66cad0e0ead2de1b46c486","modified":1648997087514},{"_id":"public/js/cursor/text.js","hash":"05d93476a210c60b3c09afdbf4ce04de5ff55115","modified":1648997087514},{"_id":"public/js/schemes/muse.js","hash":"9d15d0d6a58b1df74827288f117af22b4b6aafe5","modified":1648997087514},{"_id":"public/css/main.css","hash":"a0e9041c30bc15011116d43ec1dba7bfe9400206","modified":1648997087514},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_02.png","hash":"055eb2da9c13e9116be93a1e60c0ea2b660af864","modified":1648997087514},{"_id":"public/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1648997087514},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1648997087514},{"_id":"public/live2dw/assets/moc/shizuku.moc","hash":"c2670a0f75830edc89d7fe6d074de4ee67e8dc5d","modified":1648997087514},{"_id":"public/images/background.jpg","hash":"c2c540865483b3abf9ce087753d25bd6f437775f","modified":1648997087514},{"_id":"public/images/snow_mountain.jpg","hash":"c2c540865483b3abf9ce087753d25bd6f437775f","modified":1648997087514},{"_id":"source/_posts/牛客后端项目（2）-注册模块开发.md","hash":"393f857eb7023a136802a21ed641ee15b8f3b183","modified":1657014570082},{"_id":"public/archives/2022/07/index.html","hash":"1b5350f2280edce8b7e3e02ff36fe5ece154027c","modified":1658720631708},{"_id":"public/categories/项目开发笔记/index.html","hash":"eae999ca4d01af15b0789cb6f756a8e6c60944d5","modified":1658720631708},{"_id":"public/tags/牛客网后端/index.html","hash":"e66058483d704024b832c1c5d7f8b0f375b258ed","modified":1658720631708},{"_id":"public/2022/07/05/牛客后端项目（2）-注册模块开发/index.html","hash":"629ac961dbd6a6ddc30ad7616da83a9726821aff","modified":1658720631708},{"_id":"source/_posts/牛客后端项目（3）-登录模块开发.md","hash":"e369d62549b6e5e76c03dbf9d26ba30e07c44e5a","modified":1657268586754},{"_id":"public/2022/07/08/牛客后端项目（3）-登录模块开发/index.html","hash":"2ef2eeb5fbf2b04b5185c97d63024b0d0b44803e","modified":1658720631708},{"_id":"source/_posts/牛客后端项目（4）-帖子模块开发.md","hash":"e3e8e81429025bbd5acc528712e431e25d8d6ccd","modified":1658720958654},{"_id":"public/2022/07/25/牛客后端项目（4）-帖子模块开发/index.html","hash":"8f36d296116a254b8533f10ff85a5e61e20e3e71","modified":1658720977859},{"_id":"source/images/sea-wave.jpg","hash":"6724becdd05fbe36f42626238defbc04b6d10ff5","modified":1658721777539},{"_id":"public/images/sea-wave.jpg","hash":"6724becdd05fbe36f42626238defbc04b6d10ff5","modified":1658721941728}],"Category":[{"name":"生活Life","_id":"cl1jeaggg000638t43y8g67h4"},{"name":"DailyCode","_id":"cl1jeaggm000f38t41si5adk1"},{"name":"问题解决SolvedProblems","_id":"cl1jeaggo000k38t47a3r0276"},{"name":"学习Learning","_id":"cl1jeaggt001038t42ejq8uba"},{"name":"Java","_id":"cl1jeaggu001738t4018q12qk"},{"name":"刷题","_id":"cl1jeaggx001j38t4gqnsf2n7"},{"name":"读书笔记ReadingNotes","_id":"cl1jeagh5002c38t4fufg6mh1"},{"name":"科研Research","_id":"cl1jeagh8002o38t42txycyf3"},{"name":"ResearchLife","_id":"cl1jeaghb002v38t4fch894gx"},{"name":"课程设计","_id":"cl1jeaghc003238t4aweqhjx5"},{"name":"杂七杂八Unclassified","_id":"cl1jeaghe003a38t46aee2fh9"},{"name":"研究生生活","_id":"cl1jeaghf003g38t41plt0lin"},{"name":"编译原理CompilerPrinciple","_id":"cl1jeaghh003k38t491blhajg"},{"name":"学习LearnSomething","_id":"cl1jeaghh003n38t470xkcsyb"},{"name":"项目开发笔记","_id":"cl57yu4530001got472ap57zr"}],"Data":[{"_id":"styles","data":"body {\n  background: url(\"/images/sea-wave.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n"},{"_id":"project","data":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}],"Page":[{"title":"关于","date":"2021-03-29T10:27:09.000Z","type":"about","_content":"\n博客主人：栗子\n邮箱：li_wq22@163.com\n简介：计科研一在读，还是一只小小白，毕业后想进厂做开发💪","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2021-03-29 18:27:09\ntype: \"about\"\n---\n\n博客主人：栗子\n邮箱：li_wq22@163.com\n简介：计科研一在读，还是一只小小白，毕业后想进厂做开发💪","updated":"2021-03-29T10:27:09.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl1jeagg9000038t4c8088t52","content":"<p>博客主人：栗子<br>邮箱：<a href=\"mailto:&#108;&#x69;&#x5f;&#x77;&#x71;&#x32;&#50;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;\">&#108;&#x69;&#x5f;&#x77;&#x71;&#x32;&#50;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;</a><br>简介：计科研一在读，还是一只小小白，毕业后想进厂做开发💪</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"","more":"<p>博客主人：栗子<br>邮箱：<a href=\"mailto:&#108;&#x69;&#x5f;&#x77;&#x71;&#x32;&#50;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;\">&#108;&#x69;&#x5f;&#x77;&#x71;&#x32;&#50;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;</a><br>简介：计科研一在读，还是一只小小白，毕业后想进厂做开发💪</p>\n"},{"title":"标签","date":"2018-07-05T15:17:13.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-07-05 23:17:13\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-07-05T15:17:13.000Z","path":"tags/index.html","layout":"page","_id":"cl1jeaggd000238t4gs435cdm","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"","more":""},{"title":"分类","date":"2020-02-06T06:00:00.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2020-2-6 14:00\ntype: \"categories\"\ncomments: false\n---\n","updated":"2020-02-06T06:00:00.000Z","path":"categories/index.html","layout":"page","_id":"cl1jeaggf000438t4gq324khh","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"","more":""},{"title":"My Works","date":"2017-05-31T02:05:56.000Z","layout":"works","_content":"","source":"works/index.md","raw":"title: My Works\ndate: 2017-05-31 10:05:56\nlayout: works\n---","updated":"2017-05-31T02:05:56.000Z","path":"works/index.html","comments":1,"_id":"cl1jeaggg000738t4bnukeeps","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"","more":""}],"Post":[{"title":"2022 TODO","date":"2022-02-11T10:11:50.000Z","updated":"2022-02-11T10:11:50.000Z","_content":"","source":"_drafts/2022-TODO.md","raw":"---\ntitle: 2022 TODO\ndate: 2022-02-11 18:11:50\nupdated: 2022-02-11 18:11:50\ncategories:\ntags:\n---\n","slug":"2022-TODO","published":0,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggb000138t480jr1a2m","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"","more":""},{"title":"21岁的最后半小时与22岁的第一个半小时","date":"2020-02-21T16:27:53.000Z","_content":"\n一些思考与感悟，写给自己\n\n<!--more-->\n\n---\n\n现在是2020年2月21日的23:40。\n\n21岁就快过去了，22岁居然这么快就来了。\n\n这一个多月在家，虚度。终于让我认识到了一件事，我就是个巨婴。认识到自己思想上和行为上的不成熟。小孩子都是怎么样做事的呢？你做了这件事大人会夸你，朋友会佩服你。\n\n一直以来，我就活在别人的期望里，我就忙着在别人心中树立形象。现在我终于扒光了身上的这张皮，赤裸裸地面对着自己。我是个怎样的人？我想要成为怎样的人？我想要的是什么？我似乎从来没有想过自己真正地想要什么。我也一直在逃避，从不为自己所做的事负责。\n\n我沉醉在那些给我带来的虚荣感，也感受着虚有其表的外壳与空虚的内在所带来的痛苦。于是我会在家里暴饮暴食，终日刷着手机，感受着即刻、轻易而高度的快感刺激着我的大脑，身体机械性地重复着动作。\n\n噢2020年2月22日了，祝自己生日快乐。\n\n心智不可能在一瞬间增长，只有年龄才能。\n\n心智渴望成熟，而现状却顽固的抵抗，这一冲突让我感到难过。渴望改变，却还要和自己做斗争。即使在这一刻写着这篇文章，我都想：我还要发到博客上吗？如果被人看到了，他们会怎么想我呢？\n\n要对22岁的自己说：对自己的行为负起责任。活给自己看。不要害怕批评与冷眼，你也不用忙着在别人心里树形象。不要像个小孩去做事，大人就该有大人样。\n\n多问问自己要干什么，沉下心来做事情。多看看书，多做做事。努力成长为一个大人。\n\n生日快乐！","source":"_drafts/21岁的最后半小时与22岁的第一个半小时.md","raw":"---\ntitle: 21岁的最后半小时与22岁的第一个半小时\ndate: 2020-02-22 00:27:53\ncategories: 生活Life\n---\n\n一些思考与感悟，写给自己\n\n<!--more-->\n\n---\n\n现在是2020年2月21日的23:40。\n\n21岁就快过去了，22岁居然这么快就来了。\n\n这一个多月在家，虚度。终于让我认识到了一件事，我就是个巨婴。认识到自己思想上和行为上的不成熟。小孩子都是怎么样做事的呢？你做了这件事大人会夸你，朋友会佩服你。\n\n一直以来，我就活在别人的期望里，我就忙着在别人心中树立形象。现在我终于扒光了身上的这张皮，赤裸裸地面对着自己。我是个怎样的人？我想要成为怎样的人？我想要的是什么？我似乎从来没有想过自己真正地想要什么。我也一直在逃避，从不为自己所做的事负责。\n\n我沉醉在那些给我带来的虚荣感，也感受着虚有其表的外壳与空虚的内在所带来的痛苦。于是我会在家里暴饮暴食，终日刷着手机，感受着即刻、轻易而高度的快感刺激着我的大脑，身体机械性地重复着动作。\n\n噢2020年2月22日了，祝自己生日快乐。\n\n心智不可能在一瞬间增长，只有年龄才能。\n\n心智渴望成熟，而现状却顽固的抵抗，这一冲突让我感到难过。渴望改变，却还要和自己做斗争。即使在这一刻写着这篇文章，我都想：我还要发到博客上吗？如果被人看到了，他们会怎么想我呢？\n\n要对22岁的自己说：对自己的行为负起责任。活给自己看。不要害怕批评与冷眼，你也不用忙着在别人心里树形象。不要像个小孩去做事，大人就该有大人样。\n\n多问问自己要干什么，沉下心来做事情。多看看书，多做做事。努力成长为一个大人。\n\n生日快乐！","slug":"21岁的最后半小时与22岁的第一个半小时","published":0,"updated":"2020-02-21T16:27:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggd000338t49h8d2vhi","content":"<p>一些思考与感悟，写给自己</p>\n<span id=\"more\"></span>\n\n<hr>\n<p>现在是2020年2月21日的23:40。</p>\n<p>21岁就快过去了，22岁居然这么快就来了。</p>\n<p>这一个多月在家，虚度。终于让我认识到了一件事，我就是个巨婴。认识到自己思想上和行为上的不成熟。小孩子都是怎么样做事的呢？你做了这件事大人会夸你，朋友会佩服你。</p>\n<p>一直以来，我就活在别人的期望里，我就忙着在别人心中树立形象。现在我终于扒光了身上的这张皮，赤裸裸地面对着自己。我是个怎样的人？我想要成为怎样的人？我想要的是什么？我似乎从来没有想过自己真正地想要什么。我也一直在逃避，从不为自己所做的事负责。</p>\n<p>我沉醉在那些给我带来的虚荣感，也感受着虚有其表的外壳与空虚的内在所带来的痛苦。于是我会在家里暴饮暴食，终日刷着手机，感受着即刻、轻易而高度的快感刺激着我的大脑，身体机械性地重复着动作。</p>\n<p>噢2020年2月22日了，祝自己生日快乐。</p>\n<p>心智不可能在一瞬间增长，只有年龄才能。</p>\n<p>心智渴望成熟，而现状却顽固的抵抗，这一冲突让我感到难过。渴望改变，却还要和自己做斗争。即使在这一刻写着这篇文章，我都想：我还要发到博客上吗？如果被人看到了，他们会怎么想我呢？</p>\n<p>要对22岁的自己说：对自己的行为负起责任。活给自己看。不要害怕批评与冷眼，你也不用忙着在别人心里树形象。不要像个小孩去做事，大人就该有大人样。</p>\n<p>多问问自己要干什么，沉下心来做事情。多看看书，多做做事。努力成长为一个大人。</p>\n<p>生日快乐！</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>一些思考与感悟，写给自己</p>","more":"<hr>\n<p>现在是2020年2月21日的23:40。</p>\n<p>21岁就快过去了，22岁居然这么快就来了。</p>\n<p>这一个多月在家，虚度。终于让我认识到了一件事，我就是个巨婴。认识到自己思想上和行为上的不成熟。小孩子都是怎么样做事的呢？你做了这件事大人会夸你，朋友会佩服你。</p>\n<p>一直以来，我就活在别人的期望里，我就忙着在别人心中树立形象。现在我终于扒光了身上的这张皮，赤裸裸地面对着自己。我是个怎样的人？我想要成为怎样的人？我想要的是什么？我似乎从来没有想过自己真正地想要什么。我也一直在逃避，从不为自己所做的事负责。</p>\n<p>我沉醉在那些给我带来的虚荣感，也感受着虚有其表的外壳与空虚的内在所带来的痛苦。于是我会在家里暴饮暴食，终日刷着手机，感受着即刻、轻易而高度的快感刺激着我的大脑，身体机械性地重复着动作。</p>\n<p>噢2020年2月22日了，祝自己生日快乐。</p>\n<p>心智不可能在一瞬间增长，只有年龄才能。</p>\n<p>心智渴望成熟，而现状却顽固的抵抗，这一冲突让我感到难过。渴望改变，却还要和自己做斗争。即使在这一刻写着这篇文章，我都想：我还要发到博客上吗？如果被人看到了，他们会怎么想我呢？</p>\n<p>要对22岁的自己说：对自己的行为负起责任。活给自己看。不要害怕批评与冷眼，你也不用忙着在别人心里树形象。不要像个小孩去做事，大人就该有大人样。</p>\n<p>多问问自己要干什么，沉下心来做事情。多看看书，多做做事。努力成长为一个大人。</p>\n<p>生日快乐！</p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_drafts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":0,"date":"2021-12-01T03:07:21.036Z","updated":"2021-12-01T03:07:21.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggf000538t49ab97vu8","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"_content":"月计划\n\n4月计划\n\n| 实习进度 |      |\n| -------- | ---- |\n|          |      |\n\n","source":"_drafts/月计划.md","raw":"月计划\n\n4月计划\n\n| 实习进度 |      |\n| -------- | ---- |\n|          |      |\n\n","slug":"月计划","published":0,"date":"2022-03-28T03:07:08.713Z","updated":"2022-03-28T03:07:08.713Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggi000838t4a5n1g94v","content":"<p>月计划</p>\n<p>4月计划</p>\n<table>\n<thead>\n<tr>\n<th>实习进度</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"","more":"<p>月计划</p>\n<p>4月计划</p>\n<table>\n<thead>\n<tr>\n<th>实习进度</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n"},{"title":"编译原理实验-LR(1)分析","_content":"","source":"_drafts/编译原理实验-LR(1)分析.md","raw":"---\ntitle: 编译原理实验-LR(1)分析\ntags:\n---\n","slug":"编译原理实验-LR(1)分析","published":0,"date":"2021-12-01T03:07:21.037Z","updated":"2021-12-01T03:07:21.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggj000938t42zny3bq7","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"","more":""},{"title":" new draft","_content":"","source":"_drafts/new-draft.md","raw":"---\ntitle: ' new draft'\ntags:\n---\n","slug":"new-draft","published":0,"date":"2021-12-01T03:07:21.037Z","updated":"2021-12-01T03:07:21.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggj000a38t42fichjuj","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"","more":""},{"title":"3月读书观影分享","date":"2019-04-05T03:21:48.000Z","_content":"\n孤独六讲、绿皮书、请回答1988、数学之美\n\n<!--more-->\n\n---\n\n这个月开学了就看得少啦，其实每天都没什么课，但是过得好充实。备考、做课设、看书、运动。每一天都很开心。切入正题，前三个都很好看，推荐一下，《数学之美》就看个人啦。\n\n## 孤独六讲\n> “难道人的出生就是为了死亡吗？还是为了活着的每一分每一秒。”\n\n蒋勋先生的书，薄薄的一本书我看了两个月。这本书讲的内容我受益还挺大的。一个人要从社会中走出去，变成孤独的人，才能回过头来进行思维。\n\n1. 不畏惧成为孤独的人。\n2. 尊重别的孤独的人。沟通是一切的开始\n3. 每一个人都要作为一个个体，爱的关系应是倚靠而不是倚赖。\n4. 事情不是非黑即白的，黑白中间都有一个过渡区，这就是我们进行思辨的地方。思辨与探讨的过程比得出结论更为重要。你要学会听别人说，去听那0.01%的人的想法。\n\n先写这四点，还有几点我当时认识很深，过了段时间有些遗忘了。反正还是很值得一看的书。特别是思维孤独那一章印象很深。\n\n\n## 绿皮书\n> “改变大众的想法，这需要很大的勇气。”\n\n真的不错。一个人会有多种阶级，多种身份。\n\n白人Tony，黑人Don。\n我印象最深的一段，是两人在车上发生争执，Tony说Don只是活在自己的城堡里。Don下车，在雨里大喊：“如果我不够黑，如果我不够白，如果我不够男人，那你告诉我我是什么。我到底是谁。”\n另外印象很深的一段，是他们在车上和田野中的黑人对望的那一幕，感觉冲突到了极致。\n就是两种身份的人，Don拥有高贵的钢琴师身份，但是别人口中的“老黑”，Tony是白人，但是是在生活中摸爬滚打的夜总会员工。这样的冲突很有意思了，它触及了我从未深入思考过的问题，我没法准确表达出自己的想法。\n\n人与人之间，不分肤色，不分种族，不分背景。大家都应拥有平等的权力，不应有谁瞧不起谁。样貌、种族、背景、性格这些与生俱来的东西，都不应该作为看不起人、嘲笑别人的原因。\n你不该活在自己的城堡里，自我感动到觉得无人可以理解我。\n也不该孤独地等待别人来联系我，有人之所以会孤独，就是因为他不愿意迈出第一步。世人虽然没有那么好，但也不是都那么坏。\n\n\n## 请回答1988\n以一个月三集的速度...我看了一半了，开启爱情支线~太美好了吧这份情感╰(\\*°▽°\\*)╯\n做梦都能梦到剧情的发展，我已经两次做梦梦到请回答1988了。\n希望正勋和德善在一起！！做梦梦到了好甜好甜的，甜到感觉自己谈了个恋爱。\n\n## 数学之美\n> “数学的精彩之处就在于简单的模型可以干大事。”\n\n吴军先生真的是我很佩服的一个人了。能写数学，能写互联网，能写历史，待在Google去过腾讯。字里行间也可以看出，他自己也觉得自己是一个很厉害的人，没有隐藏这种感情(ˉ▽ˉ)\n我觉得这本书不适合没有一定专业知识的人看，除非不讨厌数学或者对这方面比较感兴趣吧...就我而言，我上个学期学了自然语言理解，之前学过机器学习，有了一定的基础，加上不讨厌数学再看起这本书来就很有意思了。\n另外，我觉得应试教育把数学变得是一样很可怕的事情，至少我以前就是这么感觉的。到了大三我才慢慢发现，数学并不是那么的面目可憎，反而是有点意思。\n\n## 后记\n没想到三月依然能写出一篇文章来~看的东西的确少了。每天都很充实，也有了新的思考。微博是我日常碎碎念的地方，你能看到这里也不容易，把我微博给你当礼物吧@栗子lllii\n写完这篇，我好想看电影噢！！！","source":"_posts/3月读书观影分享.md","raw":"---\ntitle: 3月读书观影分享\ndate: 2019-04-05 11:21:48\ncategories: 生活Life\nphoto: http://forlwq.oss-cn-hangzhou.aliyuncs.com/12.jpg\n---\n\n孤独六讲、绿皮书、请回答1988、数学之美\n\n<!--more-->\n\n---\n\n这个月开学了就看得少啦，其实每天都没什么课，但是过得好充实。备考、做课设、看书、运动。每一天都很开心。切入正题，前三个都很好看，推荐一下，《数学之美》就看个人啦。\n\n## 孤独六讲\n> “难道人的出生就是为了死亡吗？还是为了活着的每一分每一秒。”\n\n蒋勋先生的书，薄薄的一本书我看了两个月。这本书讲的内容我受益还挺大的。一个人要从社会中走出去，变成孤独的人，才能回过头来进行思维。\n\n1. 不畏惧成为孤独的人。\n2. 尊重别的孤独的人。沟通是一切的开始\n3. 每一个人都要作为一个个体，爱的关系应是倚靠而不是倚赖。\n4. 事情不是非黑即白的，黑白中间都有一个过渡区，这就是我们进行思辨的地方。思辨与探讨的过程比得出结论更为重要。你要学会听别人说，去听那0.01%的人的想法。\n\n先写这四点，还有几点我当时认识很深，过了段时间有些遗忘了。反正还是很值得一看的书。特别是思维孤独那一章印象很深。\n\n\n## 绿皮书\n> “改变大众的想法，这需要很大的勇气。”\n\n真的不错。一个人会有多种阶级，多种身份。\n\n白人Tony，黑人Don。\n我印象最深的一段，是两人在车上发生争执，Tony说Don只是活在自己的城堡里。Don下车，在雨里大喊：“如果我不够黑，如果我不够白，如果我不够男人，那你告诉我我是什么。我到底是谁。”\n另外印象很深的一段，是他们在车上和田野中的黑人对望的那一幕，感觉冲突到了极致。\n就是两种身份的人，Don拥有高贵的钢琴师身份，但是别人口中的“老黑”，Tony是白人，但是是在生活中摸爬滚打的夜总会员工。这样的冲突很有意思了，它触及了我从未深入思考过的问题，我没法准确表达出自己的想法。\n\n人与人之间，不分肤色，不分种族，不分背景。大家都应拥有平等的权力，不应有谁瞧不起谁。样貌、种族、背景、性格这些与生俱来的东西，都不应该作为看不起人、嘲笑别人的原因。\n你不该活在自己的城堡里，自我感动到觉得无人可以理解我。\n也不该孤独地等待别人来联系我，有人之所以会孤独，就是因为他不愿意迈出第一步。世人虽然没有那么好，但也不是都那么坏。\n\n\n## 请回答1988\n以一个月三集的速度...我看了一半了，开启爱情支线~太美好了吧这份情感╰(\\*°▽°\\*)╯\n做梦都能梦到剧情的发展，我已经两次做梦梦到请回答1988了。\n希望正勋和德善在一起！！做梦梦到了好甜好甜的，甜到感觉自己谈了个恋爱。\n\n## 数学之美\n> “数学的精彩之处就在于简单的模型可以干大事。”\n\n吴军先生真的是我很佩服的一个人了。能写数学，能写互联网，能写历史，待在Google去过腾讯。字里行间也可以看出，他自己也觉得自己是一个很厉害的人，没有隐藏这种感情(ˉ▽ˉ)\n我觉得这本书不适合没有一定专业知识的人看，除非不讨厌数学或者对这方面比较感兴趣吧...就我而言，我上个学期学了自然语言理解，之前学过机器学习，有了一定的基础，加上不讨厌数学再看起这本书来就很有意思了。\n另外，我觉得应试教育把数学变得是一样很可怕的事情，至少我以前就是这么感觉的。到了大三我才慢慢发现，数学并不是那么的面目可憎，反而是有点意思。\n\n## 后记\n没想到三月依然能写出一篇文章来~看的东西的确少了。每天都很充实，也有了新的思考。微博是我日常碎碎念的地方，你能看到这里也不容易，把我微博给你当礼物吧@栗子lllii\n写完这篇，我好想看电影噢！！！","slug":"3月读书观影分享","published":1,"updated":"2019-04-05T03:21:48.000Z","photos":["http://forlwq.oss-cn-hangzhou.aliyuncs.com/12.jpg"],"comments":1,"layout":"post","link":"","_id":"cl1jeaggl000b38t43bbidcjd","content":"<p>孤独六讲、绿皮书、请回答1988、数学之美</p>\n<span id=\"more\"></span>\n\n<hr>\n<p>这个月开学了就看得少啦，其实每天都没什么课，但是过得好充实。备考、做课设、看书、运动。每一天都很开心。切入正题，前三个都很好看，推荐一下，《数学之美》就看个人啦。</p>\n<h2 id=\"孤独六讲\"><a href=\"#孤独六讲\" class=\"headerlink\" title=\"孤独六讲\"></a>孤独六讲</h2><blockquote>\n<p>“难道人的出生就是为了死亡吗？还是为了活着的每一分每一秒。”</p>\n</blockquote>\n<p>蒋勋先生的书，薄薄的一本书我看了两个月。这本书讲的内容我受益还挺大的。一个人要从社会中走出去，变成孤独的人，才能回过头来进行思维。</p>\n<ol>\n<li>不畏惧成为孤独的人。</li>\n<li>尊重别的孤独的人。沟通是一切的开始</li>\n<li>每一个人都要作为一个个体，爱的关系应是倚靠而不是倚赖。</li>\n<li>事情不是非黑即白的，黑白中间都有一个过渡区，这就是我们进行思辨的地方。思辨与探讨的过程比得出结论更为重要。你要学会听别人说，去听那0.01%的人的想法。</li>\n</ol>\n<p>先写这四点，还有几点我当时认识很深，过了段时间有些遗忘了。反正还是很值得一看的书。特别是思维孤独那一章印象很深。</p>\n<h2 id=\"绿皮书\"><a href=\"#绿皮书\" class=\"headerlink\" title=\"绿皮书\"></a>绿皮书</h2><blockquote>\n<p>“改变大众的想法，这需要很大的勇气。”</p>\n</blockquote>\n<p>真的不错。一个人会有多种阶级，多种身份。</p>\n<p>白人Tony，黑人Don。<br>我印象最深的一段，是两人在车上发生争执，Tony说Don只是活在自己的城堡里。Don下车，在雨里大喊：“如果我不够黑，如果我不够白，如果我不够男人，那你告诉我我是什么。我到底是谁。”<br>另外印象很深的一段，是他们在车上和田野中的黑人对望的那一幕，感觉冲突到了极致。<br>就是两种身份的人，Don拥有高贵的钢琴师身份，但是别人口中的“老黑”，Tony是白人，但是是在生活中摸爬滚打的夜总会员工。这样的冲突很有意思了，它触及了我从未深入思考过的问题，我没法准确表达出自己的想法。</p>\n<p>人与人之间，不分肤色，不分种族，不分背景。大家都应拥有平等的权力，不应有谁瞧不起谁。样貌、种族、背景、性格这些与生俱来的东西，都不应该作为看不起人、嘲笑别人的原因。<br>你不该活在自己的城堡里，自我感动到觉得无人可以理解我。<br>也不该孤独地等待别人来联系我，有人之所以会孤独，就是因为他不愿意迈出第一步。世人虽然没有那么好，但也不是都那么坏。</p>\n<h2 id=\"请回答1988\"><a href=\"#请回答1988\" class=\"headerlink\" title=\"请回答1988\"></a>请回答1988</h2><p>以一个月三集的速度…我看了一半了，开启爱情支线~太美好了吧这份情感╰(*°▽°*)╯<br>做梦都能梦到剧情的发展，我已经两次做梦梦到请回答1988了。<br>希望正勋和德善在一起！！做梦梦到了好甜好甜的，甜到感觉自己谈了个恋爱。</p>\n<h2 id=\"数学之美\"><a href=\"#数学之美\" class=\"headerlink\" title=\"数学之美\"></a>数学之美</h2><blockquote>\n<p>“数学的精彩之处就在于简单的模型可以干大事。”</p>\n</blockquote>\n<p>吴军先生真的是我很佩服的一个人了。能写数学，能写互联网，能写历史，待在Google去过腾讯。字里行间也可以看出，他自己也觉得自己是一个很厉害的人，没有隐藏这种感情(ˉ▽ˉ)<br>我觉得这本书不适合没有一定专业知识的人看，除非不讨厌数学或者对这方面比较感兴趣吧…就我而言，我上个学期学了自然语言理解，之前学过机器学习，有了一定的基础，加上不讨厌数学再看起这本书来就很有意思了。<br>另外，我觉得应试教育把数学变得是一样很可怕的事情，至少我以前就是这么感觉的。到了大三我才慢慢发现，数学并不是那么的面目可憎，反而是有点意思。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>没想到三月依然能写出一篇文章来~看的东西的确少了。每天都很充实，也有了新的思考。微博是我日常碎碎念的地方，你能看到这里也不容易，把我微博给你当礼物吧@栗子lllii<br>写完这篇，我好想看电影噢！！！</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>孤独六讲、绿皮书、请回答1988、数学之美</p>","more":"<hr>\n<p>这个月开学了就看得少啦，其实每天都没什么课，但是过得好充实。备考、做课设、看书、运动。每一天都很开心。切入正题，前三个都很好看，推荐一下，《数学之美》就看个人啦。</p>\n<h2 id=\"孤独六讲\"><a href=\"#孤独六讲\" class=\"headerlink\" title=\"孤独六讲\"></a>孤独六讲</h2><blockquote>\n<p>“难道人的出生就是为了死亡吗？还是为了活着的每一分每一秒。”</p>\n</blockquote>\n<p>蒋勋先生的书，薄薄的一本书我看了两个月。这本书讲的内容我受益还挺大的。一个人要从社会中走出去，变成孤独的人，才能回过头来进行思维。</p>\n<ol>\n<li>不畏惧成为孤独的人。</li>\n<li>尊重别的孤独的人。沟通是一切的开始</li>\n<li>每一个人都要作为一个个体，爱的关系应是倚靠而不是倚赖。</li>\n<li>事情不是非黑即白的，黑白中间都有一个过渡区，这就是我们进行思辨的地方。思辨与探讨的过程比得出结论更为重要。你要学会听别人说，去听那0.01%的人的想法。</li>\n</ol>\n<p>先写这四点，还有几点我当时认识很深，过了段时间有些遗忘了。反正还是很值得一看的书。特别是思维孤独那一章印象很深。</p>\n<h2 id=\"绿皮书\"><a href=\"#绿皮书\" class=\"headerlink\" title=\"绿皮书\"></a>绿皮书</h2><blockquote>\n<p>“改变大众的想法，这需要很大的勇气。”</p>\n</blockquote>\n<p>真的不错。一个人会有多种阶级，多种身份。</p>\n<p>白人Tony，黑人Don。<br>我印象最深的一段，是两人在车上发生争执，Tony说Don只是活在自己的城堡里。Don下车，在雨里大喊：“如果我不够黑，如果我不够白，如果我不够男人，那你告诉我我是什么。我到底是谁。”<br>另外印象很深的一段，是他们在车上和田野中的黑人对望的那一幕，感觉冲突到了极致。<br>就是两种身份的人，Don拥有高贵的钢琴师身份，但是别人口中的“老黑”，Tony是白人，但是是在生活中摸爬滚打的夜总会员工。这样的冲突很有意思了，它触及了我从未深入思考过的问题，我没法准确表达出自己的想法。</p>\n<p>人与人之间，不分肤色，不分种族，不分背景。大家都应拥有平等的权力，不应有谁瞧不起谁。样貌、种族、背景、性格这些与生俱来的东西，都不应该作为看不起人、嘲笑别人的原因。<br>你不该活在自己的城堡里，自我感动到觉得无人可以理解我。<br>也不该孤独地等待别人来联系我，有人之所以会孤独，就是因为他不愿意迈出第一步。世人虽然没有那么好，但也不是都那么坏。</p>\n<h2 id=\"请回答1988\"><a href=\"#请回答1988\" class=\"headerlink\" title=\"请回答1988\"></a>请回答1988</h2><p>以一个月三集的速度…我看了一半了，开启爱情支线~太美好了吧这份情感╰(*°▽°*)╯<br>做梦都能梦到剧情的发展，我已经两次做梦梦到请回答1988了。<br>希望正勋和德善在一起！！做梦梦到了好甜好甜的，甜到感觉自己谈了个恋爱。</p>\n<h2 id=\"数学之美\"><a href=\"#数学之美\" class=\"headerlink\" title=\"数学之美\"></a>数学之美</h2><blockquote>\n<p>“数学的精彩之处就在于简单的模型可以干大事。”</p>\n</blockquote>\n<p>吴军先生真的是我很佩服的一个人了。能写数学，能写互联网，能写历史，待在Google去过腾讯。字里行间也可以看出，他自己也觉得自己是一个很厉害的人，没有隐藏这种感情(ˉ▽ˉ)<br>我觉得这本书不适合没有一定专业知识的人看，除非不讨厌数学或者对这方面比较感兴趣吧…就我而言，我上个学期学了自然语言理解，之前学过机器学习，有了一定的基础，加上不讨厌数学再看起这本书来就很有意思了。<br>另外，我觉得应试教育把数学变得是一样很可怕的事情，至少我以前就是这么感觉的。到了大三我才慢慢发现，数学并不是那么的面目可憎，反而是有点意思。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>没想到三月依然能写出一篇文章来~看的东西的确少了。每天都很充实，也有了新的思考。微博是我日常碎碎念的地方，你能看到这里也不容易，把我微博给你当礼物吧@栗子lllii<br>写完这篇，我好想看电影噢！！！</p>"},{"title":"Coding0618","date":"2019-06-18T08:19:48.000Z","_content":"\n\nCodeWars 第1天\n\n<!--more-->\n\n---\n\n\n## 第一题：Jaden Casing Strings\n\n> 句子的每个单词首字母转为大写\n\n```\n# My Solution\ndef toJadenCase(string):\n    item = string.strip().split(' ')\n    for i in range(len(item)):\n        fir = item[i][0]\n        if 'a' <= fir <= 'z':\n            item[i]=chr(ord(fir)-32)+item[i][1:]\n    return ' '.join(item)\n```\n\n```\n# Rank One Solution\ndef def toJadenCase(string):\n    return \" \".join(w.capitalize() for w in string.split())\n```\n\n(str是字符串类型)\n1. ord(char)：将字符串转为ASCII码；\nchr(integer)：将整型转为字符\n1. str.capitalize()\n    将字符串首字母转为大写字母\n2. str = sring.capwords(str)\n    将字符串中各个单词的首字母转为大写字母\n3. 列表/字典构建器\n（本来以为是for的省略形式/高级用法）\n（早就接触到了但是不知道该怎么用）\n```\n# 列表的基本用法\n>>>[a*a for a in range(5)]\n[0, 1, 4, 9, 16]\n\n# 但是这个有点消耗内存，下面可以用多少取多少\n>>>it = (a*a for a in range(5))\n>>>next(it)\n0\n>>>next(it)\n1\n>>>next(it)\n4\n\n# 双重循环嵌套\n>>>[a+b for a in 'abc' for b in 'xyz' ]\n['ax', 'ay', 'az', 'bx', 'by', 'bz', 'cx', 'cy', 'cz']\n\n# 字典(下面将原来的dict的key和value位置互换)\n>>>dict = {'a':1,'b':2,'c':3}\n>>>{a:b for b,a in dict.items()}\n{1: 'a', 2: 'b', 3: 'c'}\n\n#还可以直接把这个用在函数调用中\n>>>a = 'I am here for you.'\n>>>\" \".join(w.capitalize() for w in a.split())\n'I Am Here For You.'\n```\n\n## 第二题：Ones and Zeros\n\n> 二进制列表[1,0,0,1]转十进制9\n\n```\n# My Solution\ndef binary_array_to_number(arr):\n  l = len(arr)\n  result = 0\n  for i in range(l):\n      result += pow(2, l-i-1)*arr[i]\n  return result\n```\n\nint函数\nint(data, base)\nbase表示进制，于是可以这样写：\n```\ndef binary_array_to_number(arr):\n    return int(''.join((map(str, arr))), 2)\n```\n\n还看到了一种方法，太强了！简单分析了一下，有点递归思想。看不懂的可以把s = s * 2 + digit拆开：\ns4 = s3 \\* 2 + d4 = (s2\\*2+d3) \\* 2 + d4 ···\n```\ndef binary_array_to_number(arr):\n    s = 0\n    for digit in arr:\n        s = s * 2 + digit\n    return \n```\n\n\n另外学到了一招，算时间的，可以看到我的方法慢很多...\n```\n>>> s1 = \"\"\"\n... def binary_array_to_number(arr):\n...     return int(''.join((map(str, arr))), 2)\"\"\"\n>>> timeit.timeit(\"binary_array_to_number([1,0,0,1,1,0,1,0,1,1,0,0])\", setup=s1, number=100000)\n0.3919008289994963\n\n>>> s2 = \"\"\"\n... def binary_array_to_number(arr):\n...     l = len(arr)\n...     result=0\n...     for i in range(l):\n...             result += pow(2, l-i-1)*arr[i]\n...     return result\"\"\"\n>>> timeit.timeit(\"binary_array_to_number([1,0,0,1,1,0,1,0,1,1,0,0])\", setup=s2, number=100000)\n1.0104243380001208\n```\n\n\n## Others\n\n### reversed函数\n\n传入元组、列表、字符串等，返回一个反转的迭代器。\n打个栗子：\n\n```\n>>>str = 'Beautiful'\n>>>list(reversed(str))\n['l', 'u', 'f', 'i', 't', 'u', 'a', 'e', 'B']\n```\n\n### enumerate函数\n\n返回索引和数据\n打个栗子：\n```\n>>>l = ['美丽', '可爱', '大方', '善良']\n>>>list(enumerate(l))\n[(0, '美丽'), (1, '可爱'), (2, '大方'), (3, '善良')]\n>>>for index,data in enumerate(l):\n...     print(index,data)\n0 美丽\n1 可爱\n2 大方\n3 善良\n```\n\n\n## Daily Thoughts\n\n你觉得简单的题，有人就只用一行代码解决。太强了！！绝了，我觉得我就是一纯Python小白！学到很多。\n另，效率有点低，明天多刷几题~","source":"_posts/Coding0618.md","raw":"---\ntitle: Coding0618\ndate: 2019-06-18 16:19:48\ncategories: DailyCode\n---\n\n\nCodeWars 第1天\n\n<!--more-->\n\n---\n\n\n## 第一题：Jaden Casing Strings\n\n> 句子的每个单词首字母转为大写\n\n```\n# My Solution\ndef toJadenCase(string):\n    item = string.strip().split(' ')\n    for i in range(len(item)):\n        fir = item[i][0]\n        if 'a' <= fir <= 'z':\n            item[i]=chr(ord(fir)-32)+item[i][1:]\n    return ' '.join(item)\n```\n\n```\n# Rank One Solution\ndef def toJadenCase(string):\n    return \" \".join(w.capitalize() for w in string.split())\n```\n\n(str是字符串类型)\n1. ord(char)：将字符串转为ASCII码；\nchr(integer)：将整型转为字符\n1. str.capitalize()\n    将字符串首字母转为大写字母\n2. str = sring.capwords(str)\n    将字符串中各个单词的首字母转为大写字母\n3. 列表/字典构建器\n（本来以为是for的省略形式/高级用法）\n（早就接触到了但是不知道该怎么用）\n```\n# 列表的基本用法\n>>>[a*a for a in range(5)]\n[0, 1, 4, 9, 16]\n\n# 但是这个有点消耗内存，下面可以用多少取多少\n>>>it = (a*a for a in range(5))\n>>>next(it)\n0\n>>>next(it)\n1\n>>>next(it)\n4\n\n# 双重循环嵌套\n>>>[a+b for a in 'abc' for b in 'xyz' ]\n['ax', 'ay', 'az', 'bx', 'by', 'bz', 'cx', 'cy', 'cz']\n\n# 字典(下面将原来的dict的key和value位置互换)\n>>>dict = {'a':1,'b':2,'c':3}\n>>>{a:b for b,a in dict.items()}\n{1: 'a', 2: 'b', 3: 'c'}\n\n#还可以直接把这个用在函数调用中\n>>>a = 'I am here for you.'\n>>>\" \".join(w.capitalize() for w in a.split())\n'I Am Here For You.'\n```\n\n## 第二题：Ones and Zeros\n\n> 二进制列表[1,0,0,1]转十进制9\n\n```\n# My Solution\ndef binary_array_to_number(arr):\n  l = len(arr)\n  result = 0\n  for i in range(l):\n      result += pow(2, l-i-1)*arr[i]\n  return result\n```\n\nint函数\nint(data, base)\nbase表示进制，于是可以这样写：\n```\ndef binary_array_to_number(arr):\n    return int(''.join((map(str, arr))), 2)\n```\n\n还看到了一种方法，太强了！简单分析了一下，有点递归思想。看不懂的可以把s = s * 2 + digit拆开：\ns4 = s3 \\* 2 + d4 = (s2\\*2+d3) \\* 2 + d4 ···\n```\ndef binary_array_to_number(arr):\n    s = 0\n    for digit in arr:\n        s = s * 2 + digit\n    return \n```\n\n\n另外学到了一招，算时间的，可以看到我的方法慢很多...\n```\n>>> s1 = \"\"\"\n... def binary_array_to_number(arr):\n...     return int(''.join((map(str, arr))), 2)\"\"\"\n>>> timeit.timeit(\"binary_array_to_number([1,0,0,1,1,0,1,0,1,1,0,0])\", setup=s1, number=100000)\n0.3919008289994963\n\n>>> s2 = \"\"\"\n... def binary_array_to_number(arr):\n...     l = len(arr)\n...     result=0\n...     for i in range(l):\n...             result += pow(2, l-i-1)*arr[i]\n...     return result\"\"\"\n>>> timeit.timeit(\"binary_array_to_number([1,0,0,1,1,0,1,0,1,1,0,0])\", setup=s2, number=100000)\n1.0104243380001208\n```\n\n\n## Others\n\n### reversed函数\n\n传入元组、列表、字符串等，返回一个反转的迭代器。\n打个栗子：\n\n```\n>>>str = 'Beautiful'\n>>>list(reversed(str))\n['l', 'u', 'f', 'i', 't', 'u', 'a', 'e', 'B']\n```\n\n### enumerate函数\n\n返回索引和数据\n打个栗子：\n```\n>>>l = ['美丽', '可爱', '大方', '善良']\n>>>list(enumerate(l))\n[(0, '美丽'), (1, '可爱'), (2, '大方'), (3, '善良')]\n>>>for index,data in enumerate(l):\n...     print(index,data)\n0 美丽\n1 可爱\n2 大方\n3 善良\n```\n\n\n## Daily Thoughts\n\n你觉得简单的题，有人就只用一行代码解决。太强了！！绝了，我觉得我就是一纯Python小白！学到很多。\n另，效率有点低，明天多刷几题~","slug":"Coding0618","published":1,"updated":"2019-06-18T08:19:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggl000c38t4806q7usz","content":"<p>CodeWars 第1天</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"第一题：Jaden-Casing-Strings\"><a href=\"#第一题：Jaden-Casing-Strings\" class=\"headerlink\" title=\"第一题：Jaden Casing Strings\"></a>第一题：Jaden Casing Strings</h2><blockquote>\n<p>句子的每个单词首字母转为大写</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># My Solution</span><br><span class=\"line\">def toJadenCase(string):</span><br><span class=\"line\">    item = string.strip().split(&#x27; &#x27;)</span><br><span class=\"line\">    for i in range(len(item)):</span><br><span class=\"line\">        fir = item[i][0]</span><br><span class=\"line\">        if &#x27;a&#x27; &lt;= fir &lt;= &#x27;z&#x27;:</span><br><span class=\"line\">            item[i]=chr(ord(fir)-32)+item[i][1:]</span><br><span class=\"line\">    return &#x27; &#x27;.join(item)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Rank One Solution</span><br><span class=\"line\">def def toJadenCase(string):</span><br><span class=\"line\">    return &quot; &quot;.join(w.capitalize() for w in string.split())</span><br></pre></td></tr></table></figure>\n\n<p>(str是字符串类型)</p>\n<ol>\n<li>ord(char)：将字符串转为ASCII码；<br>chr(integer)：将整型转为字符</li>\n<li>str.capitalize()<br> 将字符串首字母转为大写字母</li>\n<li>str = sring.capwords(str)<br> 将字符串中各个单词的首字母转为大写字母</li>\n<li>列表/字典构建器<br>（本来以为是for的省略形式/高级用法）<br>（早就接触到了但是不知道该怎么用）<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列表的基本用法</span><br><span class=\"line\">&gt;&gt;&gt;[a*a for a in range(5)]</span><br><span class=\"line\">[0, 1, 4, 9, 16]</span><br><span class=\"line\"></span><br><span class=\"line\"># 但是这个有点消耗内存，下面可以用多少取多少</span><br><span class=\"line\">&gt;&gt;&gt;it = (a*a for a in range(5))</span><br><span class=\"line\">&gt;&gt;&gt;next(it)</span><br><span class=\"line\">0</span><br><span class=\"line\">&gt;&gt;&gt;next(it)</span><br><span class=\"line\">1</span><br><span class=\"line\">&gt;&gt;&gt;next(it)</span><br><span class=\"line\">4</span><br><span class=\"line\"></span><br><span class=\"line\"># 双重循环嵌套</span><br><span class=\"line\">&gt;&gt;&gt;[a+b for a in &#x27;abc&#x27; for b in &#x27;xyz&#x27; ]</span><br><span class=\"line\">[&#x27;ax&#x27;, &#x27;ay&#x27;, &#x27;az&#x27;, &#x27;bx&#x27;, &#x27;by&#x27;, &#x27;bz&#x27;, &#x27;cx&#x27;, &#x27;cy&#x27;, &#x27;cz&#x27;]</span><br><span class=\"line\"></span><br><span class=\"line\"># 字典(下面将原来的dict的key和value位置互换)</span><br><span class=\"line\">&gt;&gt;&gt;dict = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:3&#125;</span><br><span class=\"line\">&gt;&gt;&gt;&#123;a:b for b,a in dict.items()&#125;</span><br><span class=\"line\">&#123;1: &#x27;a&#x27;, 2: &#x27;b&#x27;, 3: &#x27;c&#x27;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#还可以直接把这个用在函数调用中</span><br><span class=\"line\">&gt;&gt;&gt;a = &#x27;I am here for you.&#x27;</span><br><span class=\"line\">&gt;&gt;&gt;&quot; &quot;.join(w.capitalize() for w in a.split())</span><br><span class=\"line\">&#x27;I Am Here For You.&#x27;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"第二题：Ones-and-Zeros\"><a href=\"#第二题：Ones-and-Zeros\" class=\"headerlink\" title=\"第二题：Ones and Zeros\"></a>第二题：Ones and Zeros</h2><blockquote>\n<p>二进制列表[1,0,0,1]转十进制9</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># My Solution</span><br><span class=\"line\">def binary_array_to_number(arr):</span><br><span class=\"line\">  l = len(arr)</span><br><span class=\"line\">  result = 0</span><br><span class=\"line\">  for i in range(l):</span><br><span class=\"line\">      result += pow(2, l-i-1)*arr[i]</span><br><span class=\"line\">  return result</span><br></pre></td></tr></table></figure>\n\n<p>int函数<br>int(data, base)<br>base表示进制，于是可以这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def binary_array_to_number(arr):</span><br><span class=\"line\">    return int(&#x27;&#x27;.join((map(str, arr))), 2)</span><br></pre></td></tr></table></figure>\n\n<p>还看到了一种方法，太强了！简单分析了一下，有点递归思想。看不懂的可以把s = s * 2 + digit拆开：<br>s4 = s3 * 2 + d4 = (s2*2+d3) * 2 + d4 ···</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def binary_array_to_number(arr):</span><br><span class=\"line\">    s = 0</span><br><span class=\"line\">    for digit in arr:</span><br><span class=\"line\">        s = s * 2 + digit</span><br><span class=\"line\">    return </span><br></pre></td></tr></table></figure>\n\n\n<p>另外学到了一招，算时间的，可以看到我的方法慢很多…</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; s1 = &quot;&quot;&quot;</span><br><span class=\"line\">... def binary_array_to_number(arr):</span><br><span class=\"line\">...     return int(&#x27;&#x27;.join((map(str, arr))), 2)&quot;&quot;&quot;</span><br><span class=\"line\">&gt;&gt;&gt; timeit.timeit(&quot;binary_array_to_number([1,0,0,1,1,0,1,0,1,1,0,0])&quot;, setup=s1, number=100000)</span><br><span class=\"line\">0.3919008289994963</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; s2 = &quot;&quot;&quot;</span><br><span class=\"line\">... def binary_array_to_number(arr):</span><br><span class=\"line\">...     l = len(arr)</span><br><span class=\"line\">...     result=0</span><br><span class=\"line\">...     for i in range(l):</span><br><span class=\"line\">...             result += pow(2, l-i-1)*arr[i]</span><br><span class=\"line\">...     return result&quot;&quot;&quot;</span><br><span class=\"line\">&gt;&gt;&gt; timeit.timeit(&quot;binary_array_to_number([1,0,0,1,1,0,1,0,1,1,0,0])&quot;, setup=s2, number=100000)</span><br><span class=\"line\">1.0104243380001208</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Others\"><a href=\"#Others\" class=\"headerlink\" title=\"Others\"></a>Others</h2><h3 id=\"reversed函数\"><a href=\"#reversed函数\" class=\"headerlink\" title=\"reversed函数\"></a>reversed函数</h3><p>传入元组、列表、字符串等，返回一个反转的迭代器。<br>打个栗子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;str = &#x27;Beautiful&#x27;</span><br><span class=\"line\">&gt;&gt;&gt;list(reversed(str))</span><br><span class=\"line\">[&#x27;l&#x27;, &#x27;u&#x27;, &#x27;f&#x27;, &#x27;i&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;a&#x27;, &#x27;e&#x27;, &#x27;B&#x27;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"enumerate函数\"><a href=\"#enumerate函数\" class=\"headerlink\" title=\"enumerate函数\"></a>enumerate函数</h3><p>返回索引和数据<br>打个栗子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;l = [&#x27;美丽&#x27;, &#x27;可爱&#x27;, &#x27;大方&#x27;, &#x27;善良&#x27;]</span><br><span class=\"line\">&gt;&gt;&gt;list(enumerate(l))</span><br><span class=\"line\">[(0, &#x27;美丽&#x27;), (1, &#x27;可爱&#x27;), (2, &#x27;大方&#x27;), (3, &#x27;善良&#x27;)]</span><br><span class=\"line\">&gt;&gt;&gt;for index,data in enumerate(l):</span><br><span class=\"line\">...     print(index,data)</span><br><span class=\"line\">0 美丽</span><br><span class=\"line\">1 可爱</span><br><span class=\"line\">2 大方</span><br><span class=\"line\">3 善良</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Daily-Thoughts\"><a href=\"#Daily-Thoughts\" class=\"headerlink\" title=\"Daily Thoughts\"></a>Daily Thoughts</h2><p>你觉得简单的题，有人就只用一行代码解决。太强了！！绝了，我觉得我就是一纯Python小白！学到很多。<br>另，效率有点低，明天多刷几题~</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>CodeWars 第1天</p>","more":"<hr>\n<h2 id=\"第一题：Jaden-Casing-Strings\"><a href=\"#第一题：Jaden-Casing-Strings\" class=\"headerlink\" title=\"第一题：Jaden Casing Strings\"></a>第一题：Jaden Casing Strings</h2><blockquote>\n<p>句子的每个单词首字母转为大写</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># My Solution</span><br><span class=\"line\">def toJadenCase(string):</span><br><span class=\"line\">    item = string.strip().split(&#x27; &#x27;)</span><br><span class=\"line\">    for i in range(len(item)):</span><br><span class=\"line\">        fir = item[i][0]</span><br><span class=\"line\">        if &#x27;a&#x27; &lt;= fir &lt;= &#x27;z&#x27;:</span><br><span class=\"line\">            item[i]=chr(ord(fir)-32)+item[i][1:]</span><br><span class=\"line\">    return &#x27; &#x27;.join(item)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Rank One Solution</span><br><span class=\"line\">def def toJadenCase(string):</span><br><span class=\"line\">    return &quot; &quot;.join(w.capitalize() for w in string.split())</span><br></pre></td></tr></table></figure>\n\n<p>(str是字符串类型)</p>\n<ol>\n<li>ord(char)：将字符串转为ASCII码；<br>chr(integer)：将整型转为字符</li>\n<li>str.capitalize()<br> 将字符串首字母转为大写字母</li>\n<li>str = sring.capwords(str)<br> 将字符串中各个单词的首字母转为大写字母</li>\n<li>列表/字典构建器<br>（本来以为是for的省略形式/高级用法）<br>（早就接触到了但是不知道该怎么用）<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列表的基本用法</span><br><span class=\"line\">&gt;&gt;&gt;[a*a for a in range(5)]</span><br><span class=\"line\">[0, 1, 4, 9, 16]</span><br><span class=\"line\"></span><br><span class=\"line\"># 但是这个有点消耗内存，下面可以用多少取多少</span><br><span class=\"line\">&gt;&gt;&gt;it = (a*a for a in range(5))</span><br><span class=\"line\">&gt;&gt;&gt;next(it)</span><br><span class=\"line\">0</span><br><span class=\"line\">&gt;&gt;&gt;next(it)</span><br><span class=\"line\">1</span><br><span class=\"line\">&gt;&gt;&gt;next(it)</span><br><span class=\"line\">4</span><br><span class=\"line\"></span><br><span class=\"line\"># 双重循环嵌套</span><br><span class=\"line\">&gt;&gt;&gt;[a+b for a in &#x27;abc&#x27; for b in &#x27;xyz&#x27; ]</span><br><span class=\"line\">[&#x27;ax&#x27;, &#x27;ay&#x27;, &#x27;az&#x27;, &#x27;bx&#x27;, &#x27;by&#x27;, &#x27;bz&#x27;, &#x27;cx&#x27;, &#x27;cy&#x27;, &#x27;cz&#x27;]</span><br><span class=\"line\"></span><br><span class=\"line\"># 字典(下面将原来的dict的key和value位置互换)</span><br><span class=\"line\">&gt;&gt;&gt;dict = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:3&#125;</span><br><span class=\"line\">&gt;&gt;&gt;&#123;a:b for b,a in dict.items()&#125;</span><br><span class=\"line\">&#123;1: &#x27;a&#x27;, 2: &#x27;b&#x27;, 3: &#x27;c&#x27;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#还可以直接把这个用在函数调用中</span><br><span class=\"line\">&gt;&gt;&gt;a = &#x27;I am here for you.&#x27;</span><br><span class=\"line\">&gt;&gt;&gt;&quot; &quot;.join(w.capitalize() for w in a.split())</span><br><span class=\"line\">&#x27;I Am Here For You.&#x27;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"第二题：Ones-and-Zeros\"><a href=\"#第二题：Ones-and-Zeros\" class=\"headerlink\" title=\"第二题：Ones and Zeros\"></a>第二题：Ones and Zeros</h2><blockquote>\n<p>二进制列表[1,0,0,1]转十进制9</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># My Solution</span><br><span class=\"line\">def binary_array_to_number(arr):</span><br><span class=\"line\">  l = len(arr)</span><br><span class=\"line\">  result = 0</span><br><span class=\"line\">  for i in range(l):</span><br><span class=\"line\">      result += pow(2, l-i-1)*arr[i]</span><br><span class=\"line\">  return result</span><br></pre></td></tr></table></figure>\n\n<p>int函数<br>int(data, base)<br>base表示进制，于是可以这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def binary_array_to_number(arr):</span><br><span class=\"line\">    return int(&#x27;&#x27;.join((map(str, arr))), 2)</span><br></pre></td></tr></table></figure>\n\n<p>还看到了一种方法，太强了！简单分析了一下，有点递归思想。看不懂的可以把s = s * 2 + digit拆开：<br>s4 = s3 * 2 + d4 = (s2*2+d3) * 2 + d4 ···</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def binary_array_to_number(arr):</span><br><span class=\"line\">    s = 0</span><br><span class=\"line\">    for digit in arr:</span><br><span class=\"line\">        s = s * 2 + digit</span><br><span class=\"line\">    return </span><br></pre></td></tr></table></figure>\n\n\n<p>另外学到了一招，算时间的，可以看到我的方法慢很多…</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; s1 = &quot;&quot;&quot;</span><br><span class=\"line\">... def binary_array_to_number(arr):</span><br><span class=\"line\">...     return int(&#x27;&#x27;.join((map(str, arr))), 2)&quot;&quot;&quot;</span><br><span class=\"line\">&gt;&gt;&gt; timeit.timeit(&quot;binary_array_to_number([1,0,0,1,1,0,1,0,1,1,0,0])&quot;, setup=s1, number=100000)</span><br><span class=\"line\">0.3919008289994963</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; s2 = &quot;&quot;&quot;</span><br><span class=\"line\">... def binary_array_to_number(arr):</span><br><span class=\"line\">...     l = len(arr)</span><br><span class=\"line\">...     result=0</span><br><span class=\"line\">...     for i in range(l):</span><br><span class=\"line\">...             result += pow(2, l-i-1)*arr[i]</span><br><span class=\"line\">...     return result&quot;&quot;&quot;</span><br><span class=\"line\">&gt;&gt;&gt; timeit.timeit(&quot;binary_array_to_number([1,0,0,1,1,0,1,0,1,1,0,0])&quot;, setup=s2, number=100000)</span><br><span class=\"line\">1.0104243380001208</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Others\"><a href=\"#Others\" class=\"headerlink\" title=\"Others\"></a>Others</h2><h3 id=\"reversed函数\"><a href=\"#reversed函数\" class=\"headerlink\" title=\"reversed函数\"></a>reversed函数</h3><p>传入元组、列表、字符串等，返回一个反转的迭代器。<br>打个栗子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;str = &#x27;Beautiful&#x27;</span><br><span class=\"line\">&gt;&gt;&gt;list(reversed(str))</span><br><span class=\"line\">[&#x27;l&#x27;, &#x27;u&#x27;, &#x27;f&#x27;, &#x27;i&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;a&#x27;, &#x27;e&#x27;, &#x27;B&#x27;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"enumerate函数\"><a href=\"#enumerate函数\" class=\"headerlink\" title=\"enumerate函数\"></a>enumerate函数</h3><p>返回索引和数据<br>打个栗子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;l = [&#x27;美丽&#x27;, &#x27;可爱&#x27;, &#x27;大方&#x27;, &#x27;善良&#x27;]</span><br><span class=\"line\">&gt;&gt;&gt;list(enumerate(l))</span><br><span class=\"line\">[(0, &#x27;美丽&#x27;), (1, &#x27;可爱&#x27;), (2, &#x27;大方&#x27;), (3, &#x27;善良&#x27;)]</span><br><span class=\"line\">&gt;&gt;&gt;for index,data in enumerate(l):</span><br><span class=\"line\">...     print(index,data)</span><br><span class=\"line\">0 美丽</span><br><span class=\"line\">1 可爱</span><br><span class=\"line\">2 大方</span><br><span class=\"line\">3 善良</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Daily-Thoughts\"><a href=\"#Daily-Thoughts\" class=\"headerlink\" title=\"Daily Thoughts\"></a>Daily Thoughts</h2><p>你觉得简单的题，有人就只用一行代码解决。太强了！！绝了，我觉得我就是一纯Python小白！学到很多。<br>另，效率有点低，明天多刷几题~</p>"},{"title":"Android新手路上一些坑|Android Studio|Android SDK|新手上路指南","date":"2019-02-15T14:33:01.000Z","_content":"最近把Android开发环境重新部署了一遍。踩了几个坑，骂了几句娘。网上很多方法都旧了，现在做个总结，也算个新年第一篇。\n<!--more-->\n---\nAndroid开发需要：Java,Android SDK,Android Studio\n**Java**，网上教程一堆。\n**SDK**，即Software Development Kit，软件开发工具包。\n下载exe/zip都可以，记得保存的路径中**不能有中文和空格**。\n**Android Studio**，安卓开发官方IDE，所以比起Eclipse，首推还是Android Studio吧\n\nAndroid SDK和Android Studio下载方式：\nAndroid Developer这个网站我翻~墙~也上不了，于是放弃。\n国内下载地址见下：\n[Android Studio中文社区][1]\n[AndroidDevTools][2]\n## 第一坑：SDK Manager闪退\n> 没想到吧，这里就遇到了第一坑。\n\n下载压缩包，解压后打开SDK Manager。然后... 出现了！闪退怪！\n网上查的方法，很多都试过了。大家网上都能查到，不多说。\n\n我的原因是JDK版本（11）过高，SDK不能兼容。**换成 JDK8 就OK了。**\n另外，如果在安装程序过程中，它告诉你你的工具包版本是1，太低了去重新下个版本更高的。也是这个原因，90%的可能是你用了JDK11，换成JDK8就好。\n\n进入Android Studio，经过一些基本配置之后启动AVD，但是...\n## 第二坑：AVD启动报错（ missing a kernel file ）\n> ERROR：This AVD's configuration is missing a kernel file \n\n上网查—> https://code.i-harness.com/en/q/9433dd （第三个回答）\n\n我把Android-sdk/system-images/android-28/google-apis 中的kernel-ranchu-64改名为kernel-qemu（视报错内容而定）\n还是不行，再把android-28下其他文件夹中的kernel-ranchu也改一下\n\n这下终于能打开了，但是怎么没有启动画面...\n## 第三坑：AVD模拟器打开黑屏\n网上查的很多方法都试了，没用。一下是几个：\n> 1. 编码问题，修改配置文件（这个很迷，原po地址找不到了）\n2. 内存大小设得太大了，调小一点。（这个没什么用）\n3. 不说了，你们在网上也能查到，然而有的很旧了，没什么用。\n\n我呢，把AndroidSDK版本从9换到8，__再换到6__ ，终于可以了！\n而且 **Android6** 也不会出现上述第二坑。\n\n## 第四坑：R文件报红\n> 背景：导入的Android项目，无法解析R文件\n\n奇怪的问题永远不会离开你！！！\nR文件报红，资源文件没有构建好，资源文件是Gradle自动生成的。可以在**app/build/generated/source/** 下看到rs的文件夹，有了这个文件夹应该就是R生成成功了。\n我在**app/build/generated/source/not_namespaced_r_class_source**下也看到很多R文件，但没有弄明白是什么意思。\n另附，网上的方法\n> \n1. Run->Clean Project->Rebuild Project\n2. Run->Make Module \"app\"...\n3. File->Invalidate and Restart\n4. 重新导入Project\n5. R文件大小超出默认，Help->Edit Custom Properties \n新建文件后添加下面这行代码：\n```idea.max.intellisense.filesize = 5000\n```\n\n\n然后呢，我全部没有成功！！！\n**下面开始废话！**\n我重复了好几次Gradle重新构建，全！部！没！用！！\n所以在这里劝告大家，如果重复好几次重新构建都没有用的话，那你也别指望下一次重构就能成功！！这只是在浪费时间！！听我说，这个时候你虽然相当烦躁，但是要停下来思考一下。越解决不了越烦躁，越烦躁就越不能静下心来，越静不下心就越容易错过解决办法。废话都是想讲给昨天的自己听的。\n**废话结束！**\n~~是时候考虑重装Android Studio了~~\n很简单，你要检查这里\n工程文件下的build.gradle\nclasspath 'com.android.tools.build:gradle:**3.2.0**'\n加粗部分是否与你的Android Studio版本一致，我就是因为版本过高了才出现的问题。\n正确版本要怎么查看呢：\nHelp->About\n\n最后一句叨叨：又TM是版本问题！！！\n\n## 后记\n以上是我部署环境中卡了比较久的三个问题，而且网上对应的解决方法很多都有点旧了，所以我总结了一篇。\n当然还有其他的问题，比如AS的Proxy设置，HAXM与Windows不兼容没法下载，新建模拟器时没有系统镜像，导入项目无法运行（File->Sysn Project with Gradle Files）等等问题，善用搜索引擎的大家一定都能知道~\n\n最后，祝各位新春快乐！万事如意！\n回头更一篇新年flag吧~新年正是立flag时！\n\n  [1]: http://www.android-studio.org/\n  [2]: https://www.androiddevtools.cn/\n  ","source":"_posts/Android新手路上一些坑-Android-Studio-Android-SDK-新手上路指南.md","raw":"---\ntitle: Android新手路上一些坑|Android Studio|Android SDK|新手上路指南\ndate: 2019-02-15 22:33:01\ncategories: 问题解决SolvedProblems\n---\n最近把Android开发环境重新部署了一遍。踩了几个坑，骂了几句娘。网上很多方法都旧了，现在做个总结，也算个新年第一篇。\n<!--more-->\n---\nAndroid开发需要：Java,Android SDK,Android Studio\n**Java**，网上教程一堆。\n**SDK**，即Software Development Kit，软件开发工具包。\n下载exe/zip都可以，记得保存的路径中**不能有中文和空格**。\n**Android Studio**，安卓开发官方IDE，所以比起Eclipse，首推还是Android Studio吧\n\nAndroid SDK和Android Studio下载方式：\nAndroid Developer这个网站我翻~墙~也上不了，于是放弃。\n国内下载地址见下：\n[Android Studio中文社区][1]\n[AndroidDevTools][2]\n## 第一坑：SDK Manager闪退\n> 没想到吧，这里就遇到了第一坑。\n\n下载压缩包，解压后打开SDK Manager。然后... 出现了！闪退怪！\n网上查的方法，很多都试过了。大家网上都能查到，不多说。\n\n我的原因是JDK版本（11）过高，SDK不能兼容。**换成 JDK8 就OK了。**\n另外，如果在安装程序过程中，它告诉你你的工具包版本是1，太低了去重新下个版本更高的。也是这个原因，90%的可能是你用了JDK11，换成JDK8就好。\n\n进入Android Studio，经过一些基本配置之后启动AVD，但是...\n## 第二坑：AVD启动报错（ missing a kernel file ）\n> ERROR：This AVD's configuration is missing a kernel file \n\n上网查—> https://code.i-harness.com/en/q/9433dd （第三个回答）\n\n我把Android-sdk/system-images/android-28/google-apis 中的kernel-ranchu-64改名为kernel-qemu（视报错内容而定）\n还是不行，再把android-28下其他文件夹中的kernel-ranchu也改一下\n\n这下终于能打开了，但是怎么没有启动画面...\n## 第三坑：AVD模拟器打开黑屏\n网上查的很多方法都试了，没用。一下是几个：\n> 1. 编码问题，修改配置文件（这个很迷，原po地址找不到了）\n2. 内存大小设得太大了，调小一点。（这个没什么用）\n3. 不说了，你们在网上也能查到，然而有的很旧了，没什么用。\n\n我呢，把AndroidSDK版本从9换到8，__再换到6__ ，终于可以了！\n而且 **Android6** 也不会出现上述第二坑。\n\n## 第四坑：R文件报红\n> 背景：导入的Android项目，无法解析R文件\n\n奇怪的问题永远不会离开你！！！\nR文件报红，资源文件没有构建好，资源文件是Gradle自动生成的。可以在**app/build/generated/source/** 下看到rs的文件夹，有了这个文件夹应该就是R生成成功了。\n我在**app/build/generated/source/not_namespaced_r_class_source**下也看到很多R文件，但没有弄明白是什么意思。\n另附，网上的方法\n> \n1. Run->Clean Project->Rebuild Project\n2. Run->Make Module \"app\"...\n3. File->Invalidate and Restart\n4. 重新导入Project\n5. R文件大小超出默认，Help->Edit Custom Properties \n新建文件后添加下面这行代码：\n```idea.max.intellisense.filesize = 5000\n```\n\n\n然后呢，我全部没有成功！！！\n**下面开始废话！**\n我重复了好几次Gradle重新构建，全！部！没！用！！\n所以在这里劝告大家，如果重复好几次重新构建都没有用的话，那你也别指望下一次重构就能成功！！这只是在浪费时间！！听我说，这个时候你虽然相当烦躁，但是要停下来思考一下。越解决不了越烦躁，越烦躁就越不能静下心来，越静不下心就越容易错过解决办法。废话都是想讲给昨天的自己听的。\n**废话结束！**\n~~是时候考虑重装Android Studio了~~\n很简单，你要检查这里\n工程文件下的build.gradle\nclasspath 'com.android.tools.build:gradle:**3.2.0**'\n加粗部分是否与你的Android Studio版本一致，我就是因为版本过高了才出现的问题。\n正确版本要怎么查看呢：\nHelp->About\n\n最后一句叨叨：又TM是版本问题！！！\n\n## 后记\n以上是我部署环境中卡了比较久的三个问题，而且网上对应的解决方法很多都有点旧了，所以我总结了一篇。\n当然还有其他的问题，比如AS的Proxy设置，HAXM与Windows不兼容没法下载，新建模拟器时没有系统镜像，导入项目无法运行（File->Sysn Project with Gradle Files）等等问题，善用搜索引擎的大家一定都能知道~\n\n最后，祝各位新春快乐！万事如意！\n回头更一篇新年flag吧~新年正是立flag时！\n\n  [1]: http://www.android-studio.org/\n  [2]: https://www.androiddevtools.cn/\n  ","slug":"Android新手路上一些坑-Android-Studio-Android-SDK-新手上路指南","published":1,"updated":"2019-02-15T14:33:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggm000e38t47rep5v3s","content":"<p>最近把Android开发环境重新部署了一遍。踩了几个坑，骂了几句娘。网上很多方法都旧了，现在做个总结，也算个新年第一篇。</p>\n<span id=\"more\"></span>\n<hr>\n<p>Android开发需要：Java,Android SDK,Android Studio<br><strong>Java</strong>，网上教程一堆。<br><strong>SDK</strong>，即Software Development Kit，软件开发工具包。<br>下载exe/zip都可以，记得保存的路径中<strong>不能有中文和空格</strong>。<br><strong>Android Studio</strong>，安卓开发官方IDE，所以比起Eclipse，首推还是Android Studio吧</p>\n<p>Android SDK和Android Studio下载方式：<br>Android Developer这个网站我翻<del>墙</del>也上不了，于是放弃。<br>国内下载地址见下：<br><a href=\"http://www.android-studio.org/\">Android Studio中文社区</a><br><a href=\"https://www.androiddevtools.cn/\">AndroidDevTools</a></p>\n<h2 id=\"第一坑：SDK-Manager闪退\"><a href=\"#第一坑：SDK-Manager闪退\" class=\"headerlink\" title=\"第一坑：SDK Manager闪退\"></a>第一坑：SDK Manager闪退</h2><blockquote>\n<p>没想到吧，这里就遇到了第一坑。</p>\n</blockquote>\n<p>下载压缩包，解压后打开SDK Manager。然后… 出现了！闪退怪！<br>网上查的方法，很多都试过了。大家网上都能查到，不多说。</p>\n<p>我的原因是JDK版本（11）过高，SDK不能兼容。<strong>换成 JDK8 就OK了。</strong><br>另外，如果在安装程序过程中，它告诉你你的工具包版本是1，太低了去重新下个版本更高的。也是这个原因，90%的可能是你用了JDK11，换成JDK8就好。</p>\n<p>进入Android Studio，经过一些基本配置之后启动AVD，但是…</p>\n<h2 id=\"第二坑：AVD启动报错（-missing-a-kernel-file-）\"><a href=\"#第二坑：AVD启动报错（-missing-a-kernel-file-）\" class=\"headerlink\" title=\"第二坑：AVD启动报错（ missing a kernel file ）\"></a>第二坑：AVD启动报错（ missing a kernel file ）</h2><blockquote>\n<p>ERROR：This AVD’s configuration is missing a kernel file </p>\n</blockquote>\n<p>上网查—&gt; <a href=\"https://code.i-harness.com/en/q/9433dd\">https://code.i-harness.com/en/q/9433dd</a> （第三个回答）</p>\n<p>我把Android-sdk/system-images/android-28/google-apis 中的kernel-ranchu-64改名为kernel-qemu（视报错内容而定）<br>还是不行，再把android-28下其他文件夹中的kernel-ranchu也改一下</p>\n<p>这下终于能打开了，但是怎么没有启动画面…</p>\n<h2 id=\"第三坑：AVD模拟器打开黑屏\"><a href=\"#第三坑：AVD模拟器打开黑屏\" class=\"headerlink\" title=\"第三坑：AVD模拟器打开黑屏\"></a>第三坑：AVD模拟器打开黑屏</h2><p>网上查的很多方法都试了，没用。一下是几个：</p>\n<blockquote>\n<ol>\n<li>编码问题，修改配置文件（这个很迷，原po地址找不到了）</li>\n<li>内存大小设得太大了，调小一点。（这个没什么用）</li>\n<li>不说了，你们在网上也能查到，然而有的很旧了，没什么用。</li>\n</ol>\n</blockquote>\n<p>我呢，把AndroidSDK版本从9换到8，<strong>再换到6</strong> ，终于可以了！<br>而且 <strong>Android6</strong> 也不会出现上述第二坑。</p>\n<h2 id=\"第四坑：R文件报红\"><a href=\"#第四坑：R文件报红\" class=\"headerlink\" title=\"第四坑：R文件报红\"></a>第四坑：R文件报红</h2><blockquote>\n<p>背景：导入的Android项目，无法解析R文件</p>\n</blockquote>\n<p>奇怪的问题永远不会离开你！！！<br>R文件报红，资源文件没有构建好，资源文件是Gradle自动生成的。可以在<strong>app/build/generated/source/</strong> 下看到rs的文件夹，有了这个文件夹应该就是R生成成功了。<br>我在<strong>app/build/generated/source/not_namespaced_r_class_source</strong>下也看到很多R文件，但没有弄明白是什么意思。<br>另附，网上的方法</p>\n<blockquote>\n</blockquote>\n<ol>\n<li>Run-&gt;Clean Project-&gt;Rebuild Project</li>\n<li>Run-&gt;Make Module “app”…</li>\n<li>File-&gt;Invalidate and Restart</li>\n<li>重新导入Project</li>\n<li>R文件大小超出默认，Help-&gt;Edit Custom Properties<br>新建文件后添加下面这行代码：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>然后呢，我全部没有成功！！！<br><strong>下面开始废话！</strong><br>我重复了好几次Gradle重新构建，全！部！没！用！！<br>所以在这里劝告大家，如果重复好几次重新构建都没有用的话，那你也别指望下一次重构就能成功！！这只是在浪费时间！！听我说，这个时候你虽然相当烦躁，但是要停下来思考一下。越解决不了越烦躁，越烦躁就越不能静下心来，越静不下心就越容易错过解决办法。废话都是想讲给昨天的自己听的。<br><strong>废话结束！</strong><br><del>是时候考虑重装Android Studio了</del><br>很简单，你要检查这里<br>工程文件下的build.gradle<br>classpath ‘com.android.tools.build:gradle:<strong>3.2.0</strong>‘<br>加粗部分是否与你的Android Studio版本一致，我就是因为版本过高了才出现的问题。<br>正确版本要怎么查看呢：<br>Help-&gt;About</p>\n<p>最后一句叨叨：又TM是版本问题！！！</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>以上是我部署环境中卡了比较久的三个问题，而且网上对应的解决方法很多都有点旧了，所以我总结了一篇。<br>当然还有其他的问题，比如AS的Proxy设置，HAXM与Windows不兼容没法下载，新建模拟器时没有系统镜像，导入项目无法运行（File-&gt;Sysn Project with Gradle Files）等等问题，善用搜索引擎的大家一定都能知道~</p>\n<p>最后，祝各位新春快乐！万事如意！<br>回头更一篇新年flag吧~新年正是立flag时！</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>最近把Android开发环境重新部署了一遍。踩了几个坑，骂了几句娘。网上很多方法都旧了，现在做个总结，也算个新年第一篇。</p>","more":"<hr>\n<p>Android开发需要：Java,Android SDK,Android Studio<br><strong>Java</strong>，网上教程一堆。<br><strong>SDK</strong>，即Software Development Kit，软件开发工具包。<br>下载exe/zip都可以，记得保存的路径中<strong>不能有中文和空格</strong>。<br><strong>Android Studio</strong>，安卓开发官方IDE，所以比起Eclipse，首推还是Android Studio吧</p>\n<p>Android SDK和Android Studio下载方式：<br>Android Developer这个网站我翻<del>墙</del>也上不了，于是放弃。<br>国内下载地址见下：<br><a href=\"http://www.android-studio.org/\">Android Studio中文社区</a><br><a href=\"https://www.androiddevtools.cn/\">AndroidDevTools</a></p>\n<h2 id=\"第一坑：SDK-Manager闪退\"><a href=\"#第一坑：SDK-Manager闪退\" class=\"headerlink\" title=\"第一坑：SDK Manager闪退\"></a>第一坑：SDK Manager闪退</h2><blockquote>\n<p>没想到吧，这里就遇到了第一坑。</p>\n</blockquote>\n<p>下载压缩包，解压后打开SDK Manager。然后… 出现了！闪退怪！<br>网上查的方法，很多都试过了。大家网上都能查到，不多说。</p>\n<p>我的原因是JDK版本（11）过高，SDK不能兼容。<strong>换成 JDK8 就OK了。</strong><br>另外，如果在安装程序过程中，它告诉你你的工具包版本是1，太低了去重新下个版本更高的。也是这个原因，90%的可能是你用了JDK11，换成JDK8就好。</p>\n<p>进入Android Studio，经过一些基本配置之后启动AVD，但是…</p>\n<h2 id=\"第二坑：AVD启动报错（-missing-a-kernel-file-）\"><a href=\"#第二坑：AVD启动报错（-missing-a-kernel-file-）\" class=\"headerlink\" title=\"第二坑：AVD启动报错（ missing a kernel file ）\"></a>第二坑：AVD启动报错（ missing a kernel file ）</h2><blockquote>\n<p>ERROR：This AVD’s configuration is missing a kernel file </p>\n</blockquote>\n<p>上网查—&gt; <a href=\"https://code.i-harness.com/en/q/9433dd\">https://code.i-harness.com/en/q/9433dd</a> （第三个回答）</p>\n<p>我把Android-sdk/system-images/android-28/google-apis 中的kernel-ranchu-64改名为kernel-qemu（视报错内容而定）<br>还是不行，再把android-28下其他文件夹中的kernel-ranchu也改一下</p>\n<p>这下终于能打开了，但是怎么没有启动画面…</p>\n<h2 id=\"第三坑：AVD模拟器打开黑屏\"><a href=\"#第三坑：AVD模拟器打开黑屏\" class=\"headerlink\" title=\"第三坑：AVD模拟器打开黑屏\"></a>第三坑：AVD模拟器打开黑屏</h2><p>网上查的很多方法都试了，没用。一下是几个：</p>\n<blockquote>\n<ol>\n<li>编码问题，修改配置文件（这个很迷，原po地址找不到了）</li>\n<li>内存大小设得太大了，调小一点。（这个没什么用）</li>\n<li>不说了，你们在网上也能查到，然而有的很旧了，没什么用。</li>\n</ol>\n</blockquote>\n<p>我呢，把AndroidSDK版本从9换到8，<strong>再换到6</strong> ，终于可以了！<br>而且 <strong>Android6</strong> 也不会出现上述第二坑。</p>\n<h2 id=\"第四坑：R文件报红\"><a href=\"#第四坑：R文件报红\" class=\"headerlink\" title=\"第四坑：R文件报红\"></a>第四坑：R文件报红</h2><blockquote>\n<p>背景：导入的Android项目，无法解析R文件</p>\n</blockquote>\n<p>奇怪的问题永远不会离开你！！！<br>R文件报红，资源文件没有构建好，资源文件是Gradle自动生成的。可以在<strong>app/build/generated/source/</strong> 下看到rs的文件夹，有了这个文件夹应该就是R生成成功了。<br>我在<strong>app/build/generated/source/not_namespaced_r_class_source</strong>下也看到很多R文件，但没有弄明白是什么意思。<br>另附，网上的方法</p>\n<blockquote>\n</blockquote>\n<ol>\n<li>Run-&gt;Clean Project-&gt;Rebuild Project</li>\n<li>Run-&gt;Make Module “app”…</li>\n<li>File-&gt;Invalidate and Restart</li>\n<li>重新导入Project</li>\n<li>R文件大小超出默认，Help-&gt;Edit Custom Properties<br>新建文件后添加下面这行代码：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>然后呢，我全部没有成功！！！<br><strong>下面开始废话！</strong><br>我重复了好几次Gradle重新构建，全！部！没！用！！<br>所以在这里劝告大家，如果重复好几次重新构建都没有用的话，那你也别指望下一次重构就能成功！！这只是在浪费时间！！听我说，这个时候你虽然相当烦躁，但是要停下来思考一下。越解决不了越烦躁，越烦躁就越不能静下心来，越静不下心就越容易错过解决办法。废话都是想讲给昨天的自己听的。<br><strong>废话结束！</strong><br><del>是时候考虑重装Android Studio了</del><br>很简单，你要检查这里<br>工程文件下的build.gradle<br>classpath ‘com.android.tools.build:gradle:<strong>3.2.0</strong>‘<br>加粗部分是否与你的Android Studio版本一致，我就是因为版本过高了才出现的问题。<br>正确版本要怎么查看呢：<br>Help-&gt;About</p>\n<p>最后一句叨叨：又TM是版本问题！！！</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>以上是我部署环境中卡了比较久的三个问题，而且网上对应的解决方法很多都有点旧了，所以我总结了一篇。<br>当然还有其他的问题，比如AS的Proxy设置，HAXM与Windows不兼容没法下载，新建模拟器时没有系统镜像，导入项目无法运行（File-&gt;Sysn Project with Gradle Files）等等问题，善用搜索引擎的大家一定都能知道~</p>\n<p>最后，祝各位新春快乐！万事如意！<br>回头更一篇新年flag吧~新年正是立flag时！</p>"},{"title":"Coding0620","date":"2019-06-20T08:05:44.000Z","_content":"\n\nCodeWars第二天\n\n<!--more-->\n\n---\n\n## 第一题 Decode the Morse code/1\n\n```\n# My Solution\ndef decodeMorse(morse_code):\n    # ToDo: Accept dots, dashes and spaces, return human-readable message\n    str = ''\n    words = morse_code.strip().split('   ')\n    for word in words:\n        w = [w.replace(w, MORSE_CODE[w]) for w in word.split(' ')]\n        str = str + ''.join(w)+' '\n    return str.strip()\n```\n(其实我觉得比起第一天的好多了。用到了第一天学到的join和列表构建)\n这个解法不错，算得上有点clever~~\nrank one的解法依然只用了一行，一行代码两个join\n有个改进的地方。\n单词可以放在一个list里，然后再return' '.join(list)就好了。\n\n## 第二题 Find the missing letter\n给一个字符列表，找出按顺序确少的字母。\n如['a','b','c','e']，返回'd'\n```\n# My Solution\ndef find_missing_letter(chars):\n    for i in range(1, len(chars)):\n        if ord(chars[i]) - ord(chars[i-1]) > 1:\n            break\n    return chr(ord(chars[i])-1)\n```\n\n另一个解法是匹配字符串。然后一个一个匹配。第一个没匹配上的就是错的。\n\n## 第三题 \n\n将字符串中的字母代替为其在字母表中对应的位置（数字）\n```\n# My Solution\ndef alphabet_position(text):\n    alphabet = {}\n    result = []\n    for i in range(26):\n        alphabet[chr(i+97)] = str(i+1)\n    text = list(text.replace(' ','').lower())\n    for i in range(len(text)):\n        if text[i] in alphabet.keys():\n            result.append(alphabet[text[i]])\n    return ' '.join(result)\n```\n**Points：**\n1. lower() ：将字符串中的所有字母转为小写字母\n2. str(): 如果被定义了的话，这个函数就用不了了\n3. 把string转为list：用list()\n\n**他山之石：**\n1. 字母表中的位置其实就是这个字母的ASCII码 - a的ASCII码（97） + 1（即直接减96）\n2. 可以不构建字典，直接用\"abcdefg...\"的字符串，再用index函数就可以找到位置了\n3. 判断字符是否是字母，有函数:isalpha()\n4. 之前讲到的list构造中，还可以加上条件判断\n5. 要遍历字符串中的每一个字符，直接for c in str即可，不用转为列表再操作~\nPS: 但是我去计算了一下时间（time.clock()），先转为list再操作，用时会短一些。当然，差的不是很多。\n\n```\n# 验证运算时间\nimport time\n\ndef alphabet_position_1(text):\n    return ' '.join(str(ord(x)-96) for x in text.lower() if x.isalpha())\n\ndef alphabet_position_2(text):\n    return ' '.join(str(ord(x)-96) for x in list(text.lower()) if x.isalpha())\n\ns = 'iuyfsvbdutg iaef'\nstart = time.clock()\nalphabet_position_1(s)\nend = time.clock()\n\nprint(\"运行时间：\", str(end-start))\n\nstart = time.clock()\nalphabet_position_2(s)\nend = time.clock()\nprint(\"运行时间：\", str(end-start))\n-----------------------------\n结果：\n运行时间： 5.759999999999099e-05\n运行时间： 4.394700000000251e-05\n```\n\n```\n# 一行代码的解法\ndef alphabet_position(text):\n    return ' '.join(str(ord(x)-96) for x in text.lower() if x.isalpha())\n```\n\n\n## 后记\n有点进步（主要是会用了一些python函数）。题目本身也不难，主要要想到一个好的解法。希望来点难度更大的题啦~\n","source":"_posts/Coding0620.md","raw":"---\ntitle: Coding0620\ndate: 2019-06-20 16:05:44\ncategories: DailyCode\nphoto: https://forlwq.oss-cn-hangzhou.aliyuncs.com/DailyCode/2.jpg\n---\n\n\nCodeWars第二天\n\n<!--more-->\n\n---\n\n## 第一题 Decode the Morse code/1\n\n```\n# My Solution\ndef decodeMorse(morse_code):\n    # ToDo: Accept dots, dashes and spaces, return human-readable message\n    str = ''\n    words = morse_code.strip().split('   ')\n    for word in words:\n        w = [w.replace(w, MORSE_CODE[w]) for w in word.split(' ')]\n        str = str + ''.join(w)+' '\n    return str.strip()\n```\n(其实我觉得比起第一天的好多了。用到了第一天学到的join和列表构建)\n这个解法不错，算得上有点clever~~\nrank one的解法依然只用了一行，一行代码两个join\n有个改进的地方。\n单词可以放在一个list里，然后再return' '.join(list)就好了。\n\n## 第二题 Find the missing letter\n给一个字符列表，找出按顺序确少的字母。\n如['a','b','c','e']，返回'd'\n```\n# My Solution\ndef find_missing_letter(chars):\n    for i in range(1, len(chars)):\n        if ord(chars[i]) - ord(chars[i-1]) > 1:\n            break\n    return chr(ord(chars[i])-1)\n```\n\n另一个解法是匹配字符串。然后一个一个匹配。第一个没匹配上的就是错的。\n\n## 第三题 \n\n将字符串中的字母代替为其在字母表中对应的位置（数字）\n```\n# My Solution\ndef alphabet_position(text):\n    alphabet = {}\n    result = []\n    for i in range(26):\n        alphabet[chr(i+97)] = str(i+1)\n    text = list(text.replace(' ','').lower())\n    for i in range(len(text)):\n        if text[i] in alphabet.keys():\n            result.append(alphabet[text[i]])\n    return ' '.join(result)\n```\n**Points：**\n1. lower() ：将字符串中的所有字母转为小写字母\n2. str(): 如果被定义了的话，这个函数就用不了了\n3. 把string转为list：用list()\n\n**他山之石：**\n1. 字母表中的位置其实就是这个字母的ASCII码 - a的ASCII码（97） + 1（即直接减96）\n2. 可以不构建字典，直接用\"abcdefg...\"的字符串，再用index函数就可以找到位置了\n3. 判断字符是否是字母，有函数:isalpha()\n4. 之前讲到的list构造中，还可以加上条件判断\n5. 要遍历字符串中的每一个字符，直接for c in str即可，不用转为列表再操作~\nPS: 但是我去计算了一下时间（time.clock()），先转为list再操作，用时会短一些。当然，差的不是很多。\n\n```\n# 验证运算时间\nimport time\n\ndef alphabet_position_1(text):\n    return ' '.join(str(ord(x)-96) for x in text.lower() if x.isalpha())\n\ndef alphabet_position_2(text):\n    return ' '.join(str(ord(x)-96) for x in list(text.lower()) if x.isalpha())\n\ns = 'iuyfsvbdutg iaef'\nstart = time.clock()\nalphabet_position_1(s)\nend = time.clock()\n\nprint(\"运行时间：\", str(end-start))\n\nstart = time.clock()\nalphabet_position_2(s)\nend = time.clock()\nprint(\"运行时间：\", str(end-start))\n-----------------------------\n结果：\n运行时间： 5.759999999999099e-05\n运行时间： 4.394700000000251e-05\n```\n\n```\n# 一行代码的解法\ndef alphabet_position(text):\n    return ' '.join(str(ord(x)-96) for x in text.lower() if x.isalpha())\n```\n\n\n## 后记\n有点进步（主要是会用了一些python函数）。题目本身也不难，主要要想到一个好的解法。希望来点难度更大的题啦~\n","slug":"Coding0620","published":1,"updated":"2019-06-20T08:05:44.000Z","photos":["https://forlwq.oss-cn-hangzhou.aliyuncs.com/DailyCode/2.jpg"],"comments":1,"layout":"post","link":"","_id":"cl1jeaggn000g38t45z0y5z1y","content":"<p>CodeWars第二天</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"第一题-Decode-the-Morse-code-1\"><a href=\"#第一题-Decode-the-Morse-code-1\" class=\"headerlink\" title=\"第一题 Decode the Morse code/1\"></a>第一题 Decode the Morse code/1</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># My Solution</span><br><span class=\"line\">def decodeMorse(morse_code):</span><br><span class=\"line\">    # ToDo: Accept dots, dashes and spaces, return human-readable message</span><br><span class=\"line\">    str = &#x27;&#x27;</span><br><span class=\"line\">    words = morse_code.strip().split(&#x27;   &#x27;)</span><br><span class=\"line\">    for word in words:</span><br><span class=\"line\">        w = [w.replace(w, MORSE_CODE[w]) for w in word.split(&#x27; &#x27;)]</span><br><span class=\"line\">        str = str + &#x27;&#x27;.join(w)+&#x27; &#x27;</span><br><span class=\"line\">    return str.strip()</span><br></pre></td></tr></table></figure>\n<p>(其实我觉得比起第一天的好多了。用到了第一天学到的join和列表构建)<br>这个解法不错，算得上有点clever~~<br>rank one的解法依然只用了一行，一行代码两个join<br>有个改进的地方。<br>单词可以放在一个list里，然后再return’ ‘.join(list)就好了。</p>\n<h2 id=\"第二题-Find-the-missing-letter\"><a href=\"#第二题-Find-the-missing-letter\" class=\"headerlink\" title=\"第二题 Find the missing letter\"></a>第二题 Find the missing letter</h2><p>给一个字符列表，找出按顺序确少的字母。<br>如[‘a’,’b’,’c’,’e’]，返回’d’</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># My Solution</span><br><span class=\"line\">def find_missing_letter(chars):</span><br><span class=\"line\">    for i in range(1, len(chars)):</span><br><span class=\"line\">        if ord(chars[i]) - ord(chars[i-1]) &gt; 1:</span><br><span class=\"line\">            break</span><br><span class=\"line\">    return chr(ord(chars[i])-1)</span><br></pre></td></tr></table></figure>\n\n<p>另一个解法是匹配字符串。然后一个一个匹配。第一个没匹配上的就是错的。</p>\n<h2 id=\"第三题\"><a href=\"#第三题\" class=\"headerlink\" title=\"第三题\"></a>第三题</h2><p>将字符串中的字母代替为其在字母表中对应的位置（数字）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># My Solution</span><br><span class=\"line\">def alphabet_position(text):</span><br><span class=\"line\">    alphabet = &#123;&#125;</span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    for i in range(26):</span><br><span class=\"line\">        alphabet[chr(i+97)] = str(i+1)</span><br><span class=\"line\">    text = list(text.replace(&#x27; &#x27;,&#x27;&#x27;).lower())</span><br><span class=\"line\">    for i in range(len(text)):</span><br><span class=\"line\">        if text[i] in alphabet.keys():</span><br><span class=\"line\">            result.append(alphabet[text[i]])</span><br><span class=\"line\">    return &#x27; &#x27;.join(result)</span><br></pre></td></tr></table></figure>\n<p><strong>Points：</strong></p>\n<ol>\n<li>lower() ：将字符串中的所有字母转为小写字母</li>\n<li>str(): 如果被定义了的话，这个函数就用不了了</li>\n<li>把string转为list：用list()</li>\n</ol>\n<p><strong>他山之石：</strong></p>\n<ol>\n<li>字母表中的位置其实就是这个字母的ASCII码 - a的ASCII码（97） + 1（即直接减96）</li>\n<li>可以不构建字典，直接用”abcdefg…”的字符串，再用index函数就可以找到位置了</li>\n<li>判断字符是否是字母，有函数:isalpha()</li>\n<li>之前讲到的list构造中，还可以加上条件判断</li>\n<li>要遍历字符串中的每一个字符，直接for c in str即可，不用转为列表再操作~<br>PS: 但是我去计算了一下时间（time.clock()），先转为list再操作，用时会短一些。当然，差的不是很多。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 验证运算时间</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">def alphabet_position_1(text):</span><br><span class=\"line\">    return &#x27; &#x27;.join(str(ord(x)-96) for x in text.lower() if x.isalpha())</span><br><span class=\"line\"></span><br><span class=\"line\">def alphabet_position_2(text):</span><br><span class=\"line\">    return &#x27; &#x27;.join(str(ord(x)-96) for x in list(text.lower()) if x.isalpha())</span><br><span class=\"line\"></span><br><span class=\"line\">s = &#x27;iuyfsvbdutg iaef&#x27;</span><br><span class=\"line\">start = time.clock()</span><br><span class=\"line\">alphabet_position_1(s)</span><br><span class=\"line\">end = time.clock()</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;运行时间：&quot;, str(end-start))</span><br><span class=\"line\"></span><br><span class=\"line\">start = time.clock()</span><br><span class=\"line\">alphabet_position_2(s)</span><br><span class=\"line\">end = time.clock()</span><br><span class=\"line\">print(&quot;运行时间：&quot;, str(end-start))</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">结果：</span><br><span class=\"line\">运行时间： 5.759999999999099e-05</span><br><span class=\"line\">运行时间： 4.394700000000251e-05</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 一行代码的解法</span><br><span class=\"line\">def alphabet_position(text):</span><br><span class=\"line\">    return &#x27; &#x27;.join(str(ord(x)-96) for x in text.lower() if x.isalpha())</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>有点进步（主要是会用了一些python函数）。题目本身也不难，主要要想到一个好的解法。希望来点难度更大的题啦~</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>CodeWars第二天</p>","more":"<hr>\n<h2 id=\"第一题-Decode-the-Morse-code-1\"><a href=\"#第一题-Decode-the-Morse-code-1\" class=\"headerlink\" title=\"第一题 Decode the Morse code/1\"></a>第一题 Decode the Morse code/1</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># My Solution</span><br><span class=\"line\">def decodeMorse(morse_code):</span><br><span class=\"line\">    # ToDo: Accept dots, dashes and spaces, return human-readable message</span><br><span class=\"line\">    str = &#x27;&#x27;</span><br><span class=\"line\">    words = morse_code.strip().split(&#x27;   &#x27;)</span><br><span class=\"line\">    for word in words:</span><br><span class=\"line\">        w = [w.replace(w, MORSE_CODE[w]) for w in word.split(&#x27; &#x27;)]</span><br><span class=\"line\">        str = str + &#x27;&#x27;.join(w)+&#x27; &#x27;</span><br><span class=\"line\">    return str.strip()</span><br></pre></td></tr></table></figure>\n<p>(其实我觉得比起第一天的好多了。用到了第一天学到的join和列表构建)<br>这个解法不错，算得上有点clever~~<br>rank one的解法依然只用了一行，一行代码两个join<br>有个改进的地方。<br>单词可以放在一个list里，然后再return’ ‘.join(list)就好了。</p>\n<h2 id=\"第二题-Find-the-missing-letter\"><a href=\"#第二题-Find-the-missing-letter\" class=\"headerlink\" title=\"第二题 Find the missing letter\"></a>第二题 Find the missing letter</h2><p>给一个字符列表，找出按顺序确少的字母。<br>如[‘a’,’b’,’c’,’e’]，返回’d’</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># My Solution</span><br><span class=\"line\">def find_missing_letter(chars):</span><br><span class=\"line\">    for i in range(1, len(chars)):</span><br><span class=\"line\">        if ord(chars[i]) - ord(chars[i-1]) &gt; 1:</span><br><span class=\"line\">            break</span><br><span class=\"line\">    return chr(ord(chars[i])-1)</span><br></pre></td></tr></table></figure>\n\n<p>另一个解法是匹配字符串。然后一个一个匹配。第一个没匹配上的就是错的。</p>\n<h2 id=\"第三题\"><a href=\"#第三题\" class=\"headerlink\" title=\"第三题\"></a>第三题</h2><p>将字符串中的字母代替为其在字母表中对应的位置（数字）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># My Solution</span><br><span class=\"line\">def alphabet_position(text):</span><br><span class=\"line\">    alphabet = &#123;&#125;</span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    for i in range(26):</span><br><span class=\"line\">        alphabet[chr(i+97)] = str(i+1)</span><br><span class=\"line\">    text = list(text.replace(&#x27; &#x27;,&#x27;&#x27;).lower())</span><br><span class=\"line\">    for i in range(len(text)):</span><br><span class=\"line\">        if text[i] in alphabet.keys():</span><br><span class=\"line\">            result.append(alphabet[text[i]])</span><br><span class=\"line\">    return &#x27; &#x27;.join(result)</span><br></pre></td></tr></table></figure>\n<p><strong>Points：</strong></p>\n<ol>\n<li>lower() ：将字符串中的所有字母转为小写字母</li>\n<li>str(): 如果被定义了的话，这个函数就用不了了</li>\n<li>把string转为list：用list()</li>\n</ol>\n<p><strong>他山之石：</strong></p>\n<ol>\n<li>字母表中的位置其实就是这个字母的ASCII码 - a的ASCII码（97） + 1（即直接减96）</li>\n<li>可以不构建字典，直接用”abcdefg…”的字符串，再用index函数就可以找到位置了</li>\n<li>判断字符是否是字母，有函数:isalpha()</li>\n<li>之前讲到的list构造中，还可以加上条件判断</li>\n<li>要遍历字符串中的每一个字符，直接for c in str即可，不用转为列表再操作~<br>PS: 但是我去计算了一下时间（time.clock()），先转为list再操作，用时会短一些。当然，差的不是很多。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 验证运算时间</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">def alphabet_position_1(text):</span><br><span class=\"line\">    return &#x27; &#x27;.join(str(ord(x)-96) for x in text.lower() if x.isalpha())</span><br><span class=\"line\"></span><br><span class=\"line\">def alphabet_position_2(text):</span><br><span class=\"line\">    return &#x27; &#x27;.join(str(ord(x)-96) for x in list(text.lower()) if x.isalpha())</span><br><span class=\"line\"></span><br><span class=\"line\">s = &#x27;iuyfsvbdutg iaef&#x27;</span><br><span class=\"line\">start = time.clock()</span><br><span class=\"line\">alphabet_position_1(s)</span><br><span class=\"line\">end = time.clock()</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;运行时间：&quot;, str(end-start))</span><br><span class=\"line\"></span><br><span class=\"line\">start = time.clock()</span><br><span class=\"line\">alphabet_position_2(s)</span><br><span class=\"line\">end = time.clock()</span><br><span class=\"line\">print(&quot;运行时间：&quot;, str(end-start))</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">结果：</span><br><span class=\"line\">运行时间： 5.759999999999099e-05</span><br><span class=\"line\">运行时间： 4.394700000000251e-05</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 一行代码的解法</span><br><span class=\"line\">def alphabet_position(text):</span><br><span class=\"line\">    return &#x27; &#x27;.join(str(ord(x)-96) for x in text.lower() if x.isalpha())</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>有点进步（主要是会用了一些python函数）。题目本身也不难，主要要想到一个好的解法。希望来点难度更大的题啦~</p>"},{"title":"Colab运行python代码找不到路径","date":"2021-03-31T03:11:54.000Z","_content":"\n因为要修改工作路径！\n\n<!--more-->\n\n已经有两次碰到这个问题了。原因是我在谷歌云盘中新建了colab笔记本，同一目录下放了想要运行的代码，但是给我报错`No such file or directory`。但是colab文件的工作目录跟他文件放的位置没关系，如果要运行云盘中的文件，需要**挂载谷歌云盘**然后**修改工作路径**。\n\n![run-error](https://forlwq.oss-cn-hangzhou.aliyuncs.com/SolvedProblems/colab-run-python-codes/image-20210331104255484.png)\n\n先给出**解决方法**：\n\n```python\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\t// 挂载谷歌云盘\nimport os\nos.chdir('/content/gdrive/MyDrive/Codes')\t// 设置工作路径\n```\n\n挂载的时候需要进行授权，输入授权码。这样就把colab和谷歌云盘链接起来了，下图的gdrive就是。PS：如果直接在colab这里上传文件有可能会丢失的。\n\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/SolvedProblems/colab-run-python-codes/image-20210331103818864.png\" alt=\"directories\" style=\"zoom:50%;\" />\n\n**os模块**\n\n官方文档：[os --- 多种操作系统接口 — Python 3.9.2 文档](https://docs.python.org/zh-cn/3/library/os.html)\n\n`os.chdir(path)`：修改当前工作目录为path\n\n`os.getcwd()`：返回当前工作目录的字符串\n\n`os.listdir(path='.')`：返回一个列表，包括path目录下的条目名称。\n\n\n\n","source":"_posts/Colab运行python代码找不到路径.md","raw":"---\ntitle: Colab运行python代码找不到路径\ndate: 2021-03-31 11:11:54\ntags: \n- Colab\n- Python\ncategories: 问题解决SolvedProblems\n---\n\n因为要修改工作路径！\n\n<!--more-->\n\n已经有两次碰到这个问题了。原因是我在谷歌云盘中新建了colab笔记本，同一目录下放了想要运行的代码，但是给我报错`No such file or directory`。但是colab文件的工作目录跟他文件放的位置没关系，如果要运行云盘中的文件，需要**挂载谷歌云盘**然后**修改工作路径**。\n\n![run-error](https://forlwq.oss-cn-hangzhou.aliyuncs.com/SolvedProblems/colab-run-python-codes/image-20210331104255484.png)\n\n先给出**解决方法**：\n\n```python\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\t// 挂载谷歌云盘\nimport os\nos.chdir('/content/gdrive/MyDrive/Codes')\t// 设置工作路径\n```\n\n挂载的时候需要进行授权，输入授权码。这样就把colab和谷歌云盘链接起来了，下图的gdrive就是。PS：如果直接在colab这里上传文件有可能会丢失的。\n\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/SolvedProblems/colab-run-python-codes/image-20210331103818864.png\" alt=\"directories\" style=\"zoom:50%;\" />\n\n**os模块**\n\n官方文档：[os --- 多种操作系统接口 — Python 3.9.2 文档](https://docs.python.org/zh-cn/3/library/os.html)\n\n`os.chdir(path)`：修改当前工作目录为path\n\n`os.getcwd()`：返回当前工作目录的字符串\n\n`os.listdir(path='.')`：返回一个列表，包括path目录下的条目名称。\n\n\n\n","slug":"Colab运行python代码找不到路径","published":1,"updated":"2021-03-31T03:11:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggn000i38t440891tb6","content":"<p>因为要修改工作路径！</p>\n<span id=\"more\"></span>\n\n<p>已经有两次碰到这个问题了。原因是我在谷歌云盘中新建了colab笔记本，同一目录下放了想要运行的代码，但是给我报错<code>No such file or directory</code>。但是colab文件的工作目录跟他文件放的位置没关系，如果要运行云盘中的文件，需要<strong>挂载谷歌云盘</strong>然后<strong>修改工作路径</strong>。</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/SolvedProblems/colab-run-python-codes/image-20210331104255484.png\" alt=\"run-error\"></p>\n<p>先给出<strong>解决方法</strong>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> google.colab <span class=\"keyword\">import</span> drive</span><br><span class=\"line\">drive.mount(<span class=\"string\">&#x27;/content/gdrive&#x27;</span>)\t// 挂载谷歌云盘</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\">os.chdir(<span class=\"string\">&#x27;/content/gdrive/MyDrive/Codes&#x27;</span>)\t// 设置工作路径</span><br></pre></td></tr></table></figure>\n\n<p>挂载的时候需要进行授权，输入授权码。这样就把colab和谷歌云盘链接起来了，下图的gdrive就是。PS：如果直接在colab这里上传文件有可能会丢失的。</p>\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/SolvedProblems/colab-run-python-codes/image-20210331103818864.png\" alt=\"directories\" style=\"zoom:50%;\" />\n\n<p><strong>os模块</strong></p>\n<p>官方文档：<a href=\"https://docs.python.org/zh-cn/3/library/os.html\">os — 多种操作系统接口 — Python 3.9.2 文档</a></p>\n<p><code>os.chdir(path)</code>：修改当前工作目录为path</p>\n<p><code>os.getcwd()</code>：返回当前工作目录的字符串</p>\n<p><code>os.listdir(path=&#39;.&#39;)</code>：返回一个列表，包括path目录下的条目名称。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>因为要修改工作路径！</p>","more":"<p>已经有两次碰到这个问题了。原因是我在谷歌云盘中新建了colab笔记本，同一目录下放了想要运行的代码，但是给我报错<code>No such file or directory</code>。但是colab文件的工作目录跟他文件放的位置没关系，如果要运行云盘中的文件，需要<strong>挂载谷歌云盘</strong>然后<strong>修改工作路径</strong>。</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/SolvedProblems/colab-run-python-codes/image-20210331104255484.png\" alt=\"run-error\"></p>\n<p>先给出<strong>解决方法</strong>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> google.colab <span class=\"keyword\">import</span> drive</span><br><span class=\"line\">drive.mount(<span class=\"string\">&#x27;/content/gdrive&#x27;</span>)\t// 挂载谷歌云盘</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\">os.chdir(<span class=\"string\">&#x27;/content/gdrive/MyDrive/Codes&#x27;</span>)\t// 设置工作路径</span><br></pre></td></tr></table></figure>\n\n<p>挂载的时候需要进行授权，输入授权码。这样就把colab和谷歌云盘链接起来了，下图的gdrive就是。PS：如果直接在colab这里上传文件有可能会丢失的。</p>\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/SolvedProblems/colab-run-python-codes/image-20210331103818864.png\" alt=\"directories\" style=\"zoom:50%;\" />\n\n<p><strong>os模块</strong></p>\n<p>官方文档：<a href=\"https://docs.python.org/zh-cn/3/library/os.html\">os — 多种操作系统接口 — Python 3.9.2 文档</a></p>\n<p><code>os.chdir(path)</code>：修改当前工作目录为path</p>\n<p><code>os.getcwd()</code>：返回当前工作目录的字符串</p>\n<p><code>os.listdir(path=&#39;.&#39;)</code>：返回一个列表，包括path目录下的条目名称。</p>"},{"title":"Deep Learning学习笔记-1","date":"2020-07-29T08:17:07.000Z","_content":"\n还没拿到学校的录取通知书，学校先开了暑期班的课程。选了深度学习和智能计算基础。先记个DL里PyTorch的操作。\n\n<!--more-->\n\n## PyTorch的基本操作使用\n\n在PyTorch中，基本的数据类型是Tensor（类似于Numpy中的Array）。Tensor除了存储和变换数据等基本功能外，还提供了GPU计算和自动求梯度等功能。\n\n### 创建Tensor\n\n1. torch.empty(): 创建一个未初始化的Tensor\n2. torch.rand()/torch.randn():创建一个随机数的Tensor。rand的随机数从均匀分布，randn的随机数从标准正态分布。\n3. torch.normal(mean,std)/torch.uniform(from, to):正态分布/均匀分布\n3. torch.ones():创建一个都是1的Tensor\n4. torch.zeros():创建一个都是0的Tensor\n5. torch.tensor():直接赋值创建\n6. torch.randn_like(tensor):创建size和其他类型都同tensor的Tensor\n7. tensor.new_ones():创建一个都是1的Tensor，并且数据类型和设备等都同tensor\n8. tensor.arange(s, e, step): s到e(不包括e)，步长为e\n9. tensor.linspace(s, e, steps):s到e（包括e），均匀分成e-1段\n```python\nb = torch.arange(1, 7, 2)\nc = torch.linspace(1, 7, 2)\nd = torch.linspace(1, 7, 4)\nprint(b)\nprint(c)\n\n# output\n# tensor([1, 3, 5])\n# tensor([1., 7.])\n# tensor([1., 3., 5., 7.])\n```\n\n###  算术操作\n\n三种方法：\n1. 直接使用运算符\n2. torch.add()函数\n3. Tensor.add_()函数\n\n```python\na = torch.ones(2,3)\nb = torch.ones(2,3)\nprint(a + b)\nprint(torch.add(a, b))\na.add_(b) # 类似于add_的操作，称为原地操作。原地操作的函数名都带个_\nprint(a)\n\n'''\noutput\ntensor([[2., 2., 2.],\n        [2., 2., 2.]])\ntensor([[2., 2., 2.],\n        [2., 2., 2.]])\ntensor([[2., 2., 2.],\n        [2., 2., 2.]])\n'''\n```\n\n### 选择Tensor的一部分\n\n#### 索引\n\nAttention: 索引提取的部分张量与原张量共享内存（即一个变了，另一个也变了）\n\n```python\nprint(x)\ny = x[0, :]\nprint(y)\ny += 1\nprint(x)\nx += 1 \nprint(y)\n\n'''\noutput\ntensor([[6, 6, 4],\n        [2, 2, 5]])\ntensor([6, 6, 4])\ntensor([[7, 7, 5],\n        [2, 2, 5]])\ntensor([8, 8, 6])\n'''\n```\n\n#### 选择函数\n\ntorch.index_select(input, dim, index)\nTensor.index_select(dim, index)\ninput：输入Tensor\ndim：选择维度，0为选择行，1为选择列\nindex：Tensor类型的行向量，表示选择的范围\n\ntorch.gather(input, dim, index)\nTensor.gather(input, dim, index)\n```python\ny = torch.tensor([[0.1205, 0.1205, 0.1205],\n                  [0.6966, 0.6966, 0.6966]])\nindex = torch.tensor([[0, 0, 0], \n                      [0, 0, 0]])\nz = y.gather(1, index)\nprint(z)\n\n'''\noutput\ntensor([[0.1205, 0.1205, 0.1205],\n        [0.6966, 0.6966, 0.6966]])\n'''\n```\n\n### 改变形状\n\nview()\n共享内存。（就跟它函数名一样，他只是给了你一个不同的视角来看数组而已。）\n\nreshape()\nview()函数只能对连续存储的tensor进行操作。reshape在能进行view()的时候，返回view（即共享内存）；在不能进行view()的时候（对tensor进行），即存储空间不连续（如，y=x.permute(*dims)），返回一个新的副本。\n因此reshape()不能保证得到的是一个副本。\n\n为了得到真正的新副本（不共享内存），如果连续存储则先进行clone再使用view，如果不连续就用reshape()。\n\n### 广播机制\n\n对形状不同的tensor按元素运算时，会触发广播机制(broadcasting)。\n\n```python\na = torch.arange(1, 3).view(1, 2)\nb = torch.arange(2, 5).view(3, 1)\n\nprint(a)\nprint(b)\nprint(a+b)\n\n'''\noutput\ntensor([[1, 2]])\ntensor([[2],\n        [3],\n        [4]])\ntensor([[3, 4],\n        [4, 5],\n        [5, 6]])\n'''\n```\n\n### array与tensor的相互转换\n\n#### array->tensor\n\ntorch.from_numpy(array) （PS. 共享内存）\n\ntorch.tensor(array) （PS. 数据拷贝，不共享内存）\n\n#### tansor->array\n\nTensor.numpy() （PS. 共享内存）\n\n### 转移数据位置\n\n```python\nif torch.cuda.is_available():\n    device = torch.device(\"cuda\")\n    tensor.to(device)\n\n```\n\n\n## 其他\n\n> ```x = x + 1```与```x += 1```的区别\n\n在学习view()共享内存的时候发现。\n前者其实是创建了一个新的对象x，并进行赋值。而后者是在原先的x上进行+1操作。","source":"_posts/Deep-Learning学习笔记.md","raw":"---\ntitle: Deep Learning学习笔记-1\ndate: 2020-07-29 16:17:07\ncategories: 学习Learning\n---\n\n还没拿到学校的录取通知书，学校先开了暑期班的课程。选了深度学习和智能计算基础。先记个DL里PyTorch的操作。\n\n<!--more-->\n\n## PyTorch的基本操作使用\n\n在PyTorch中，基本的数据类型是Tensor（类似于Numpy中的Array）。Tensor除了存储和变换数据等基本功能外，还提供了GPU计算和自动求梯度等功能。\n\n### 创建Tensor\n\n1. torch.empty(): 创建一个未初始化的Tensor\n2. torch.rand()/torch.randn():创建一个随机数的Tensor。rand的随机数从均匀分布，randn的随机数从标准正态分布。\n3. torch.normal(mean,std)/torch.uniform(from, to):正态分布/均匀分布\n3. torch.ones():创建一个都是1的Tensor\n4. torch.zeros():创建一个都是0的Tensor\n5. torch.tensor():直接赋值创建\n6. torch.randn_like(tensor):创建size和其他类型都同tensor的Tensor\n7. tensor.new_ones():创建一个都是1的Tensor，并且数据类型和设备等都同tensor\n8. tensor.arange(s, e, step): s到e(不包括e)，步长为e\n9. tensor.linspace(s, e, steps):s到e（包括e），均匀分成e-1段\n```python\nb = torch.arange(1, 7, 2)\nc = torch.linspace(1, 7, 2)\nd = torch.linspace(1, 7, 4)\nprint(b)\nprint(c)\n\n# output\n# tensor([1, 3, 5])\n# tensor([1., 7.])\n# tensor([1., 3., 5., 7.])\n```\n\n###  算术操作\n\n三种方法：\n1. 直接使用运算符\n2. torch.add()函数\n3. Tensor.add_()函数\n\n```python\na = torch.ones(2,3)\nb = torch.ones(2,3)\nprint(a + b)\nprint(torch.add(a, b))\na.add_(b) # 类似于add_的操作，称为原地操作。原地操作的函数名都带个_\nprint(a)\n\n'''\noutput\ntensor([[2., 2., 2.],\n        [2., 2., 2.]])\ntensor([[2., 2., 2.],\n        [2., 2., 2.]])\ntensor([[2., 2., 2.],\n        [2., 2., 2.]])\n'''\n```\n\n### 选择Tensor的一部分\n\n#### 索引\n\nAttention: 索引提取的部分张量与原张量共享内存（即一个变了，另一个也变了）\n\n```python\nprint(x)\ny = x[0, :]\nprint(y)\ny += 1\nprint(x)\nx += 1 \nprint(y)\n\n'''\noutput\ntensor([[6, 6, 4],\n        [2, 2, 5]])\ntensor([6, 6, 4])\ntensor([[7, 7, 5],\n        [2, 2, 5]])\ntensor([8, 8, 6])\n'''\n```\n\n#### 选择函数\n\ntorch.index_select(input, dim, index)\nTensor.index_select(dim, index)\ninput：输入Tensor\ndim：选择维度，0为选择行，1为选择列\nindex：Tensor类型的行向量，表示选择的范围\n\ntorch.gather(input, dim, index)\nTensor.gather(input, dim, index)\n```python\ny = torch.tensor([[0.1205, 0.1205, 0.1205],\n                  [0.6966, 0.6966, 0.6966]])\nindex = torch.tensor([[0, 0, 0], \n                      [0, 0, 0]])\nz = y.gather(1, index)\nprint(z)\n\n'''\noutput\ntensor([[0.1205, 0.1205, 0.1205],\n        [0.6966, 0.6966, 0.6966]])\n'''\n```\n\n### 改变形状\n\nview()\n共享内存。（就跟它函数名一样，他只是给了你一个不同的视角来看数组而已。）\n\nreshape()\nview()函数只能对连续存储的tensor进行操作。reshape在能进行view()的时候，返回view（即共享内存）；在不能进行view()的时候（对tensor进行），即存储空间不连续（如，y=x.permute(*dims)），返回一个新的副本。\n因此reshape()不能保证得到的是一个副本。\n\n为了得到真正的新副本（不共享内存），如果连续存储则先进行clone再使用view，如果不连续就用reshape()。\n\n### 广播机制\n\n对形状不同的tensor按元素运算时，会触发广播机制(broadcasting)。\n\n```python\na = torch.arange(1, 3).view(1, 2)\nb = torch.arange(2, 5).view(3, 1)\n\nprint(a)\nprint(b)\nprint(a+b)\n\n'''\noutput\ntensor([[1, 2]])\ntensor([[2],\n        [3],\n        [4]])\ntensor([[3, 4],\n        [4, 5],\n        [5, 6]])\n'''\n```\n\n### array与tensor的相互转换\n\n#### array->tensor\n\ntorch.from_numpy(array) （PS. 共享内存）\n\ntorch.tensor(array) （PS. 数据拷贝，不共享内存）\n\n#### tansor->array\n\nTensor.numpy() （PS. 共享内存）\n\n### 转移数据位置\n\n```python\nif torch.cuda.is_available():\n    device = torch.device(\"cuda\")\n    tensor.to(device)\n\n```\n\n\n## 其他\n\n> ```x = x + 1```与```x += 1```的区别\n\n在学习view()共享内存的时候发现。\n前者其实是创建了一个新的对象x，并进行赋值。而后者是在原先的x上进行+1操作。","slug":"Deep-Learning学习笔记","published":1,"updated":"2020-07-29T08:17:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggn000j38t4578k7aie","content":"<p>还没拿到学校的录取通知书，学校先开了暑期班的课程。选了深度学习和智能计算基础。先记个DL里PyTorch的操作。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"PyTorch的基本操作使用\"><a href=\"#PyTorch的基本操作使用\" class=\"headerlink\" title=\"PyTorch的基本操作使用\"></a>PyTorch的基本操作使用</h2><p>在PyTorch中，基本的数据类型是Tensor（类似于Numpy中的Array）。Tensor除了存储和变换数据等基本功能外，还提供了GPU计算和自动求梯度等功能。</p>\n<h3 id=\"创建Tensor\"><a href=\"#创建Tensor\" class=\"headerlink\" title=\"创建Tensor\"></a>创建Tensor</h3><ol>\n<li>torch.empty(): 创建一个未初始化的Tensor</li>\n<li>torch.rand()/torch.randn():创建一个随机数的Tensor。rand的随机数从均匀分布，randn的随机数从标准正态分布。</li>\n<li>torch.normal(mean,std)/torch.uniform(from, to):正态分布/均匀分布</li>\n<li>torch.ones():创建一个都是1的Tensor</li>\n<li>torch.zeros():创建一个都是0的Tensor</li>\n<li>torch.tensor():直接赋值创建</li>\n<li>torch.randn_like(tensor):创建size和其他类型都同tensor的Tensor</li>\n<li>tensor.new_ones():创建一个都是1的Tensor，并且数据类型和设备等都同tensor</li>\n<li>tensor.arange(s, e, step): s到e(不包括e)，步长为e</li>\n<li>tensor.linspace(s, e, steps):s到e（包括e），均匀分成e-1段<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = torch.arange(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">c = torch.linspace(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">d = torch.linspace(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># output</span></span><br><span class=\"line\"><span class=\"comment\"># tensor([1, 3, 5])</span></span><br><span class=\"line\"><span class=\"comment\"># tensor([1., 7.])</span></span><br><span class=\"line\"><span class=\"comment\"># tensor([1., 3., 5., 7.])</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"算术操作\"><a href=\"#算术操作\" class=\"headerlink\" title=\"算术操作\"></a>算术操作</h3><p>三种方法：</p>\n<ol>\n<li>直接使用运算符</li>\n<li>torch.add()函数</li>\n<li>Tensor.add_()函数</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = torch.ones(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">b = torch.ones(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a + b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(torch.add(a, b))</span><br><span class=\"line\">a.add_(b) <span class=\"comment\"># 类似于add_的操作，称为原地操作。原地操作的函数名都带个_</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">output</span></span><br><span class=\"line\"><span class=\"string\">tensor([[2., 2., 2.],</span></span><br><span class=\"line\"><span class=\"string\">        [2., 2., 2.]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([[2., 2., 2.],</span></span><br><span class=\"line\"><span class=\"string\">        [2., 2., 2.]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([[2., 2., 2.],</span></span><br><span class=\"line\"><span class=\"string\">        [2., 2., 2.]])</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择Tensor的一部分\"><a href=\"#选择Tensor的一部分\" class=\"headerlink\" title=\"选择Tensor的一部分\"></a>选择Tensor的一部分</h3><h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><p>Attention: 索引提取的部分张量与原张量共享内存（即一个变了，另一个也变了）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\">y = x[<span class=\"number\">0</span>, :]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\">y += <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\">x += <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">output</span></span><br><span class=\"line\"><span class=\"string\">tensor([[6, 6, 4],</span></span><br><span class=\"line\"><span class=\"string\">        [2, 2, 5]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([6, 6, 4])</span></span><br><span class=\"line\"><span class=\"string\">tensor([[7, 7, 5],</span></span><br><span class=\"line\"><span class=\"string\">        [2, 2, 5]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([8, 8, 6])</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"选择函数\"><a href=\"#选择函数\" class=\"headerlink\" title=\"选择函数\"></a>选择函数</h4><p>torch.index_select(input, dim, index)<br>Tensor.index_select(dim, index)<br>input：输入Tensor<br>dim：选择维度，0为选择行，1为选择列<br>index：Tensor类型的行向量，表示选择的范围</p>\n<p>torch.gather(input, dim, index)<br>Tensor.gather(input, dim, index)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = torch.tensor([[<span class=\"number\">0.1205</span>, <span class=\"number\">0.1205</span>, <span class=\"number\">0.1205</span>],</span><br><span class=\"line\">                  [<span class=\"number\">0.6966</span>, <span class=\"number\">0.6966</span>, <span class=\"number\">0.6966</span>]])</span><br><span class=\"line\">index = torch.tensor([[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>], </span><br><span class=\"line\">                      [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]])</span><br><span class=\"line\">z = y.gather(<span class=\"number\">1</span>, index)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(z)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">output</span></span><br><span class=\"line\"><span class=\"string\">tensor([[0.1205, 0.1205, 0.1205],</span></span><br><span class=\"line\"><span class=\"string\">        [0.6966, 0.6966, 0.6966]])</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"改变形状\"><a href=\"#改变形状\" class=\"headerlink\" title=\"改变形状\"></a>改变形状</h3><p>view()<br>共享内存。（就跟它函数名一样，他只是给了你一个不同的视角来看数组而已。）</p>\n<p>reshape()<br>view()函数只能对连续存储的tensor进行操作。reshape在能进行view()的时候，返回view（即共享内存）；在不能进行view()的时候（对tensor进行），即存储空间不连续（如，y=x.permute(*dims)），返回一个新的副本。<br>因此reshape()不能保证得到的是一个副本。</p>\n<p>为了得到真正的新副本（不共享内存），如果连续存储则先进行clone再使用view，如果不连续就用reshape()。</p>\n<h3 id=\"广播机制\"><a href=\"#广播机制\" class=\"headerlink\" title=\"广播机制\"></a>广播机制</h3><p>对形状不同的tensor按元素运算时，会触发广播机制(broadcasting)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = torch.arange(<span class=\"number\">1</span>, <span class=\"number\">3</span>).view(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">b = torch.arange(<span class=\"number\">2</span>, <span class=\"number\">5</span>).view(<span class=\"number\">3</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a+b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">output</span></span><br><span class=\"line\"><span class=\"string\">tensor([[1, 2]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([[2],</span></span><br><span class=\"line\"><span class=\"string\">        [3],</span></span><br><span class=\"line\"><span class=\"string\">        [4]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([[3, 4],</span></span><br><span class=\"line\"><span class=\"string\">        [4, 5],</span></span><br><span class=\"line\"><span class=\"string\">        [5, 6]])</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"array与tensor的相互转换\"><a href=\"#array与tensor的相互转换\" class=\"headerlink\" title=\"array与tensor的相互转换\"></a>array与tensor的相互转换</h3><h4 id=\"array-gt-tensor\"><a href=\"#array-gt-tensor\" class=\"headerlink\" title=\"array-&gt;tensor\"></a>array-&gt;tensor</h4><p>torch.from_numpy(array) （PS. 共享内存）</p>\n<p>torch.tensor(array) （PS. 数据拷贝，不共享内存）</p>\n<h4 id=\"tansor-gt-array\"><a href=\"#tansor-gt-array\" class=\"headerlink\" title=\"tansor-&gt;array\"></a>tansor-&gt;array</h4><p>Tensor.numpy() （PS. 共享内存）</p>\n<h3 id=\"转移数据位置\"><a href=\"#转移数据位置\" class=\"headerlink\" title=\"转移数据位置\"></a>转移数据位置</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> torch.cuda.is_available():</span><br><span class=\"line\">    device = torch.device(<span class=\"string\">&quot;cuda&quot;</span>)</span><br><span class=\"line\">    tensor.to(device)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><blockquote>\n<p><code>x = x + 1</code>与<code>x += 1</code>的区别</p>\n</blockquote>\n<p>在学习view()共享内存的时候发现。<br>前者其实是创建了一个新的对象x，并进行赋值。而后者是在原先的x上进行+1操作。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>还没拿到学校的录取通知书，学校先开了暑期班的课程。选了深度学习和智能计算基础。先记个DL里PyTorch的操作。</p>","more":"<h2 id=\"PyTorch的基本操作使用\"><a href=\"#PyTorch的基本操作使用\" class=\"headerlink\" title=\"PyTorch的基本操作使用\"></a>PyTorch的基本操作使用</h2><p>在PyTorch中，基本的数据类型是Tensor（类似于Numpy中的Array）。Tensor除了存储和变换数据等基本功能外，还提供了GPU计算和自动求梯度等功能。</p>\n<h3 id=\"创建Tensor\"><a href=\"#创建Tensor\" class=\"headerlink\" title=\"创建Tensor\"></a>创建Tensor</h3><ol>\n<li>torch.empty(): 创建一个未初始化的Tensor</li>\n<li>torch.rand()/torch.randn():创建一个随机数的Tensor。rand的随机数从均匀分布，randn的随机数从标准正态分布。</li>\n<li>torch.normal(mean,std)/torch.uniform(from, to):正态分布/均匀分布</li>\n<li>torch.ones():创建一个都是1的Tensor</li>\n<li>torch.zeros():创建一个都是0的Tensor</li>\n<li>torch.tensor():直接赋值创建</li>\n<li>torch.randn_like(tensor):创建size和其他类型都同tensor的Tensor</li>\n<li>tensor.new_ones():创建一个都是1的Tensor，并且数据类型和设备等都同tensor</li>\n<li>tensor.arange(s, e, step): s到e(不包括e)，步长为e</li>\n<li>tensor.linspace(s, e, steps):s到e（包括e），均匀分成e-1段<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = torch.arange(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">c = torch.linspace(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">d = torch.linspace(<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># output</span></span><br><span class=\"line\"><span class=\"comment\"># tensor([1, 3, 5])</span></span><br><span class=\"line\"><span class=\"comment\"># tensor([1., 7.])</span></span><br><span class=\"line\"><span class=\"comment\"># tensor([1., 3., 5., 7.])</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"算术操作\"><a href=\"#算术操作\" class=\"headerlink\" title=\"算术操作\"></a>算术操作</h3><p>三种方法：</p>\n<ol>\n<li>直接使用运算符</li>\n<li>torch.add()函数</li>\n<li>Tensor.add_()函数</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = torch.ones(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">b = torch.ones(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a + b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(torch.add(a, b))</span><br><span class=\"line\">a.add_(b) <span class=\"comment\"># 类似于add_的操作，称为原地操作。原地操作的函数名都带个_</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">output</span></span><br><span class=\"line\"><span class=\"string\">tensor([[2., 2., 2.],</span></span><br><span class=\"line\"><span class=\"string\">        [2., 2., 2.]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([[2., 2., 2.],</span></span><br><span class=\"line\"><span class=\"string\">        [2., 2., 2.]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([[2., 2., 2.],</span></span><br><span class=\"line\"><span class=\"string\">        [2., 2., 2.]])</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择Tensor的一部分\"><a href=\"#选择Tensor的一部分\" class=\"headerlink\" title=\"选择Tensor的一部分\"></a>选择Tensor的一部分</h3><h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><p>Attention: 索引提取的部分张量与原张量共享内存（即一个变了，另一个也变了）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\">y = x[<span class=\"number\">0</span>, :]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\">y += <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\">x += <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">output</span></span><br><span class=\"line\"><span class=\"string\">tensor([[6, 6, 4],</span></span><br><span class=\"line\"><span class=\"string\">        [2, 2, 5]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([6, 6, 4])</span></span><br><span class=\"line\"><span class=\"string\">tensor([[7, 7, 5],</span></span><br><span class=\"line\"><span class=\"string\">        [2, 2, 5]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([8, 8, 6])</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"选择函数\"><a href=\"#选择函数\" class=\"headerlink\" title=\"选择函数\"></a>选择函数</h4><p>torch.index_select(input, dim, index)<br>Tensor.index_select(dim, index)<br>input：输入Tensor<br>dim：选择维度，0为选择行，1为选择列<br>index：Tensor类型的行向量，表示选择的范围</p>\n<p>torch.gather(input, dim, index)<br>Tensor.gather(input, dim, index)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = torch.tensor([[<span class=\"number\">0.1205</span>, <span class=\"number\">0.1205</span>, <span class=\"number\">0.1205</span>],</span><br><span class=\"line\">                  [<span class=\"number\">0.6966</span>, <span class=\"number\">0.6966</span>, <span class=\"number\">0.6966</span>]])</span><br><span class=\"line\">index = torch.tensor([[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>], </span><br><span class=\"line\">                      [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]])</span><br><span class=\"line\">z = y.gather(<span class=\"number\">1</span>, index)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(z)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">output</span></span><br><span class=\"line\"><span class=\"string\">tensor([[0.1205, 0.1205, 0.1205],</span></span><br><span class=\"line\"><span class=\"string\">        [0.6966, 0.6966, 0.6966]])</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"改变形状\"><a href=\"#改变形状\" class=\"headerlink\" title=\"改变形状\"></a>改变形状</h3><p>view()<br>共享内存。（就跟它函数名一样，他只是给了你一个不同的视角来看数组而已。）</p>\n<p>reshape()<br>view()函数只能对连续存储的tensor进行操作。reshape在能进行view()的时候，返回view（即共享内存）；在不能进行view()的时候（对tensor进行），即存储空间不连续（如，y=x.permute(*dims)），返回一个新的副本。<br>因此reshape()不能保证得到的是一个副本。</p>\n<p>为了得到真正的新副本（不共享内存），如果连续存储则先进行clone再使用view，如果不连续就用reshape()。</p>\n<h3 id=\"广播机制\"><a href=\"#广播机制\" class=\"headerlink\" title=\"广播机制\"></a>广播机制</h3><p>对形状不同的tensor按元素运算时，会触发广播机制(broadcasting)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = torch.arange(<span class=\"number\">1</span>, <span class=\"number\">3</span>).view(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">b = torch.arange(<span class=\"number\">2</span>, <span class=\"number\">5</span>).view(<span class=\"number\">3</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a+b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">output</span></span><br><span class=\"line\"><span class=\"string\">tensor([[1, 2]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([[2],</span></span><br><span class=\"line\"><span class=\"string\">        [3],</span></span><br><span class=\"line\"><span class=\"string\">        [4]])</span></span><br><span class=\"line\"><span class=\"string\">tensor([[3, 4],</span></span><br><span class=\"line\"><span class=\"string\">        [4, 5],</span></span><br><span class=\"line\"><span class=\"string\">        [5, 6]])</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"array与tensor的相互转换\"><a href=\"#array与tensor的相互转换\" class=\"headerlink\" title=\"array与tensor的相互转换\"></a>array与tensor的相互转换</h3><h4 id=\"array-gt-tensor\"><a href=\"#array-gt-tensor\" class=\"headerlink\" title=\"array-&gt;tensor\"></a>array-&gt;tensor</h4><p>torch.from_numpy(array) （PS. 共享内存）</p>\n<p>torch.tensor(array) （PS. 数据拷贝，不共享内存）</p>\n<h4 id=\"tansor-gt-array\"><a href=\"#tansor-gt-array\" class=\"headerlink\" title=\"tansor-&gt;array\"></a>tansor-&gt;array</h4><p>Tensor.numpy() （PS. 共享内存）</p>\n<h3 id=\"转移数据位置\"><a href=\"#转移数据位置\" class=\"headerlink\" title=\"转移数据位置\"></a>转移数据位置</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> torch.cuda.is_available():</span><br><span class=\"line\">    device = torch.device(<span class=\"string\">&quot;cuda&quot;</span>)</span><br><span class=\"line\">    tensor.to(device)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><blockquote>\n<p><code>x = x + 1</code>与<code>x += 1</code>的区别</p>\n</blockquote>\n<p>在学习view()共享内存的时候发现。<br>前者其实是创建了一个新的对象x，并进行赋值。而后者是在原先的x上进行+1操作。</p>"},{"title":"Java核心技术卷1笔记-1","date":"2021-11-30T13:57:26.000Z","_content":"\nJava核心技术卷1笔记\n\n<!--more-->\n\n# String\n\n- String变量既可以存放空串，也可以存放null。区分两者，空串是一个对象，有长度（0）和内容（空）。检查时，先检查是否为空，再检查长度是否为0.\n\n## String的长度\n\nString的长度涉及到码点与码元。以下对比几种方法：\n\n- String.length()与String.codePointCount()：str.length()返回字符串str的码元数量，str.codePointCount(0, str.length())返回字符串str的码字数量。\n- String.charAt()与String.codePointAt()：str.charAt(n)返回字符串str的码元；获取码字需要和String.offsetByCodePoints()配合使用，`int index = str.offsetByCodePoints(n); int cp = str.codePointAt(index)`，注意是返回int。\n\n之所以会有区别，是因为辅助字符是有两个码元的。\n\n遍历字符串码元的方法：codePoints()；判断一个码点是否为辅助字符：isSupplementaryCodePoint(int codePoint)；判断一个码元是否对应辅助字符的码元：isSurrogate(char)\n\n## 输入输出\n\n输入Scanner不多说，在输密码需要不显示的时候可以用console.readPassword()\n\n### 格式化输出printf\n\n**输出数字**\n\n`%8.2f`：8表示宽度，.2表示小数，f是转换符\n\n在%之后可以加入标志（控制输出格式，如对齐方式、分组分隔符等）\n\n`%,+.2f`：,表示分组（如1000写作1,000），+表示输出正负号\n\n**输出日期**\n\n以t开头，后跟转换符\n\n`%tc`：输出完整的时间如`周二 11月 30 20:48:29 CST 2021`\n\n可以对同一个Date对象操作，输出时需要指出被格式化的参数索引，有两种写法。<是一种标志，表示格式化前一个的数值。\n\n```java\nSystem.out.printf(\"%tB %<te, %<tY\", new Date());\nSystem.out.printf(\"%1$tB %1$te, %1$tY\", new Date());\n```\n\nPS：输出日期有java.text.SimpleDateFormat，可以方便表示。[java 日期格式化-- SimpleDateFormat 的使用](https://blog.csdn.net/qq_27093465/article/details/53034427)\n\n### 文件输入输出\n\n```java\nScanner scanner = new Scanner(Paths.get(\"input.txt\"), StandardCharsets.UTF_8);\nPrintWriter printWriter = new PrintWriter(\"output.txt\", StandardCharsets.UTF_8);\n```\n\n# 数组\n\n- 直接new一个数组：数字数组初始化为0，boolean数组初始化为false，对象数组初始化为null。\n\n- 数组创建后不能改变大小，ArrayList可以改变大小。\n\n**数组初始化**方法：\n\n```java\nint[] a = new int[] {1,2,3};\t// new int[] {1,2,3}是匿名数组\n\nint[] b = {1, 2, 3};\n\nint[] c = new int[3];\nfor(int i=0;i<3;i++)\n    c[i] = i+1;\n```\n\n**数组拷贝**\n\n记住，数组是引用类型，除了基本数据类型（整型，浮点型，布尔型，字符型）都是引用类型\n\n```java\nint[] a = new int[] {1,2,3};\nint[] b = a;\t// b和a指向同一个数组\nb[0]=5;\t\t\t// 此时a[0]也为5\n```\n\n如果要复制到一个新数组应该是这样：\n\n```java\nint[] a = new int[] {1,2,3};\nint[] b = Array.copyOf(a, a.length);\n//可以用来增加数组长度\na = Array.copyOf(a, a.length*2);\t//多余的地方填0\n//Array.copyOfRange(a, 0, a.length*2);\n```\n\n**数组排序**：Array.sort(a);\n\n**二维数组（多维数组）**\n\n- Java中的二维数组，如`a[10][10]`，a是包含10个元素的数组，而其中每个元素又是包含10个元素的数组。我认为正是这个特性，使得Java可以定义不规则的二维数组，即`a[10][]`，其中每一行上的数组大小可以不同。C++中也有这种定义方式，不过会自动补全为0.\n\n```java\nint[][] a = new int[10][];\nfor(int i=0;i<10;i++)\n    a[i] = new int[i+1];\nSystem.out.println(a[0][0]);\t// 输出a[0][1]就会报数组越界的错误\n```\n\n\n\n# 其他\n\n## 大数值\n\nBigInteger和BigDecimal可以处理任意精读的运算。但是不能用+*符号，只能用类的静态方法来实现。\n\n转换方法：`BigInteger big = BigInteger.valueOf(2);`\n\n\n\n## 关于编码、码元、码字等：\n\n一个有效的 Unicode 字符的二进制代码值被称作一个码点，也就是一个字符意味着一个码点。\n\n[**Unicode_and_Character_Sets**](https://github.com/acmerfight/insight_python/blob/master/Unicode_and_Character_Sets.md)\n\n[**java——char类型、码点和代码单元详解**](https://blog.csdn.net/so_geili/article/details/105477780)\n\n","source":"_posts/Java核心技术卷1笔记-1.md","raw":"---\ntitle: Java核心技术卷1笔记-1\ndate: 2021-11-30 21:57:26\ncategories: Java\n---\n\nJava核心技术卷1笔记\n\n<!--more-->\n\n# String\n\n- String变量既可以存放空串，也可以存放null。区分两者，空串是一个对象，有长度（0）和内容（空）。检查时，先检查是否为空，再检查长度是否为0.\n\n## String的长度\n\nString的长度涉及到码点与码元。以下对比几种方法：\n\n- String.length()与String.codePointCount()：str.length()返回字符串str的码元数量，str.codePointCount(0, str.length())返回字符串str的码字数量。\n- String.charAt()与String.codePointAt()：str.charAt(n)返回字符串str的码元；获取码字需要和String.offsetByCodePoints()配合使用，`int index = str.offsetByCodePoints(n); int cp = str.codePointAt(index)`，注意是返回int。\n\n之所以会有区别，是因为辅助字符是有两个码元的。\n\n遍历字符串码元的方法：codePoints()；判断一个码点是否为辅助字符：isSupplementaryCodePoint(int codePoint)；判断一个码元是否对应辅助字符的码元：isSurrogate(char)\n\n## 输入输出\n\n输入Scanner不多说，在输密码需要不显示的时候可以用console.readPassword()\n\n### 格式化输出printf\n\n**输出数字**\n\n`%8.2f`：8表示宽度，.2表示小数，f是转换符\n\n在%之后可以加入标志（控制输出格式，如对齐方式、分组分隔符等）\n\n`%,+.2f`：,表示分组（如1000写作1,000），+表示输出正负号\n\n**输出日期**\n\n以t开头，后跟转换符\n\n`%tc`：输出完整的时间如`周二 11月 30 20:48:29 CST 2021`\n\n可以对同一个Date对象操作，输出时需要指出被格式化的参数索引，有两种写法。<是一种标志，表示格式化前一个的数值。\n\n```java\nSystem.out.printf(\"%tB %<te, %<tY\", new Date());\nSystem.out.printf(\"%1$tB %1$te, %1$tY\", new Date());\n```\n\nPS：输出日期有java.text.SimpleDateFormat，可以方便表示。[java 日期格式化-- SimpleDateFormat 的使用](https://blog.csdn.net/qq_27093465/article/details/53034427)\n\n### 文件输入输出\n\n```java\nScanner scanner = new Scanner(Paths.get(\"input.txt\"), StandardCharsets.UTF_8);\nPrintWriter printWriter = new PrintWriter(\"output.txt\", StandardCharsets.UTF_8);\n```\n\n# 数组\n\n- 直接new一个数组：数字数组初始化为0，boolean数组初始化为false，对象数组初始化为null。\n\n- 数组创建后不能改变大小，ArrayList可以改变大小。\n\n**数组初始化**方法：\n\n```java\nint[] a = new int[] {1,2,3};\t// new int[] {1,2,3}是匿名数组\n\nint[] b = {1, 2, 3};\n\nint[] c = new int[3];\nfor(int i=0;i<3;i++)\n    c[i] = i+1;\n```\n\n**数组拷贝**\n\n记住，数组是引用类型，除了基本数据类型（整型，浮点型，布尔型，字符型）都是引用类型\n\n```java\nint[] a = new int[] {1,2,3};\nint[] b = a;\t// b和a指向同一个数组\nb[0]=5;\t\t\t// 此时a[0]也为5\n```\n\n如果要复制到一个新数组应该是这样：\n\n```java\nint[] a = new int[] {1,2,3};\nint[] b = Array.copyOf(a, a.length);\n//可以用来增加数组长度\na = Array.copyOf(a, a.length*2);\t//多余的地方填0\n//Array.copyOfRange(a, 0, a.length*2);\n```\n\n**数组排序**：Array.sort(a);\n\n**二维数组（多维数组）**\n\n- Java中的二维数组，如`a[10][10]`，a是包含10个元素的数组，而其中每个元素又是包含10个元素的数组。我认为正是这个特性，使得Java可以定义不规则的二维数组，即`a[10][]`，其中每一行上的数组大小可以不同。C++中也有这种定义方式，不过会自动补全为0.\n\n```java\nint[][] a = new int[10][];\nfor(int i=0;i<10;i++)\n    a[i] = new int[i+1];\nSystem.out.println(a[0][0]);\t// 输出a[0][1]就会报数组越界的错误\n```\n\n\n\n# 其他\n\n## 大数值\n\nBigInteger和BigDecimal可以处理任意精读的运算。但是不能用+*符号，只能用类的静态方法来实现。\n\n转换方法：`BigInteger big = BigInteger.valueOf(2);`\n\n\n\n## 关于编码、码元、码字等：\n\n一个有效的 Unicode 字符的二进制代码值被称作一个码点，也就是一个字符意味着一个码点。\n\n[**Unicode_and_Character_Sets**](https://github.com/acmerfight/insight_python/blob/master/Unicode_and_Character_Sets.md)\n\n[**java——char类型、码点和代码单元详解**](https://blog.csdn.net/so_geili/article/details/105477780)\n\n","slug":"Java核心技术卷1笔记-1","published":1,"updated":"2021-11-30T13:57:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggp000m38t49n155h63","content":"<p>Java核心技术卷1笔记</p>\n<span id=\"more\"></span>\n\n<h1 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h1><ul>\n<li>String变量既可以存放空串，也可以存放null。区分两者，空串是一个对象，有长度（0）和内容（空）。检查时，先检查是否为空，再检查长度是否为0.</li>\n</ul>\n<h2 id=\"String的长度\"><a href=\"#String的长度\" class=\"headerlink\" title=\"String的长度\"></a>String的长度</h2><p>String的长度涉及到码点与码元。以下对比几种方法：</p>\n<ul>\n<li>String.length()与String.codePointCount()：str.length()返回字符串str的码元数量，str.codePointCount(0, str.length())返回字符串str的码字数量。</li>\n<li>String.charAt()与String.codePointAt()：str.charAt(n)返回字符串str的码元；获取码字需要和String.offsetByCodePoints()配合使用，<code>int index = str.offsetByCodePoints(n); int cp = str.codePointAt(index)</code>，注意是返回int。</li>\n</ul>\n<p>之所以会有区别，是因为辅助字符是有两个码元的。</p>\n<p>遍历字符串码元的方法：codePoints()；判断一个码点是否为辅助字符：isSupplementaryCodePoint(int codePoint)；判断一个码元是否对应辅助字符的码元：isSurrogate(char)</p>\n<h2 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h2><p>输入Scanner不多说，在输密码需要不显示的时候可以用console.readPassword()</p>\n<h3 id=\"格式化输出printf\"><a href=\"#格式化输出printf\" class=\"headerlink\" title=\"格式化输出printf\"></a>格式化输出printf</h3><p><strong>输出数字</strong></p>\n<p><code>%8.2f</code>：8表示宽度，.2表示小数，f是转换符</p>\n<p>在%之后可以加入标志（控制输出格式，如对齐方式、分组分隔符等）</p>\n<p><code>%,+.2f</code>：,表示分组（如1000写作1,000），+表示输出正负号</p>\n<p><strong>输出日期</strong></p>\n<p>以t开头，后跟转换符</p>\n<p><code>%tc</code>：输出完整的时间如<code>周二 11月 30 20:48:29 CST 2021</code></p>\n<p>可以对同一个Date对象操作，输出时需要指出被格式化的参数索引，有两种写法。&lt;是一种标志，表示格式化前一个的数值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.printf(<span class=\"string\">&quot;%tB %&lt;te, %&lt;tY&quot;</span>, <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">System.out.printf(<span class=\"string\">&quot;%1$tB %1$te, %1$tY&quot;</span>, <span class=\"keyword\">new</span> Date());</span><br></pre></td></tr></table></figure>\n\n<p>PS：输出日期有java.text.SimpleDateFormat，可以方便表示。<a href=\"https://blog.csdn.net/qq_27093465/article/details/53034427\">java 日期格式化– SimpleDateFormat 的使用</a></p>\n<h3 id=\"文件输入输出\"><a href=\"#文件输入输出\" class=\"headerlink\" title=\"文件输入输出\"></a>文件输入输出</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner scanner = <span class=\"keyword\">new</span> Scanner(Paths.get(<span class=\"string\">&quot;input.txt&quot;</span>), StandardCharsets.UTF_8);</span><br><span class=\"line\">PrintWriter printWriter = <span class=\"keyword\">new</span> PrintWriter(<span class=\"string\">&quot;output.txt&quot;</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><ul>\n<li><p>直接new一个数组：数字数组初始化为0，boolean数组初始化为false，对象数组初始化为null。</p>\n</li>\n<li><p>数组创建后不能改变大小，ArrayList可以改变大小。</p>\n</li>\n</ul>\n<p><strong>数组初始化</strong>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;\t<span class=\"comment\">// new int[] &#123;1,2,3&#125;是匿名数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] b = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] c = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)</span><br><span class=\"line\">    c[i] = i+<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>数组拷贝</strong></p>\n<p>记住，数组是引用类型，除了基本数据类型（整型，浮点型，布尔型，字符型）都是引用类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] b = a;\t<span class=\"comment\">// b和a指向同一个数组</span></span><br><span class=\"line\">b[<span class=\"number\">0</span>]=<span class=\"number\">5</span>;\t\t\t<span class=\"comment\">// 此时a[0]也为5</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要复制到一个新数组应该是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] b = Array.copyOf(a, a.length);</span><br><span class=\"line\"><span class=\"comment\">//可以用来增加数组长度</span></span><br><span class=\"line\">a = Array.copyOf(a, a.length*<span class=\"number\">2</span>);\t<span class=\"comment\">//多余的地方填0</span></span><br><span class=\"line\"><span class=\"comment\">//Array.copyOfRange(a, 0, a.length*2);</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>数组排序</strong>：Array.sort(a);</p>\n<p><strong>二维数组（多维数组）</strong></p>\n<ul>\n<li>Java中的二维数组，如<code>a[10][10]</code>，a是包含10个元素的数组，而其中每个元素又是包含10个元素的数组。我认为正是这个特性，使得Java可以定义不规则的二维数组，即<code>a[10][]</code>，其中每一行上的数组大小可以不同。C++中也有这种定义方式，不过会自动补全为0.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[][] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)</span><br><span class=\"line\">    a[i] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">System.out.println(a[<span class=\"number\">0</span>][<span class=\"number\">0</span>]);\t<span class=\"comment\">// 输出a[0][1]就会报数组越界的错误</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"大数值\"><a href=\"#大数值\" class=\"headerlink\" title=\"大数值\"></a>大数值</h2><p>BigInteger和BigDecimal可以处理任意精读的运算。但是不能用+*符号，只能用类的静态方法来实现。</p>\n<p>转换方法：<code>BigInteger big = BigInteger.valueOf(2);</code></p>\n<h2 id=\"关于编码、码元、码字等：\"><a href=\"#关于编码、码元、码字等：\" class=\"headerlink\" title=\"关于编码、码元、码字等：\"></a>关于编码、码元、码字等：</h2><p>一个有效的 Unicode 字符的二进制代码值被称作一个码点，也就是一个字符意味着一个码点。</p>\n<p><a href=\"https://github.com/acmerfight/insight_python/blob/master/Unicode_and_Character_Sets.md\"><strong>Unicode_and_Character_Sets</strong></a></p>\n<p><a href=\"https://blog.csdn.net/so_geili/article/details/105477780\"><strong>java——char类型、码点和代码单元详解</strong></a></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>Java核心技术卷1笔记</p>","more":"<h1 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h1><ul>\n<li>String变量既可以存放空串，也可以存放null。区分两者，空串是一个对象，有长度（0）和内容（空）。检查时，先检查是否为空，再检查长度是否为0.</li>\n</ul>\n<h2 id=\"String的长度\"><a href=\"#String的长度\" class=\"headerlink\" title=\"String的长度\"></a>String的长度</h2><p>String的长度涉及到码点与码元。以下对比几种方法：</p>\n<ul>\n<li>String.length()与String.codePointCount()：str.length()返回字符串str的码元数量，str.codePointCount(0, str.length())返回字符串str的码字数量。</li>\n<li>String.charAt()与String.codePointAt()：str.charAt(n)返回字符串str的码元；获取码字需要和String.offsetByCodePoints()配合使用，<code>int index = str.offsetByCodePoints(n); int cp = str.codePointAt(index)</code>，注意是返回int。</li>\n</ul>\n<p>之所以会有区别，是因为辅助字符是有两个码元的。</p>\n<p>遍历字符串码元的方法：codePoints()；判断一个码点是否为辅助字符：isSupplementaryCodePoint(int codePoint)；判断一个码元是否对应辅助字符的码元：isSurrogate(char)</p>\n<h2 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h2><p>输入Scanner不多说，在输密码需要不显示的时候可以用console.readPassword()</p>\n<h3 id=\"格式化输出printf\"><a href=\"#格式化输出printf\" class=\"headerlink\" title=\"格式化输出printf\"></a>格式化输出printf</h3><p><strong>输出数字</strong></p>\n<p><code>%8.2f</code>：8表示宽度，.2表示小数，f是转换符</p>\n<p>在%之后可以加入标志（控制输出格式，如对齐方式、分组分隔符等）</p>\n<p><code>%,+.2f</code>：,表示分组（如1000写作1,000），+表示输出正负号</p>\n<p><strong>输出日期</strong></p>\n<p>以t开头，后跟转换符</p>\n<p><code>%tc</code>：输出完整的时间如<code>周二 11月 30 20:48:29 CST 2021</code></p>\n<p>可以对同一个Date对象操作，输出时需要指出被格式化的参数索引，有两种写法。&lt;是一种标志，表示格式化前一个的数值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.printf(<span class=\"string\">&quot;%tB %&lt;te, %&lt;tY&quot;</span>, <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">System.out.printf(<span class=\"string\">&quot;%1$tB %1$te, %1$tY&quot;</span>, <span class=\"keyword\">new</span> Date());</span><br></pre></td></tr></table></figure>\n\n<p>PS：输出日期有java.text.SimpleDateFormat，可以方便表示。<a href=\"https://blog.csdn.net/qq_27093465/article/details/53034427\">java 日期格式化– SimpleDateFormat 的使用</a></p>\n<h3 id=\"文件输入输出\"><a href=\"#文件输入输出\" class=\"headerlink\" title=\"文件输入输出\"></a>文件输入输出</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner scanner = <span class=\"keyword\">new</span> Scanner(Paths.get(<span class=\"string\">&quot;input.txt&quot;</span>), StandardCharsets.UTF_8);</span><br><span class=\"line\">PrintWriter printWriter = <span class=\"keyword\">new</span> PrintWriter(<span class=\"string\">&quot;output.txt&quot;</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><ul>\n<li><p>直接new一个数组：数字数组初始化为0，boolean数组初始化为false，对象数组初始化为null。</p>\n</li>\n<li><p>数组创建后不能改变大小，ArrayList可以改变大小。</p>\n</li>\n</ul>\n<p><strong>数组初始化</strong>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;\t<span class=\"comment\">// new int[] &#123;1,2,3&#125;是匿名数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] b = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] c = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)</span><br><span class=\"line\">    c[i] = i+<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>数组拷贝</strong></p>\n<p>记住，数组是引用类型，除了基本数据类型（整型，浮点型，布尔型，字符型）都是引用类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] b = a;\t<span class=\"comment\">// b和a指向同一个数组</span></span><br><span class=\"line\">b[<span class=\"number\">0</span>]=<span class=\"number\">5</span>;\t\t\t<span class=\"comment\">// 此时a[0]也为5</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要复制到一个新数组应该是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] b = Array.copyOf(a, a.length);</span><br><span class=\"line\"><span class=\"comment\">//可以用来增加数组长度</span></span><br><span class=\"line\">a = Array.copyOf(a, a.length*<span class=\"number\">2</span>);\t<span class=\"comment\">//多余的地方填0</span></span><br><span class=\"line\"><span class=\"comment\">//Array.copyOfRange(a, 0, a.length*2);</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>数组排序</strong>：Array.sort(a);</p>\n<p><strong>二维数组（多维数组）</strong></p>\n<ul>\n<li>Java中的二维数组，如<code>a[10][10]</code>，a是包含10个元素的数组，而其中每个元素又是包含10个元素的数组。我认为正是这个特性，使得Java可以定义不规则的二维数组，即<code>a[10][]</code>，其中每一行上的数组大小可以不同。C++中也有这种定义方式，不过会自动补全为0.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[][] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)</span><br><span class=\"line\">    a[i] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">System.out.println(a[<span class=\"number\">0</span>][<span class=\"number\">0</span>]);\t<span class=\"comment\">// 输出a[0][1]就会报数组越界的错误</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"大数值\"><a href=\"#大数值\" class=\"headerlink\" title=\"大数值\"></a>大数值</h2><p>BigInteger和BigDecimal可以处理任意精读的运算。但是不能用+*符号，只能用类的静态方法来实现。</p>\n<p>转换方法：<code>BigInteger big = BigInteger.valueOf(2);</code></p>\n<h2 id=\"关于编码、码元、码字等：\"><a href=\"#关于编码、码元、码字等：\" class=\"headerlink\" title=\"关于编码、码元、码字等：\"></a>关于编码、码元、码字等：</h2><p>一个有效的 Unicode 字符的二进制代码值被称作一个码点，也就是一个字符意味着一个码点。</p>\n<p><a href=\"https://github.com/acmerfight/insight_python/blob/master/Unicode_and_Character_Sets.md\"><strong>Unicode_and_Character_Sets</strong></a></p>\n<p><a href=\"https://blog.csdn.net/so_geili/article/details/105477780\"><strong>java——char类型、码点和代码单元详解</strong></a></p>"},{"title":"Java核心技术卷1笔记-2","date":"2021-12-08T08:00:51.000Z","updated":"2021-12-08T08:00:51.000Z","_content":"\n第四章笔记\n\n<!--more-->\n\n# 对象\n\n- 三大基本特征：封装、继承、多态。\n- 对象的构造使用**构造器**：`new Date()`。构造器的名称与类名相同。\n- 区别对象变量与对象：对象变量**引用**一个对象。\n- 在使用类方法时，实际上还有一个隐式参数，即对象。\n- 对于同一个类，一个对象的私有域可以被另一个对象访问。\n\n# final修饰符\n\n参考：[浅析Java中的final关键字](https://www.cnblogs.com/dolphin0520/p/3736238.html)\n\n三个特性：（1）构建类时必须初始化；（2）初始化后不能修改；（3）一般用于基本类型或者不可变类。\n\n可以用于修饰类、方法、变量。\n\n**修饰类**\n\n表示该类不允许被继承，且类内方法被隐式声明为final方法。\n\n**修饰方法**\n\nfinal可以将方法锁定，即防止继承类修改其含义。因此，如果这个方法不想在子类中被覆盖的话，就设置为final。（private方法会隐式指定为final方法）\n\n将类或方法修饰为final，可以防止其在子类中被修改。\n\n**修饰变量**\n\n对于一个final变量，如果是基本数据类型变量，那么初始化之后就不能再修改；如果是引用类型变量，那么初始化之后就能指向另一个对象。\n\n# 静态域\n\n- 一个类的所有实例都共享一个静态域\n\n- 类中**静态常量**用处较多，比如`Math.PI`，`System.out`\n\n**静态方法**\n\n静态方法是一种不能操作对象的方法。也就是说，静态方法中不能使用类的实例域，但是可以方法类的静态域。因此以下两种情况可以用静态方法：（1）不需要访问对象状态；（2）只需要访问静态域。\n\n调用时直接类名就行，比如`Math.pow(x, a);`\n\n下文【其他】中提到的静态工厂方法也是。\n\n**main方法**\n\n每一个类都可以有自己的main方法，就用来做单元测试。\n\n# 方法参数\n\n**Java采用按值调用**（而不是按引用调用）。按值调用，即方法接受的是**参数的拷贝**。\n\n这里有一个比较绕的点，**如果参数时引用变量，函数会接受一个引用变量的拷贝**。对于拷贝所指的对象进行修改，也可以改变其值，即**可以改变对象参数引用的对象的状态**。但是，**无法改变对象参数引用的对**象。\n\n# 对象构造\n\n构造器的多种写法。\n\n**重载（overload）**\n\n简单来说，就是方法名称相同，但参数不同。编译器会进行**重载解析**（为具体执行挑选特定的方法）。\n\n描述一个方法，通过方法的签名，方法签名指的是**方法名称与参数类型**（不包括返回类型，因此不允许存在名称和参数相同，返回类型却不同的两种方法）（不允许这种情况也好理解，我感觉是编译器解析的时候管不到返回类型这么远的东西）\n\n**无参数的构造器**\n\n如果类中没有写构造器，此时会有一个默认的无参数构造器，构造器为实例域都设置为默认值（如对象是null，数值为0，布尔型为false）。\n\n注意，如果只写了一个带参数的构造器，这个时候在new对象的时候用无参数构造器，是会报错的。\n\n**显式域初始化**\n\n在声明数据域的时候，直接赋值了。这个操作是在调用构造器之前执行的。\n\n**调用另一个构造器**\n\n在一个构造器中调用另一个构造器，**要放在第一句**，如此一来使得不同构造器之间公共的部分只需要写一次。\n\n例子：\n\n```java\npublic Employee(int id)\n{\n    this(id, \"Employee #\" + nextId);\t// 看这里~\n    nextId ++;\n}\n```\n\n**初始化块**\n\n不常见，通常都是会放到构造器中。就是在数据域声明之后放一个花括号括起来的代码块，来初始化值。\n\n同样的，静态域除了直接赋值，也可以这样初始化，当类第一次加载的时候就会进行初始化。\n\n```java\nprivate static int example = 1;  // 直接赋值\n\nprivate static int nextId;\nstatic{\n    Random random = new Random();\n    nextId = random.nextInt(1000);\n}\n```\n\n**对象析构**\n\nC++中有析构器，来清理与释放内存。但Java有垃圾回收机制，因此不需要人工回收，也不支持析构器。\n\n但是如果有对象**使用了内存之外的资源**，需要回收再利用的时候，可以引入finalize方法，但用起来要当心，因为不知道啥时候才会调用这个方法。（有关闭钩方法）\n\n另外，如果有资源需要在用完了之后马上关闭，那就需要人工管理，用close。\n\n# 包（package）\n\n如果要访问某个包中的类，有两种方式。第一，指名道姓地给出完整路径；第二，导入该类或该类所在的包。\n\n```java\nLocalDate today = LocalDate.now();\njava.time.LocalDate today = java.time.LocalDate.now();\n```\n\n- 如果有重复名称的类同时出现在程序里，那么就要指名道姓给出路径了。\n\n- 在包中定位是编译器的事情。\n\n**静态导入**\n\n这样可以直接使用某个类中的静态和静态方法，比如Math包：\n\n```java\nimport static java.lang.Math.*;\n...\n\tsqrt(2); // 不用写Math.sqrt(2); \n```\n\n>  `java.lang.*`是默认导入的，因此不需要导入就可以使用`Math`类的函数。\n\n**创建自己的包**\n\n在源代码开头写`package myjava.com.test;`，然后把这个文件放到myjava/com/test文件夹下面\n\n- 注意，现在不允许自定义`java.`开头的包了，怕原始文件被破坏。[Prohibited package name: java异常原因-CSDN博客](https://blog.csdn.net/Ezreal_King/article/details/60879025)\n\n\n\n# 其他\n\n## 静态工厂方法（static factory method）\n\n简单来说，就是代替构造器，来提供类实例的方法。在《Effective Java》中提出**“用静态工厂方法代替构造器”**。\n\n写法\n\n```java\npublic static ClassName getInstance()\n```\n\n参考：[关于 Java 的静态工厂方法，看这一篇就够了](https://www.jianshu.com/p/ceb5ec8f1174)\n\n## public与private\n\npublic表示可以被任意类使用，private表示只能被定义它的类使用，啥也不加表示的是package，也就是只能被同一个包内的类使用。类、变量和方法都是如此。\n\n定义private类，只能在一个外部类（顶级类，top class）中定义。且一个top class中不能用private修饰（参考这篇[Stack Overflow](https://stackoverflow.com/questions/1913863/why-cant-we-define-a-top-level-class-as-private)）。\n\n- 注意，变量要显式指出private，否则破坏了类的封装性。\n\n## JAR\n\njar中可以压缩存放多个类和子目录，更节省空间。在使用时需要设置类路径。\n\n类路径的设置也就是环境变量里的`CLASSPATH`。\n\n## 文档注释\n\n主要是javadoc的用法。javadoc可以根据源代码中的注释自动生成文档。\n\n提取信息的有：\n\n1. 包\n2. 公有类与接口\n3. 公有的和受保护的构造器及方法\n4. 公有的和受保护的域\n\n在源代码中添加注释：\n\n对公有类添加注释需要在import后，声明前。\n\n```java\nimport java.util.Random;\n/**\n * This is an {@code Employee} object.\n * @author lwq\n * @version 1.0\n */\npublic class Employee {\n    ...\n}\n```\n\n对公有域注释一般是对静态常量注释。\n\n对包添加注释：\n\n同目录下新建文件。\n\n（PS，要用的时候知道有这个工具就行）\n","source":"_posts/Java核心技术卷1笔记-2.md","raw":"---\ntitle: Java核心技术卷1笔记-2\ndate: 2021-12-08 16:00:51\nupdated: 2021-12-08 16:00:51\ncategories: Java\n---\n\n第四章笔记\n\n<!--more-->\n\n# 对象\n\n- 三大基本特征：封装、继承、多态。\n- 对象的构造使用**构造器**：`new Date()`。构造器的名称与类名相同。\n- 区别对象变量与对象：对象变量**引用**一个对象。\n- 在使用类方法时，实际上还有一个隐式参数，即对象。\n- 对于同一个类，一个对象的私有域可以被另一个对象访问。\n\n# final修饰符\n\n参考：[浅析Java中的final关键字](https://www.cnblogs.com/dolphin0520/p/3736238.html)\n\n三个特性：（1）构建类时必须初始化；（2）初始化后不能修改；（3）一般用于基本类型或者不可变类。\n\n可以用于修饰类、方法、变量。\n\n**修饰类**\n\n表示该类不允许被继承，且类内方法被隐式声明为final方法。\n\n**修饰方法**\n\nfinal可以将方法锁定，即防止继承类修改其含义。因此，如果这个方法不想在子类中被覆盖的话，就设置为final。（private方法会隐式指定为final方法）\n\n将类或方法修饰为final，可以防止其在子类中被修改。\n\n**修饰变量**\n\n对于一个final变量，如果是基本数据类型变量，那么初始化之后就不能再修改；如果是引用类型变量，那么初始化之后就能指向另一个对象。\n\n# 静态域\n\n- 一个类的所有实例都共享一个静态域\n\n- 类中**静态常量**用处较多，比如`Math.PI`，`System.out`\n\n**静态方法**\n\n静态方法是一种不能操作对象的方法。也就是说，静态方法中不能使用类的实例域，但是可以方法类的静态域。因此以下两种情况可以用静态方法：（1）不需要访问对象状态；（2）只需要访问静态域。\n\n调用时直接类名就行，比如`Math.pow(x, a);`\n\n下文【其他】中提到的静态工厂方法也是。\n\n**main方法**\n\n每一个类都可以有自己的main方法，就用来做单元测试。\n\n# 方法参数\n\n**Java采用按值调用**（而不是按引用调用）。按值调用，即方法接受的是**参数的拷贝**。\n\n这里有一个比较绕的点，**如果参数时引用变量，函数会接受一个引用变量的拷贝**。对于拷贝所指的对象进行修改，也可以改变其值，即**可以改变对象参数引用的对象的状态**。但是，**无法改变对象参数引用的对**象。\n\n# 对象构造\n\n构造器的多种写法。\n\n**重载（overload）**\n\n简单来说，就是方法名称相同，但参数不同。编译器会进行**重载解析**（为具体执行挑选特定的方法）。\n\n描述一个方法，通过方法的签名，方法签名指的是**方法名称与参数类型**（不包括返回类型，因此不允许存在名称和参数相同，返回类型却不同的两种方法）（不允许这种情况也好理解，我感觉是编译器解析的时候管不到返回类型这么远的东西）\n\n**无参数的构造器**\n\n如果类中没有写构造器，此时会有一个默认的无参数构造器，构造器为实例域都设置为默认值（如对象是null，数值为0，布尔型为false）。\n\n注意，如果只写了一个带参数的构造器，这个时候在new对象的时候用无参数构造器，是会报错的。\n\n**显式域初始化**\n\n在声明数据域的时候，直接赋值了。这个操作是在调用构造器之前执行的。\n\n**调用另一个构造器**\n\n在一个构造器中调用另一个构造器，**要放在第一句**，如此一来使得不同构造器之间公共的部分只需要写一次。\n\n例子：\n\n```java\npublic Employee(int id)\n{\n    this(id, \"Employee #\" + nextId);\t// 看这里~\n    nextId ++;\n}\n```\n\n**初始化块**\n\n不常见，通常都是会放到构造器中。就是在数据域声明之后放一个花括号括起来的代码块，来初始化值。\n\n同样的，静态域除了直接赋值，也可以这样初始化，当类第一次加载的时候就会进行初始化。\n\n```java\nprivate static int example = 1;  // 直接赋值\n\nprivate static int nextId;\nstatic{\n    Random random = new Random();\n    nextId = random.nextInt(1000);\n}\n```\n\n**对象析构**\n\nC++中有析构器，来清理与释放内存。但Java有垃圾回收机制，因此不需要人工回收，也不支持析构器。\n\n但是如果有对象**使用了内存之外的资源**，需要回收再利用的时候，可以引入finalize方法，但用起来要当心，因为不知道啥时候才会调用这个方法。（有关闭钩方法）\n\n另外，如果有资源需要在用完了之后马上关闭，那就需要人工管理，用close。\n\n# 包（package）\n\n如果要访问某个包中的类，有两种方式。第一，指名道姓地给出完整路径；第二，导入该类或该类所在的包。\n\n```java\nLocalDate today = LocalDate.now();\njava.time.LocalDate today = java.time.LocalDate.now();\n```\n\n- 如果有重复名称的类同时出现在程序里，那么就要指名道姓给出路径了。\n\n- 在包中定位是编译器的事情。\n\n**静态导入**\n\n这样可以直接使用某个类中的静态和静态方法，比如Math包：\n\n```java\nimport static java.lang.Math.*;\n...\n\tsqrt(2); // 不用写Math.sqrt(2); \n```\n\n>  `java.lang.*`是默认导入的，因此不需要导入就可以使用`Math`类的函数。\n\n**创建自己的包**\n\n在源代码开头写`package myjava.com.test;`，然后把这个文件放到myjava/com/test文件夹下面\n\n- 注意，现在不允许自定义`java.`开头的包了，怕原始文件被破坏。[Prohibited package name: java异常原因-CSDN博客](https://blog.csdn.net/Ezreal_King/article/details/60879025)\n\n\n\n# 其他\n\n## 静态工厂方法（static factory method）\n\n简单来说，就是代替构造器，来提供类实例的方法。在《Effective Java》中提出**“用静态工厂方法代替构造器”**。\n\n写法\n\n```java\npublic static ClassName getInstance()\n```\n\n参考：[关于 Java 的静态工厂方法，看这一篇就够了](https://www.jianshu.com/p/ceb5ec8f1174)\n\n## public与private\n\npublic表示可以被任意类使用，private表示只能被定义它的类使用，啥也不加表示的是package，也就是只能被同一个包内的类使用。类、变量和方法都是如此。\n\n定义private类，只能在一个外部类（顶级类，top class）中定义。且一个top class中不能用private修饰（参考这篇[Stack Overflow](https://stackoverflow.com/questions/1913863/why-cant-we-define-a-top-level-class-as-private)）。\n\n- 注意，变量要显式指出private，否则破坏了类的封装性。\n\n## JAR\n\njar中可以压缩存放多个类和子目录，更节省空间。在使用时需要设置类路径。\n\n类路径的设置也就是环境变量里的`CLASSPATH`。\n\n## 文档注释\n\n主要是javadoc的用法。javadoc可以根据源代码中的注释自动生成文档。\n\n提取信息的有：\n\n1. 包\n2. 公有类与接口\n3. 公有的和受保护的构造器及方法\n4. 公有的和受保护的域\n\n在源代码中添加注释：\n\n对公有类添加注释需要在import后，声明前。\n\n```java\nimport java.util.Random;\n/**\n * This is an {@code Employee} object.\n * @author lwq\n * @version 1.0\n */\npublic class Employee {\n    ...\n}\n```\n\n对公有域注释一般是对静态常量注释。\n\n对包添加注释：\n\n同目录下新建文件。\n\n（PS，要用的时候知道有这个工具就行）\n","slug":"Java核心技术卷1笔记-2","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggp000n38t40lpj5z3m","content":"<p>第四章笔记</p>\n<span id=\"more\"></span>\n\n<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><ul>\n<li>三大基本特征：封装、继承、多态。</li>\n<li>对象的构造使用<strong>构造器</strong>：<code>new Date()</code>。构造器的名称与类名相同。</li>\n<li>区别对象变量与对象：对象变量<strong>引用</strong>一个对象。</li>\n<li>在使用类方法时，实际上还有一个隐式参数，即对象。</li>\n<li>对于同一个类，一个对象的私有域可以被另一个对象访问。</li>\n</ul>\n<h1 id=\"final修饰符\"><a href=\"#final修饰符\" class=\"headerlink\" title=\"final修饰符\"></a>final修饰符</h1><p>参考：<a href=\"https://www.cnblogs.com/dolphin0520/p/3736238.html\">浅析Java中的final关键字</a></p>\n<p>三个特性：（1）构建类时必须初始化；（2）初始化后不能修改；（3）一般用于基本类型或者不可变类。</p>\n<p>可以用于修饰类、方法、变量。</p>\n<p><strong>修饰类</strong></p>\n<p>表示该类不允许被继承，且类内方法被隐式声明为final方法。</p>\n<p><strong>修饰方法</strong></p>\n<p>final可以将方法锁定，即防止继承类修改其含义。因此，如果这个方法不想在子类中被覆盖的话，就设置为final。（private方法会隐式指定为final方法）</p>\n<p>将类或方法修饰为final，可以防止其在子类中被修改。</p>\n<p><strong>修饰变量</strong></p>\n<p>对于一个final变量，如果是基本数据类型变量，那么初始化之后就不能再修改；如果是引用类型变量，那么初始化之后就能指向另一个对象。</p>\n<h1 id=\"静态域\"><a href=\"#静态域\" class=\"headerlink\" title=\"静态域\"></a>静态域</h1><ul>\n<li><p>一个类的所有实例都共享一个静态域</p>\n</li>\n<li><p>类中<strong>静态常量</strong>用处较多，比如<code>Math.PI</code>，<code>System.out</code></p>\n</li>\n</ul>\n<p><strong>静态方法</strong></p>\n<p>静态方法是一种不能操作对象的方法。也就是说，静态方法中不能使用类的实例域，但是可以方法类的静态域。因此以下两种情况可以用静态方法：（1）不需要访问对象状态；（2）只需要访问静态域。</p>\n<p>调用时直接类名就行，比如<code>Math.pow(x, a);</code></p>\n<p>下文【其他】中提到的静态工厂方法也是。</p>\n<p><strong>main方法</strong></p>\n<p>每一个类都可以有自己的main方法，就用来做单元测试。</p>\n<h1 id=\"方法参数\"><a href=\"#方法参数\" class=\"headerlink\" title=\"方法参数\"></a>方法参数</h1><p><strong>Java采用按值调用</strong>（而不是按引用调用）。按值调用，即方法接受的是<strong>参数的拷贝</strong>。</p>\n<p>这里有一个比较绕的点，<strong>如果参数时引用变量，函数会接受一个引用变量的拷贝</strong>。对于拷贝所指的对象进行修改，也可以改变其值，即<strong>可以改变对象参数引用的对象的状态</strong>。但是，<strong>无法改变对象参数引用的对</strong>象。</p>\n<h1 id=\"对象构造\"><a href=\"#对象构造\" class=\"headerlink\" title=\"对象构造\"></a>对象构造</h1><p>构造器的多种写法。</p>\n<p><strong>重载（overload）</strong></p>\n<p>简单来说，就是方法名称相同，但参数不同。编译器会进行<strong>重载解析</strong>（为具体执行挑选特定的方法）。</p>\n<p>描述一个方法，通过方法的签名，方法签名指的是<strong>方法名称与参数类型</strong>（不包括返回类型，因此不允许存在名称和参数相同，返回类型却不同的两种方法）（不允许这种情况也好理解，我感觉是编译器解析的时候管不到返回类型这么远的东西）</p>\n<p><strong>无参数的构造器</strong></p>\n<p>如果类中没有写构造器，此时会有一个默认的无参数构造器，构造器为实例域都设置为默认值（如对象是null，数值为0，布尔型为false）。</p>\n<p>注意，如果只写了一个带参数的构造器，这个时候在new对象的时候用无参数构造器，是会报错的。</p>\n<p><strong>显式域初始化</strong></p>\n<p>在声明数据域的时候，直接赋值了。这个操作是在调用构造器之前执行的。</p>\n<p><strong>调用另一个构造器</strong></p>\n<p>在一个构造器中调用另一个构造器，<strong>要放在第一句</strong>，如此一来使得不同构造器之间公共的部分只需要写一次。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Employee</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(id, <span class=\"string\">&quot;Employee #&quot;</span> + nextId);\t<span class=\"comment\">// 看这里~</span></span><br><span class=\"line\">    nextId ++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>初始化块</strong></p>\n<p>不常见，通常都是会放到构造器中。就是在数据域声明之后放一个花括号括起来的代码块，来初始化值。</p>\n<p>同样的，静态域除了直接赋值，也可以这样初始化，当类第一次加载的时候就会进行初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> example = <span class=\"number\">1</span>;  <span class=\"comment\">// 直接赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> nextId;</span><br><span class=\"line\"><span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">    Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    nextId = random.nextInt(<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>对象析构</strong></p>\n<p>C++中有析构器，来清理与释放内存。但Java有垃圾回收机制，因此不需要人工回收，也不支持析构器。</p>\n<p>但是如果有对象<strong>使用了内存之外的资源</strong>，需要回收再利用的时候，可以引入finalize方法，但用起来要当心，因为不知道啥时候才会调用这个方法。（有关闭钩方法）</p>\n<p>另外，如果有资源需要在用完了之后马上关闭，那就需要人工管理，用close。</p>\n<h1 id=\"包（package）\"><a href=\"#包（package）\" class=\"headerlink\" title=\"包（package）\"></a>包（package）</h1><p>如果要访问某个包中的类，有两种方式。第一，指名道姓地给出完整路径；第二，导入该类或该类所在的包。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDate today = LocalDate.now();</span><br><span class=\"line\">java.time.LocalDate today = java.time.LocalDate.now();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果有重复名称的类同时出现在程序里，那么就要指名道姓给出路径了。</p>\n</li>\n<li><p>在包中定位是编译器的事情。</p>\n</li>\n</ul>\n<p><strong>静态导入</strong></p>\n<p>这样可以直接使用某个类中的静态和静态方法，比如Math包：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.Math.*;</span><br><span class=\"line\">...</span><br><span class=\"line\">\tsqrt(<span class=\"number\">2</span>); <span class=\"comment\">// 不用写Math.sqrt(2); </span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p> <code>java.lang.*</code>是默认导入的，因此不需要导入就可以使用<code>Math</code>类的函数。</p>\n</blockquote>\n<p><strong>创建自己的包</strong></p>\n<p>在源代码开头写<code>package myjava.com.test;</code>，然后把这个文件放到myjava/com/test文件夹下面</p>\n<ul>\n<li>注意，现在不允许自定义<code>java.</code>开头的包了，怕原始文件被破坏。<a href=\"https://blog.csdn.net/Ezreal_King/article/details/60879025\">Prohibited package name: java异常原因-CSDN博客</a></li>\n</ul>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"静态工厂方法（static-factory-method）\"><a href=\"#静态工厂方法（static-factory-method）\" class=\"headerlink\" title=\"静态工厂方法（static factory method）\"></a>静态工厂方法（static factory method）</h2><p>简单来说，就是代替构造器，来提供类实例的方法。在《Effective Java》中提出<strong>“用静态工厂方法代替构造器”</strong>。</p>\n<p>写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ClassName <span class=\"title\">getInstance</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p>参考：<a href=\"https://www.jianshu.com/p/ceb5ec8f1174\">关于 Java 的静态工厂方法，看这一篇就够了</a></p>\n<h2 id=\"public与private\"><a href=\"#public与private\" class=\"headerlink\" title=\"public与private\"></a>public与private</h2><p>public表示可以被任意类使用，private表示只能被定义它的类使用，啥也不加表示的是package，也就是只能被同一个包内的类使用。类、变量和方法都是如此。</p>\n<p>定义private类，只能在一个外部类（顶级类，top class）中定义。且一个top class中不能用private修饰（参考这篇<a href=\"https://stackoverflow.com/questions/1913863/why-cant-we-define-a-top-level-class-as-private\">Stack Overflow</a>）。</p>\n<ul>\n<li>注意，变量要显式指出private，否则破坏了类的封装性。</li>\n</ul>\n<h2 id=\"JAR\"><a href=\"#JAR\" class=\"headerlink\" title=\"JAR\"></a>JAR</h2><p>jar中可以压缩存放多个类和子目录，更节省空间。在使用时需要设置类路径。</p>\n<p>类路径的设置也就是环境变量里的<code>CLASSPATH</code>。</p>\n<h2 id=\"文档注释\"><a href=\"#文档注释\" class=\"headerlink\" title=\"文档注释\"></a>文档注释</h2><p>主要是javadoc的用法。javadoc可以根据源代码中的注释自动生成文档。</p>\n<p>提取信息的有：</p>\n<ol>\n<li>包</li>\n<li>公有类与接口</li>\n<li>公有的和受保护的构造器及方法</li>\n<li>公有的和受保护的域</li>\n</ol>\n<p>在源代码中添加注释：</p>\n<p>对公有类添加注释需要在import后，声明前。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This is an &#123;<span class=\"doctag\">@code</span> Employee&#125; object.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lwq</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对公有域注释一般是对静态常量注释。</p>\n<p>对包添加注释：</p>\n<p>同目录下新建文件。</p>\n<p>（PS，要用的时候知道有这个工具就行）</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>第四章笔记</p>","more":"<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><ul>\n<li>三大基本特征：封装、继承、多态。</li>\n<li>对象的构造使用<strong>构造器</strong>：<code>new Date()</code>。构造器的名称与类名相同。</li>\n<li>区别对象变量与对象：对象变量<strong>引用</strong>一个对象。</li>\n<li>在使用类方法时，实际上还有一个隐式参数，即对象。</li>\n<li>对于同一个类，一个对象的私有域可以被另一个对象访问。</li>\n</ul>\n<h1 id=\"final修饰符\"><a href=\"#final修饰符\" class=\"headerlink\" title=\"final修饰符\"></a>final修饰符</h1><p>参考：<a href=\"https://www.cnblogs.com/dolphin0520/p/3736238.html\">浅析Java中的final关键字</a></p>\n<p>三个特性：（1）构建类时必须初始化；（2）初始化后不能修改；（3）一般用于基本类型或者不可变类。</p>\n<p>可以用于修饰类、方法、变量。</p>\n<p><strong>修饰类</strong></p>\n<p>表示该类不允许被继承，且类内方法被隐式声明为final方法。</p>\n<p><strong>修饰方法</strong></p>\n<p>final可以将方法锁定，即防止继承类修改其含义。因此，如果这个方法不想在子类中被覆盖的话，就设置为final。（private方法会隐式指定为final方法）</p>\n<p>将类或方法修饰为final，可以防止其在子类中被修改。</p>\n<p><strong>修饰变量</strong></p>\n<p>对于一个final变量，如果是基本数据类型变量，那么初始化之后就不能再修改；如果是引用类型变量，那么初始化之后就能指向另一个对象。</p>\n<h1 id=\"静态域\"><a href=\"#静态域\" class=\"headerlink\" title=\"静态域\"></a>静态域</h1><ul>\n<li><p>一个类的所有实例都共享一个静态域</p>\n</li>\n<li><p>类中<strong>静态常量</strong>用处较多，比如<code>Math.PI</code>，<code>System.out</code></p>\n</li>\n</ul>\n<p><strong>静态方法</strong></p>\n<p>静态方法是一种不能操作对象的方法。也就是说，静态方法中不能使用类的实例域，但是可以方法类的静态域。因此以下两种情况可以用静态方法：（1）不需要访问对象状态；（2）只需要访问静态域。</p>\n<p>调用时直接类名就行，比如<code>Math.pow(x, a);</code></p>\n<p>下文【其他】中提到的静态工厂方法也是。</p>\n<p><strong>main方法</strong></p>\n<p>每一个类都可以有自己的main方法，就用来做单元测试。</p>\n<h1 id=\"方法参数\"><a href=\"#方法参数\" class=\"headerlink\" title=\"方法参数\"></a>方法参数</h1><p><strong>Java采用按值调用</strong>（而不是按引用调用）。按值调用，即方法接受的是<strong>参数的拷贝</strong>。</p>\n<p>这里有一个比较绕的点，<strong>如果参数时引用变量，函数会接受一个引用变量的拷贝</strong>。对于拷贝所指的对象进行修改，也可以改变其值，即<strong>可以改变对象参数引用的对象的状态</strong>。但是，<strong>无法改变对象参数引用的对</strong>象。</p>\n<h1 id=\"对象构造\"><a href=\"#对象构造\" class=\"headerlink\" title=\"对象构造\"></a>对象构造</h1><p>构造器的多种写法。</p>\n<p><strong>重载（overload）</strong></p>\n<p>简单来说，就是方法名称相同，但参数不同。编译器会进行<strong>重载解析</strong>（为具体执行挑选特定的方法）。</p>\n<p>描述一个方法，通过方法的签名，方法签名指的是<strong>方法名称与参数类型</strong>（不包括返回类型，因此不允许存在名称和参数相同，返回类型却不同的两种方法）（不允许这种情况也好理解，我感觉是编译器解析的时候管不到返回类型这么远的东西）</p>\n<p><strong>无参数的构造器</strong></p>\n<p>如果类中没有写构造器，此时会有一个默认的无参数构造器，构造器为实例域都设置为默认值（如对象是null，数值为0，布尔型为false）。</p>\n<p>注意，如果只写了一个带参数的构造器，这个时候在new对象的时候用无参数构造器，是会报错的。</p>\n<p><strong>显式域初始化</strong></p>\n<p>在声明数据域的时候，直接赋值了。这个操作是在调用构造器之前执行的。</p>\n<p><strong>调用另一个构造器</strong></p>\n<p>在一个构造器中调用另一个构造器，<strong>要放在第一句</strong>，如此一来使得不同构造器之间公共的部分只需要写一次。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Employee</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(id, <span class=\"string\">&quot;Employee #&quot;</span> + nextId);\t<span class=\"comment\">// 看这里~</span></span><br><span class=\"line\">    nextId ++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>初始化块</strong></p>\n<p>不常见，通常都是会放到构造器中。就是在数据域声明之后放一个花括号括起来的代码块，来初始化值。</p>\n<p>同样的，静态域除了直接赋值，也可以这样初始化，当类第一次加载的时候就会进行初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> example = <span class=\"number\">1</span>;  <span class=\"comment\">// 直接赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> nextId;</span><br><span class=\"line\"><span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">    Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    nextId = random.nextInt(<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>对象析构</strong></p>\n<p>C++中有析构器，来清理与释放内存。但Java有垃圾回收机制，因此不需要人工回收，也不支持析构器。</p>\n<p>但是如果有对象<strong>使用了内存之外的资源</strong>，需要回收再利用的时候，可以引入finalize方法，但用起来要当心，因为不知道啥时候才会调用这个方法。（有关闭钩方法）</p>\n<p>另外，如果有资源需要在用完了之后马上关闭，那就需要人工管理，用close。</p>\n<h1 id=\"包（package）\"><a href=\"#包（package）\" class=\"headerlink\" title=\"包（package）\"></a>包（package）</h1><p>如果要访问某个包中的类，有两种方式。第一，指名道姓地给出完整路径；第二，导入该类或该类所在的包。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDate today = LocalDate.now();</span><br><span class=\"line\">java.time.LocalDate today = java.time.LocalDate.now();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果有重复名称的类同时出现在程序里，那么就要指名道姓给出路径了。</p>\n</li>\n<li><p>在包中定位是编译器的事情。</p>\n</li>\n</ul>\n<p><strong>静态导入</strong></p>\n<p>这样可以直接使用某个类中的静态和静态方法，比如Math包：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.Math.*;</span><br><span class=\"line\">...</span><br><span class=\"line\">\tsqrt(<span class=\"number\">2</span>); <span class=\"comment\">// 不用写Math.sqrt(2); </span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p> <code>java.lang.*</code>是默认导入的，因此不需要导入就可以使用<code>Math</code>类的函数。</p>\n</blockquote>\n<p><strong>创建自己的包</strong></p>\n<p>在源代码开头写<code>package myjava.com.test;</code>，然后把这个文件放到myjava/com/test文件夹下面</p>\n<ul>\n<li>注意，现在不允许自定义<code>java.</code>开头的包了，怕原始文件被破坏。<a href=\"https://blog.csdn.net/Ezreal_King/article/details/60879025\">Prohibited package name: java异常原因-CSDN博客</a></li>\n</ul>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"静态工厂方法（static-factory-method）\"><a href=\"#静态工厂方法（static-factory-method）\" class=\"headerlink\" title=\"静态工厂方法（static factory method）\"></a>静态工厂方法（static factory method）</h2><p>简单来说，就是代替构造器，来提供类实例的方法。在《Effective Java》中提出<strong>“用静态工厂方法代替构造器”</strong>。</p>\n<p>写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ClassName <span class=\"title\">getInstance</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p>参考：<a href=\"https://www.jianshu.com/p/ceb5ec8f1174\">关于 Java 的静态工厂方法，看这一篇就够了</a></p>\n<h2 id=\"public与private\"><a href=\"#public与private\" class=\"headerlink\" title=\"public与private\"></a>public与private</h2><p>public表示可以被任意类使用，private表示只能被定义它的类使用，啥也不加表示的是package，也就是只能被同一个包内的类使用。类、变量和方法都是如此。</p>\n<p>定义private类，只能在一个外部类（顶级类，top class）中定义。且一个top class中不能用private修饰（参考这篇<a href=\"https://stackoverflow.com/questions/1913863/why-cant-we-define-a-top-level-class-as-private\">Stack Overflow</a>）。</p>\n<ul>\n<li>注意，变量要显式指出private，否则破坏了类的封装性。</li>\n</ul>\n<h2 id=\"JAR\"><a href=\"#JAR\" class=\"headerlink\" title=\"JAR\"></a>JAR</h2><p>jar中可以压缩存放多个类和子目录，更节省空间。在使用时需要设置类路径。</p>\n<p>类路径的设置也就是环境变量里的<code>CLASSPATH</code>。</p>\n<h2 id=\"文档注释\"><a href=\"#文档注释\" class=\"headerlink\" title=\"文档注释\"></a>文档注释</h2><p>主要是javadoc的用法。javadoc可以根据源代码中的注释自动生成文档。</p>\n<p>提取信息的有：</p>\n<ol>\n<li>包</li>\n<li>公有类与接口</li>\n<li>公有的和受保护的构造器及方法</li>\n<li>公有的和受保护的域</li>\n</ol>\n<p>在源代码中添加注释：</p>\n<p>对公有类添加注释需要在import后，声明前。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This is an &#123;<span class=\"doctag\">@code</span> Employee&#125; object.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lwq</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对公有域注释一般是对静态常量注释。</p>\n<p>对包添加注释：</p>\n<p>同目录下新建文件。</p>\n<p>（PS，要用的时候知道有这个工具就行）</p>"},{"title":"Leetcode-0106","date":"2021-01-11T10:43:43.000Z","_content":"\n两数之和与整数反转\n\n<!--more-->\n\n## 两数之和\n\n### 我的思路\n\n先排序，找到小于等于target的最大数，索引为idx。然后用双指针，start=0，end=idx。如果两个相加等于target就break，小于target就start++，大于target就end--，这样循环。把找到的数在原数组中进行搜索，找到索引再返回。\n\n然后我遇到一个问题，如果数字相同（如3+3=6），返回索引会有重复。\n\n看了题解发现自己把问题想复杂了。嵌套循环就行了啊！\n\n### 题解\n\n1. 双层循环，$O(n^2)$\n2. 用哈希表，$O(1)$。除掉自身搜索哈希表，搜完了再把自己放进去，可以避免重复的问题（这个比较巧妙）。\n\n第二种思路的代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hashmap;\n        for(int i=0;i<nums.size();i++)\n        {\n            auto it = hashmap.find(target-nums[i]);\n            if(it != hashmap.end())\n            {\n                return {it->second, i};\n            }\n            hashmap[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n\n## 整数反转\n\n### 我的思路\n\n想把整数转为字符串，然后字符串用reverse函数就能翻转，再把字符串转为整数。这个问题关键在于如何判断溢出。我的方法是用stol()转为long，再和INT_MAX作比较。代码如下：\n\n```c++\nint reverse(int x) {\n    string str = to_string(abs(x));\n    std::reverse(str.begin(), str.end());\n\n    double result = stol(str);\n    if(result>INT_MAX)\n        return 0;\n    if(x<0)\n        result = -result;\n    return result;\n}\n```\n\nPS: int最大值用INT_MAX就可以，我先试了pow(2, 32)算出来很奇怪。\nPS2: INT_MAX和INT_MIN在头文件limits.h中，int类型的范围是$-2^{31}~2^{31}-1$。之所以上界要减一，下界不用是因为大于零时有符号位占一个；而下届是因为规定第一位为1，其余为0的是$-2^n$，不然这个编码就用不上了。\n\n### 题解\n\n官方题解的思路没有想到，是通过比较`x/10`和`INT_MAX/10`。若两者相等，那么再比较最后一位的大小。若前者大于后者，直接得到x溢出。要注意的是，有**向上溢出**还有**向下溢出**！！\n\n具体实现来说，由`pop=x%10`每次取x的最后一位，rev则从0开始，形成`rev*10+pop`来与INT_MAX和INT_MIN作比较。\n\n代码如下：\n\n```c++\nint reverse(int x) {\n    int rev=0;\n    int pop=0;\n    while(x)\n    {\n        pop=x%10;\n        if(rev > INT_MAX/10 || rev==INT_MAX/10 & pop>INT_MAX%10) return 0;\n        if(rev < INT_MIN/10 || rev == INT_MIN / 10 & pop < INT_MIN%10) return 0;\n        x = x/10;\n        rev = rev * 10 + pop;\n    }\n    return rev;\n}\n```\n\n## 写在最后\n\n从简单题开始练起，静下心来去消化题目。加油！💪💪","source":"_posts/Leetcode-0106.md","raw":"---\ntitle: Leetcode-0106\ndate: 2021-01-11 18:43:43\ntags: \n- 刷题\n- Leetcode简单题\ncategories: DailyCode\n---\n\n两数之和与整数反转\n\n<!--more-->\n\n## 两数之和\n\n### 我的思路\n\n先排序，找到小于等于target的最大数，索引为idx。然后用双指针，start=0，end=idx。如果两个相加等于target就break，小于target就start++，大于target就end--，这样循环。把找到的数在原数组中进行搜索，找到索引再返回。\n\n然后我遇到一个问题，如果数字相同（如3+3=6），返回索引会有重复。\n\n看了题解发现自己把问题想复杂了。嵌套循环就行了啊！\n\n### 题解\n\n1. 双层循环，$O(n^2)$\n2. 用哈希表，$O(1)$。除掉自身搜索哈希表，搜完了再把自己放进去，可以避免重复的问题（这个比较巧妙）。\n\n第二种思路的代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hashmap;\n        for(int i=0;i<nums.size();i++)\n        {\n            auto it = hashmap.find(target-nums[i]);\n            if(it != hashmap.end())\n            {\n                return {it->second, i};\n            }\n            hashmap[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n\n## 整数反转\n\n### 我的思路\n\n想把整数转为字符串，然后字符串用reverse函数就能翻转，再把字符串转为整数。这个问题关键在于如何判断溢出。我的方法是用stol()转为long，再和INT_MAX作比较。代码如下：\n\n```c++\nint reverse(int x) {\n    string str = to_string(abs(x));\n    std::reverse(str.begin(), str.end());\n\n    double result = stol(str);\n    if(result>INT_MAX)\n        return 0;\n    if(x<0)\n        result = -result;\n    return result;\n}\n```\n\nPS: int最大值用INT_MAX就可以，我先试了pow(2, 32)算出来很奇怪。\nPS2: INT_MAX和INT_MIN在头文件limits.h中，int类型的范围是$-2^{31}~2^{31}-1$。之所以上界要减一，下界不用是因为大于零时有符号位占一个；而下届是因为规定第一位为1，其余为0的是$-2^n$，不然这个编码就用不上了。\n\n### 题解\n\n官方题解的思路没有想到，是通过比较`x/10`和`INT_MAX/10`。若两者相等，那么再比较最后一位的大小。若前者大于后者，直接得到x溢出。要注意的是，有**向上溢出**还有**向下溢出**！！\n\n具体实现来说，由`pop=x%10`每次取x的最后一位，rev则从0开始，形成`rev*10+pop`来与INT_MAX和INT_MIN作比较。\n\n代码如下：\n\n```c++\nint reverse(int x) {\n    int rev=0;\n    int pop=0;\n    while(x)\n    {\n        pop=x%10;\n        if(rev > INT_MAX/10 || rev==INT_MAX/10 & pop>INT_MAX%10) return 0;\n        if(rev < INT_MIN/10 || rev == INT_MIN / 10 & pop < INT_MIN%10) return 0;\n        x = x/10;\n        rev = rev * 10 + pop;\n    }\n    return rev;\n}\n```\n\n## 写在最后\n\n从简单题开始练起，静下心来去消化题目。加油！💪💪","slug":"Leetcode-0106","published":1,"updated":"2021-01-11T10:43:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggr000q38t49w1qbpoo","content":"<p>两数之和与整数反转</p>\n<span id=\"more\"></span>\n\n<h2 id=\"两数之和\"><a href=\"#两数之和\" class=\"headerlink\" title=\"两数之和\"></a>两数之和</h2><h3 id=\"我的思路\"><a href=\"#我的思路\" class=\"headerlink\" title=\"我的思路\"></a>我的思路</h3><p>先排序，找到小于等于target的最大数，索引为idx。然后用双指针，start=0，end=idx。如果两个相加等于target就break，小于target就start++，大于target就end–，这样循环。把找到的数在原数组中进行搜索，找到索引再返回。</p>\n<p>然后我遇到一个问题，如果数字相同（如3+3=6），返回索引会有重复。</p>\n<p>看了题解发现自己把问题想复杂了。嵌套循环就行了啊！</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><ol>\n<li>双层循环，$O(n^2)$</li>\n<li>用哈希表，$O(1)$。除掉自身搜索哈希表，搜完了再把自己放进去，可以避免重复的问题（这个比较巧妙）。</li>\n</ol>\n<p>第二种思路的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; hashmap;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> it = hashmap.<span class=\"built_in\">find</span>(target-nums[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(it != hashmap.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            hashmap[nums[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"整数反转\"><a href=\"#整数反转\" class=\"headerlink\" title=\"整数反转\"></a>整数反转</h2><h3 id=\"我的思路-1\"><a href=\"#我的思路-1\" class=\"headerlink\" title=\"我的思路\"></a>我的思路</h3><p>想把整数转为字符串，然后字符串用reverse函数就能翻转，再把字符串转为整数。这个问题关键在于如何判断溢出。我的方法是用stol()转为long，再和INT_MAX作比较。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    string str = <span class=\"built_in\">to_string</span>(<span class=\"built_in\">abs</span>(x));</span><br><span class=\"line\">    std::<span class=\"built_in\">reverse</span>(str.<span class=\"built_in\">begin</span>(), str.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">double</span> result = <span class=\"built_in\">stol</span>(str);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result&gt;INT_MAX)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">        result = -result;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS: int最大值用INT_MAX就可以，我先试了pow(2, 32)算出来很奇怪。<br>PS2: INT_MAX和INT_MIN在头文件limits.h中，int类型的范围是$-2^{31}~2^{31}-1$。之所以上界要减一，下界不用是因为大于零时有符号位占一个；而下届是因为规定第一位为1，其余为0的是$-2^n$，不然这个编码就用不上了。</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>官方题解的思路没有想到，是通过比较<code>x/10</code>和<code>INT_MAX/10</code>。若两者相等，那么再比较最后一位的大小。若前者大于后者，直接得到x溢出。要注意的是，有<strong>向上溢出</strong>还有<strong>向下溢出</strong>！！</p>\n<p>具体实现来说，由<code>pop=x%10</code>每次取x的最后一位，rev则从0开始，形成<code>rev*10+pop</code>来与INT_MAX和INT_MIN作比较。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rev=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pop=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pop=x%<span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rev &gt; INT_MAX/<span class=\"number\">10</span> || rev==INT_MAX/<span class=\"number\">10</span> &amp; pop&gt;INT_MAX%<span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rev &lt; INT_MIN/<span class=\"number\">10</span> || rev == INT_MIN / <span class=\"number\">10</span> &amp; pop &lt; INT_MIN%<span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        x = x/<span class=\"number\">10</span>;</span><br><span class=\"line\">        rev = rev * <span class=\"number\">10</span> + pop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rev;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>从简单题开始练起，静下心来去消化题目。加油！💪💪</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>两数之和与整数反转</p>","more":"<h2 id=\"两数之和\"><a href=\"#两数之和\" class=\"headerlink\" title=\"两数之和\"></a>两数之和</h2><h3 id=\"我的思路\"><a href=\"#我的思路\" class=\"headerlink\" title=\"我的思路\"></a>我的思路</h3><p>先排序，找到小于等于target的最大数，索引为idx。然后用双指针，start=0，end=idx。如果两个相加等于target就break，小于target就start++，大于target就end–，这样循环。把找到的数在原数组中进行搜索，找到索引再返回。</p>\n<p>然后我遇到一个问题，如果数字相同（如3+3=6），返回索引会有重复。</p>\n<p>看了题解发现自己把问题想复杂了。嵌套循环就行了啊！</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><ol>\n<li>双层循环，$O(n^2)$</li>\n<li>用哈希表，$O(1)$。除掉自身搜索哈希表，搜完了再把自己放进去，可以避免重复的问题（这个比较巧妙）。</li>\n</ol>\n<p>第二种思路的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; hashmap;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> it = hashmap.<span class=\"built_in\">find</span>(target-nums[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(it != hashmap.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            hashmap[nums[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"整数反转\"><a href=\"#整数反转\" class=\"headerlink\" title=\"整数反转\"></a>整数反转</h2><h3 id=\"我的思路-1\"><a href=\"#我的思路-1\" class=\"headerlink\" title=\"我的思路\"></a>我的思路</h3><p>想把整数转为字符串，然后字符串用reverse函数就能翻转，再把字符串转为整数。这个问题关键在于如何判断溢出。我的方法是用stol()转为long，再和INT_MAX作比较。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    string str = <span class=\"built_in\">to_string</span>(<span class=\"built_in\">abs</span>(x));</span><br><span class=\"line\">    std::<span class=\"built_in\">reverse</span>(str.<span class=\"built_in\">begin</span>(), str.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">double</span> result = <span class=\"built_in\">stol</span>(str);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result&gt;INT_MAX)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">        result = -result;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PS: int最大值用INT_MAX就可以，我先试了pow(2, 32)算出来很奇怪。<br>PS2: INT_MAX和INT_MIN在头文件limits.h中，int类型的范围是$-2^{31}~2^{31}-1$。之所以上界要减一，下界不用是因为大于零时有符号位占一个；而下届是因为规定第一位为1，其余为0的是$-2^n$，不然这个编码就用不上了。</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>官方题解的思路没有想到，是通过比较<code>x/10</code>和<code>INT_MAX/10</code>。若两者相等，那么再比较最后一位的大小。若前者大于后者，直接得到x溢出。要注意的是，有<strong>向上溢出</strong>还有<strong>向下溢出</strong>！！</p>\n<p>具体实现来说，由<code>pop=x%10</code>每次取x的最后一位，rev则从0开始，形成<code>rev*10+pop</code>来与INT_MAX和INT_MIN作比较。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rev=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pop=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pop=x%<span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rev &gt; INT_MAX/<span class=\"number\">10</span> || rev==INT_MAX/<span class=\"number\">10</span> &amp; pop&gt;INT_MAX%<span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rev &lt; INT_MIN/<span class=\"number\">10</span> || rev == INT_MIN / <span class=\"number\">10</span> &amp; pop &lt; INT_MIN%<span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        x = x/<span class=\"number\">10</span>;</span><br><span class=\"line\">        rev = rev * <span class=\"number\">10</span> + pop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rev;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>从简单题开始练起，静下心来去消化题目。加油！💪💪</p>"},{"title":"Leetcode0221","date":"2021-02-21T15:02:58.000Z","_content":"\n回文数、罗马字符转数字\n<!--more-->\n\n## 9. 回文数\n\n题目链接：[LeetCode链接](https://leetcode-cn.com/problems/palindrome-number/)\n\n没有用字符串的方法来做。\n\n### 我的思路\n\n1. 依次取第一位和最后一位上的数字进行比较。后面的数字是好取，第一位数字不好取，问题复杂化了。\n2. 从后面开始取数字，得到翻转过来的数字，然后比较一下是否相等。考虑到溢出：如果出现溢出，那么也肯定不是回文数，但是需要把翻转过来的数字类型定义为long。\n\n代码用时20ms，击败38.53%；内存消耗5.8MB，击败80.43%：\n\n```c++\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x<0)\n            return false;\n        int x_tmp = x;\n        long tmp = 0;\n        while(x_tmp)\n        {\n            tmp = tmp * 10 + x_tmp % 10;\n            x_tmp /= 10;\n        }\n        if (x == tmp)\n            return true;\n        else\n            return false;\n    }\n};\n```\n\n### 官解\n\n第一，考虑特殊情况，分别是负数和最后一位为0。第二，只要判断一半就够。对于如何鉴别这个一半的位置，只要对上面的代码稍作改动就可以。\n\n```c++\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x<0)   \n            return false;\n        if (x!=0 && x%10 ==0)   // 加入另一种特殊情况\n            return false;\n        int tmp = 0;    // 这个时候int就够了\n        while(x > tmp)\n        {\n            tmp = tmp * 10 + x % 10;\n            x /= 10;\n        }\n        // 第一种条件是位数为偶数，一分为二；第二种情况是位数为奇数\n        if (x == tmp || x == tmp/10)\n            return true;\n        else\n            return false;\n    }\n};\n```\n\n评论里说得好哇：\n\n“简单的题效率完全比不上题解，复杂的题完全不会 -.-”  by wanwenx\n\n😣\n\n## 13. 罗马数字转整数\n\n题目链接：[13. 罗马数字转整数 - 力扣（LeetCode）]( https://leetcode-cn.com/problems/roman-to-integer/submissions/)\n\n### 我的思路\n\n1. 定义一个函数，输入罗马字符，返回对应的数值；\n2. 分析罗马数字的规则：如果是正常计算的话，一个字符对应一个数，加起来就可以了；特殊情况只有后一位比当前位对应数值要大。那么，只要当前位置不是最后一位，就比较当前位置大小和下一位置大小。\n\n注：switch语句里要用break做当前分支的结束。不然即使满足条件，也还是会进入下一分支。\n\n代码用时12ms，击败66.55%；内存消耗5.9MB，击败89.62%：\n\n```c++\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        int len = s.length();\n        int i=0;\n        int now=0, next=0, result=0;\n        while(i<len)\n        {\n            now = trans(s[i]);\n            if(i == len-1)\n            {\n                result += now;\n                break;\n            }\n            next = trans(s[i+1]);\n            if(now<next)\n            {\n                result += next - now;\n                i += 2;\n                continue;                \n            }\n            result += now;\n            i++;\n        }\n        return result;\n    }\n    int trans(char ch)\n    {\n        int a=0;\n        switch(ch)\n        {\n            case 'I':\n                a = 1;\n                break;\n            case 'V':\n                a = 5;\n                break;\n            case 'X':\n                a = 10;\n                break;\n            case 'L':\n                a = 50;\n                break;\n            case 'C':\n                a = 100;\n                break;\n            case 'D':\n                a = 500;\n                break;\n            case 'M':\n                a = 1000;\n        }\n        return a;\n    }\n};\n```\n\n### 题解\n\n基本思路和我的方法差不多，有把switch函数换成哈希表的。\n\n```c++\nunordered_map<string, int> m = {{\"I\", 1}, {\"IV\", 3}, {\"IX\", 8}, {\"V\", 5}, {\"X\", 10}, {\"XL\", 30}, {\"XC\", 80}, {\"L\", 50}, {\"C\", 100}, {\"CD\", 300}, {\"CM\", 800}, {\"D\", 500}, {\"M\", 1000}};\n```\n\n一个作者说明得比我更清楚写，小数在左大数在右，则做减法，即IV中的I对应-1.\n\n\n\n","source":"_posts/Leetcode-0221.md","raw":"---\ntitle: Leetcode0221\ndate: 2021-02-21 23:02:58\ntags: \n- 刷题\n- Leetcode简单题\ncategories: DailyCode\n---\n\n回文数、罗马字符转数字\n<!--more-->\n\n## 9. 回文数\n\n题目链接：[LeetCode链接](https://leetcode-cn.com/problems/palindrome-number/)\n\n没有用字符串的方法来做。\n\n### 我的思路\n\n1. 依次取第一位和最后一位上的数字进行比较。后面的数字是好取，第一位数字不好取，问题复杂化了。\n2. 从后面开始取数字，得到翻转过来的数字，然后比较一下是否相等。考虑到溢出：如果出现溢出，那么也肯定不是回文数，但是需要把翻转过来的数字类型定义为long。\n\n代码用时20ms，击败38.53%；内存消耗5.8MB，击败80.43%：\n\n```c++\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x<0)\n            return false;\n        int x_tmp = x;\n        long tmp = 0;\n        while(x_tmp)\n        {\n            tmp = tmp * 10 + x_tmp % 10;\n            x_tmp /= 10;\n        }\n        if (x == tmp)\n            return true;\n        else\n            return false;\n    }\n};\n```\n\n### 官解\n\n第一，考虑特殊情况，分别是负数和最后一位为0。第二，只要判断一半就够。对于如何鉴别这个一半的位置，只要对上面的代码稍作改动就可以。\n\n```c++\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x<0)   \n            return false;\n        if (x!=0 && x%10 ==0)   // 加入另一种特殊情况\n            return false;\n        int tmp = 0;    // 这个时候int就够了\n        while(x > tmp)\n        {\n            tmp = tmp * 10 + x % 10;\n            x /= 10;\n        }\n        // 第一种条件是位数为偶数，一分为二；第二种情况是位数为奇数\n        if (x == tmp || x == tmp/10)\n            return true;\n        else\n            return false;\n    }\n};\n```\n\n评论里说得好哇：\n\n“简单的题效率完全比不上题解，复杂的题完全不会 -.-”  by wanwenx\n\n😣\n\n## 13. 罗马数字转整数\n\n题目链接：[13. 罗马数字转整数 - 力扣（LeetCode）]( https://leetcode-cn.com/problems/roman-to-integer/submissions/)\n\n### 我的思路\n\n1. 定义一个函数，输入罗马字符，返回对应的数值；\n2. 分析罗马数字的规则：如果是正常计算的话，一个字符对应一个数，加起来就可以了；特殊情况只有后一位比当前位对应数值要大。那么，只要当前位置不是最后一位，就比较当前位置大小和下一位置大小。\n\n注：switch语句里要用break做当前分支的结束。不然即使满足条件，也还是会进入下一分支。\n\n代码用时12ms，击败66.55%；内存消耗5.9MB，击败89.62%：\n\n```c++\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        int len = s.length();\n        int i=0;\n        int now=0, next=0, result=0;\n        while(i<len)\n        {\n            now = trans(s[i]);\n            if(i == len-1)\n            {\n                result += now;\n                break;\n            }\n            next = trans(s[i+1]);\n            if(now<next)\n            {\n                result += next - now;\n                i += 2;\n                continue;                \n            }\n            result += now;\n            i++;\n        }\n        return result;\n    }\n    int trans(char ch)\n    {\n        int a=0;\n        switch(ch)\n        {\n            case 'I':\n                a = 1;\n                break;\n            case 'V':\n                a = 5;\n                break;\n            case 'X':\n                a = 10;\n                break;\n            case 'L':\n                a = 50;\n                break;\n            case 'C':\n                a = 100;\n                break;\n            case 'D':\n                a = 500;\n                break;\n            case 'M':\n                a = 1000;\n        }\n        return a;\n    }\n};\n```\n\n### 题解\n\n基本思路和我的方法差不多，有把switch函数换成哈希表的。\n\n```c++\nunordered_map<string, int> m = {{\"I\", 1}, {\"IV\", 3}, {\"IX\", 8}, {\"V\", 5}, {\"X\", 10}, {\"XL\", 30}, {\"XC\", 80}, {\"L\", 50}, {\"C\", 100}, {\"CD\", 300}, {\"CM\", 800}, {\"D\", 500}, {\"M\", 1000}};\n```\n\n一个作者说明得比我更清楚写，小数在左大数在右，则做减法，即IV中的I对应-1.\n\n\n\n","slug":"Leetcode-0221","published":1,"updated":"2021-02-21T15:02:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggr000s38t4htqkdhl1","content":"<p>回文数、罗马字符转数字</p>\n<span id=\"more\"></span>\n\n<h2 id=\"9-回文数\"><a href=\"#9-回文数\" class=\"headerlink\" title=\"9. 回文数\"></a>9. 回文数</h2><p>题目链接：<a href=\"https://leetcode-cn.com/problems/palindrome-number/\">LeetCode链接</a></p>\n<p>没有用字符串的方法来做。</p>\n<h3 id=\"我的思路\"><a href=\"#我的思路\" class=\"headerlink\" title=\"我的思路\"></a>我的思路</h3><ol>\n<li>依次取第一位和最后一位上的数字进行比较。后面的数字是好取，第一位数字不好取，问题复杂化了。</li>\n<li>从后面开始取数字，得到翻转过来的数字，然后比较一下是否相等。考虑到溢出：如果出现溢出，那么也肯定不是回文数，但是需要把翻转过来的数字类型定义为long。</li>\n</ol>\n<p>代码用时20ms，击败38.53%；内存消耗5.8MB，击败80.43%：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x_tmp = x;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x_tmp)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmp = tmp * <span class=\"number\">10</span> + x_tmp % <span class=\"number\">10</span>;</span><br><span class=\"line\">            x_tmp /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == tmp)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"官解\"><a href=\"#官解\" class=\"headerlink\" title=\"官解\"></a>官解</h3><p>第一，考虑特殊情况，分别是负数和最后一位为0。第二，只要判断一半就够。对于如何鉴别这个一半的位置，只要对上面的代码稍作改动就可以。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>)   </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x!=<span class=\"number\">0</span> &amp;&amp; x%<span class=\"number\">10</span> ==<span class=\"number\">0</span>)   <span class=\"comment\">// 加入另一种特殊情况</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;    <span class=\"comment\">// 这个时候int就够了</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x &gt; tmp)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmp = tmp * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">            x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 第一种条件是位数为偶数，一分为二；第二种情况是位数为奇数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == tmp || x == tmp/<span class=\"number\">10</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>评论里说得好哇：</p>\n<p>“简单的题效率完全比不上题解，复杂的题完全不会 -.-”  by wanwenx</p>\n<p>😣</p>\n<h2 id=\"13-罗马数字转整数\"><a href=\"#13-罗马数字转整数\" class=\"headerlink\" title=\"13. 罗马数字转整数\"></a>13. 罗马数字转整数</h2><p>题目链接：<a href=\"https://leetcode-cn.com/problems/roman-to-integer/submissions/\">13. 罗马数字转整数 - 力扣（LeetCode）</a></p>\n<h3 id=\"我的思路-1\"><a href=\"#我的思路-1\" class=\"headerlink\" title=\"我的思路\"></a>我的思路</h3><ol>\n<li>定义一个函数，输入罗马字符，返回对应的数值；</li>\n<li>分析罗马数字的规则：如果是正常计算的话，一个字符对应一个数，加起来就可以了；特殊情况只有后一位比当前位对应数值要大。那么，只要当前位置不是最后一位，就比较当前位置大小和下一位置大小。</li>\n</ol>\n<p>注：switch语句里要用break做当前分支的结束。不然即使满足条件，也还是会进入下一分支。</p>\n<p>代码用时12ms，击败66.55%；内存消耗5.9MB，击败89.62%：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> now=<span class=\"number\">0</span>, next=<span class=\"number\">0</span>, result=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;len)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            now = <span class=\"built_in\">trans</span>(s[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == len<span class=\"number\">-1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result += now;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            next = <span class=\"built_in\">trans</span>(s[i+<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(now&lt;next)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result += next - now;</span><br><span class=\"line\">                i += <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result += now;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">trans</span><span class=\"params\">(<span class=\"keyword\">char</span> ch)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">switch</span></span>(ch)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;I&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;V&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">5</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;X&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">10</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;L&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">50</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;C&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">100</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;D&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">500</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;M&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">1000</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>基本思路和我的方法差不多，有把switch函数换成哈希表的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unordered_map&lt;string, <span class=\"keyword\">int</span>&gt; m = &#123;&#123;<span class=\"string\">&quot;I&quot;</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"string\">&quot;IV&quot;</span>, <span class=\"number\">3</span>&#125;, &#123;<span class=\"string\">&quot;IX&quot;</span>, <span class=\"number\">8</span>&#125;, &#123;<span class=\"string\">&quot;V&quot;</span>, <span class=\"number\">5</span>&#125;, &#123;<span class=\"string\">&quot;X&quot;</span>, <span class=\"number\">10</span>&#125;, &#123;<span class=\"string\">&quot;XL&quot;</span>, <span class=\"number\">30</span>&#125;, &#123;<span class=\"string\">&quot;XC&quot;</span>, <span class=\"number\">80</span>&#125;, &#123;<span class=\"string\">&quot;L&quot;</span>, <span class=\"number\">50</span>&#125;, &#123;<span class=\"string\">&quot;C&quot;</span>, <span class=\"number\">100</span>&#125;, &#123;<span class=\"string\">&quot;CD&quot;</span>, <span class=\"number\">300</span>&#125;, &#123;<span class=\"string\">&quot;CM&quot;</span>, <span class=\"number\">800</span>&#125;, &#123;<span class=\"string\">&quot;D&quot;</span>, <span class=\"number\">500</span>&#125;, &#123;<span class=\"string\">&quot;M&quot;</span>, <span class=\"number\">1000</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一个作者说明得比我更清楚写，小数在左大数在右，则做减法，即IV中的I对应-1.</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>回文数、罗马字符转数字</p>","more":"<h2 id=\"9-回文数\"><a href=\"#9-回文数\" class=\"headerlink\" title=\"9. 回文数\"></a>9. 回文数</h2><p>题目链接：<a href=\"https://leetcode-cn.com/problems/palindrome-number/\">LeetCode链接</a></p>\n<p>没有用字符串的方法来做。</p>\n<h3 id=\"我的思路\"><a href=\"#我的思路\" class=\"headerlink\" title=\"我的思路\"></a>我的思路</h3><ol>\n<li>依次取第一位和最后一位上的数字进行比较。后面的数字是好取，第一位数字不好取，问题复杂化了。</li>\n<li>从后面开始取数字，得到翻转过来的数字，然后比较一下是否相等。考虑到溢出：如果出现溢出，那么也肯定不是回文数，但是需要把翻转过来的数字类型定义为long。</li>\n</ol>\n<p>代码用时20ms，击败38.53%；内存消耗5.8MB，击败80.43%：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x_tmp = x;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x_tmp)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmp = tmp * <span class=\"number\">10</span> + x_tmp % <span class=\"number\">10</span>;</span><br><span class=\"line\">            x_tmp /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == tmp)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"官解\"><a href=\"#官解\" class=\"headerlink\" title=\"官解\"></a>官解</h3><p>第一，考虑特殊情况，分别是负数和最后一位为0。第二，只要判断一半就够。对于如何鉴别这个一半的位置，只要对上面的代码稍作改动就可以。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>)   </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x!=<span class=\"number\">0</span> &amp;&amp; x%<span class=\"number\">10</span> ==<span class=\"number\">0</span>)   <span class=\"comment\">// 加入另一种特殊情况</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;    <span class=\"comment\">// 这个时候int就够了</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x &gt; tmp)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmp = tmp * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">            x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 第一种条件是位数为偶数，一分为二；第二种情况是位数为奇数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == tmp || x == tmp/<span class=\"number\">10</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>评论里说得好哇：</p>\n<p>“简单的题效率完全比不上题解，复杂的题完全不会 -.-”  by wanwenx</p>\n<p>😣</p>\n<h2 id=\"13-罗马数字转整数\"><a href=\"#13-罗马数字转整数\" class=\"headerlink\" title=\"13. 罗马数字转整数\"></a>13. 罗马数字转整数</h2><p>题目链接：<a href=\"https://leetcode-cn.com/problems/roman-to-integer/submissions/\">13. 罗马数字转整数 - 力扣（LeetCode）</a></p>\n<h3 id=\"我的思路-1\"><a href=\"#我的思路-1\" class=\"headerlink\" title=\"我的思路\"></a>我的思路</h3><ol>\n<li>定义一个函数，输入罗马字符，返回对应的数值；</li>\n<li>分析罗马数字的规则：如果是正常计算的话，一个字符对应一个数，加起来就可以了；特殊情况只有后一位比当前位对应数值要大。那么，只要当前位置不是最后一位，就比较当前位置大小和下一位置大小。</li>\n</ol>\n<p>注：switch语句里要用break做当前分支的结束。不然即使满足条件，也还是会进入下一分支。</p>\n<p>代码用时12ms，击败66.55%；内存消耗5.9MB，击败89.62%：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> now=<span class=\"number\">0</span>, next=<span class=\"number\">0</span>, result=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;len)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            now = <span class=\"built_in\">trans</span>(s[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == len<span class=\"number\">-1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result += now;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            next = <span class=\"built_in\">trans</span>(s[i+<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(now&lt;next)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result += next - now;</span><br><span class=\"line\">                i += <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result += now;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">trans</span><span class=\"params\">(<span class=\"keyword\">char</span> ch)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">switch</span></span>(ch)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;I&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;V&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">5</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;X&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">10</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;L&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">50</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;C&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">100</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;D&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">500</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;M&#x27;</span>:</span><br><span class=\"line\">                a = <span class=\"number\">1000</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>基本思路和我的方法差不多，有把switch函数换成哈希表的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unordered_map&lt;string, <span class=\"keyword\">int</span>&gt; m = &#123;&#123;<span class=\"string\">&quot;I&quot;</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"string\">&quot;IV&quot;</span>, <span class=\"number\">3</span>&#125;, &#123;<span class=\"string\">&quot;IX&quot;</span>, <span class=\"number\">8</span>&#125;, &#123;<span class=\"string\">&quot;V&quot;</span>, <span class=\"number\">5</span>&#125;, &#123;<span class=\"string\">&quot;X&quot;</span>, <span class=\"number\">10</span>&#125;, &#123;<span class=\"string\">&quot;XL&quot;</span>, <span class=\"number\">30</span>&#125;, &#123;<span class=\"string\">&quot;XC&quot;</span>, <span class=\"number\">80</span>&#125;, &#123;<span class=\"string\">&quot;L&quot;</span>, <span class=\"number\">50</span>&#125;, &#123;<span class=\"string\">&quot;C&quot;</span>, <span class=\"number\">100</span>&#125;, &#123;<span class=\"string\">&quot;CD&quot;</span>, <span class=\"number\">300</span>&#125;, &#123;<span class=\"string\">&quot;CM&quot;</span>, <span class=\"number\">800</span>&#125;, &#123;<span class=\"string\">&quot;D&quot;</span>, <span class=\"number\">500</span>&#125;, &#123;<span class=\"string\">&quot;M&quot;</span>, <span class=\"number\">1000</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一个作者说明得比我更清楚写，小数在左大数在右，则做减法，即IV中的I对应-1.</p>"},{"title":"Leetcode刷题之动态规划","date":"2022-04-03T14:43:22.000Z","updated":"2022-04-03T14:43:22.000Z","_content":"\n终于开始动态规划啦！啊好难的动态规划~目前做了一些题，持续更新！\n\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/emoji/braveDog.jpg\" alt=\"braveDog\" style=\"zoom:50%;\" />\n\n<!--more-->\n\n- 状态压缩：留个档https://zhuanlan.zhihu.com/p/131585177\n- 题单：[花花酱 LeetCode Problem List 题目列表](https://zxi.mytechroad.com/blog/leetcode-problem-categories/)\n- [代码随想录](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)\n\n# 背包问题\n\n什么问题适合用背包来解决呢？\n\n我认为是给了**一组元素（数字、字符、字符串）**（放进背包的东西），让你使用其中的元素，来**满足一定的要求**（背包容量）。这些元素可以是每个只能最多用一次（01背包），也可以是每个可以用无数次（完全背包）。这一类问题可以考虑背包。\n\n## 01背包\n\n有n件物品和一个最多只能背w重量的背包，每件物品只能用一次，求怎么放才能使背包内物品价值最大。\n\n解决问题的关键在于：\n\n1. 当然是想到问题可以用背包来解~然后把问题转换为背包问题，我觉得这一步是最难的，因为题目形式千变万化\n2. 设计背包。\n\n### 中等\n\n#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n\n把问题转换为：数组中是否有一组数字，它们的和为sum/2。\n\n#### [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)\n\n把问题转换为：把石头分成两堆，这两堆和的差尽可能接近。\n\n或者可以看成：把石头重量加上正负号，求这些数列出式子后，和最接近零的。（其实也是在找一堆数字相加可以尽量等于sum/2。）\n\n#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)\n\n416、1049、494这三道题比较类似。\n\n特别和第1049题很像。\n\n#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)\n\n和上面三道题不一样的地方是，**背包有两个容量（1的数量和0的数量）**。\n\n想了半天用二维dp如何表示，也没想出来。参考题解用三维，然后进一步优化为二维。\n\n`dp[i][j][k]`表示在下标`0-i`中选择字符串，字符串中`0`的数量不超过`j`，`1`的数量不超过`k`。状态转移有两种情况，当不选择第`i`个字符串时，`dp[i][j][k] = dp[i-1][j][k]`时；当选择第`i`个字符串时，`dp[i][j][k] = dp[i-1][j-zero[i]][k-one[i]]`。\n\n考虑初始化：多设置一行，第一行为空串也不选择，整行为0。\n\n## 完全背包\n\n### 中等\n\n#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)\n\n相当于求组合数，需要注意的是每种硬币不能重复选择，即(1, 5)和(5, 1)只能出现其中一种。这个体现在双重for循环求解时，外层for循环对硬币面额的循环，内层for循环对硬币总和的循环。而如果反过来，就会产生重复了，列表也可以看出来。\n\n#### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)\n\n这道题虽然标题叫求组合的总和，实际上看一下测试用例就知道在找排列数。跟518思路差不多，就是518的两层循环内外交换一下。\n\nPS. 我感觉这样求组合数、排列数的用动态规划（背包）即可解决，如果需要具体的排列组合方式，就需要回溯。\n\n#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)\n\n518在求组合数，这道题求最少的硬币个数，状态转移方程不同一点。在求`dp[i][j]`时，518题的状态转移方程为：`dp[i][j]=dp[i-1][j] + dp[j-1][j-coins[i]]`。\n\n在这道题中，状态转移方程为：`dp[i][j] = min(dp[i-1][j], dp[i-1][j-coins[i]]+1)`。然后考虑初始化，dp数组的大小为`dp[m+1][n+1]`， `dp[0][0]`表示一个硬币也不取，总和为0时需要的硬币个数（注意不是组合数，组合数即取法为1），即 `dp[0][0] = 0`。其他的先初始化成取不到的数字，用`Integer.MAX_VALUE`即可。\n\n# 简单\n\n## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/) ☆\n\n> 有一个人学DP不会爬楼梯的我都会伤心的OK？\n\n递归方法容易想到，但是会超时。分析一下，先想到可以用一个长度为N的数组来保存每一次结果。再进一步分析一下可以想到其实保存两个数字就够啦。\n\n**动态规划 vs 递归**（[参考](https://leetcode-cn.com/problems/climbing-stairs/solution/cong-zhi-jue-si-wei-fen-xi-dong-tai-gui-hua-si-lu-/)）\n\n将原问题分为子问题来解决的，通常有两种思路：自顶向下和自底向上。递归就是自顶向下的思想，再层层向上返回结果，递归会出现重复解决子问题的情况因此效率较低。而动态规划是自底向上的思想。\n\n虽然动态规划看上去更好用，但是递归也有其优势。比如动态规划一般只保存结果，而不保存路径；但递归用回溯可以得到路径。\n\n变形体：[746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)\n\n## [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)\n\n和爬楼梯解决方法类似。在读题的时候卡了一下emm，然后在计算代价的时候稍微卡了一下。还是自底向上的思路，令f(i)为爬到第i个台阶时需要的代价。$f(i)=min(f(i-1)+cost(i-1), f(i-2)+cost(i-2))$，得到这个公式之后就比较清晰了。\n\n## [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)\n\n这叫泰波那契数，还不是斐波那契数，哈哈，但是解法是类似的。\n\n来点不一样的方法看看叭：[矩阵快速幂](https://leetcode-cn.com/problems/n-th-tribonacci-number/solution/gong-shui-san-xie-yi-ti-si-jie-die-dai-d-m1ie/)\n\n## [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)\n\n用前缀和。\n\n来点不一样的方法看看叭：[分块算法](https://leetcode-cn.com/problems/range-sum-query-immutable/solution/ni-yong-yuan-ke-yi-xiang-xin-fen-kuai-su-ugou/)\n\n# 中等\n\n## [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)\n\n详见二分篇\n\n## [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)\n\n参考题解：[「手画图解」剖析三种解法: DFS, BFS, 动态规划 |139.单词拆分 - 单词拆分 - 力扣（LeetCode）](https://leetcode-cn.com/problems/word-break/solution/shou-hui-tu-jie-san-chong-fang-fa-dfs-bfs-dong-tai/)\n\n**方法1-DFS**\n\n将问题进行拆分，以leetcode为例，拆分为：1. `l`是否在单词表中，剩余子串是否能分解；2. `le`是否在单词表中，剩余子串是否能分解；3. ...\n\n用DFS回溯即可。\n\n\n\n## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)\n\n发现做了一些dp题目之后有点思路了！\n\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/emoji/large.jpg\" alt=\"gejvOpen\" style=\"zoom: 25%;\" />\n\n题目关键点：不能连续偷。\n\n设`dp[i]`表示前i家能取得的最高金额。尝试写一下状态转移公式，既然是求最大，应该是一些状态来比较。如果不偷第i家，就是`dp[i-1]`；如果偷第i家，那就不能偷第`i-1`家，但是第`i-2`家要偷，那就前`i-2`家取得的最高金额加上第`i`家取得的金额，也就是`dp[i-2]+nums[i]`。状态转移方程：`dp[i] = max(dp[i-1], dp[i-2]+nums[i])`。\n\n再考虑初始化，这里初始化需要i=0时，即一家也不偷，显然为0。再看状态转移方程中，其实当前状态`dp[i]`只跟`dp[i-1]`和`dp[i-2]`有关，所以只需要两个变量来保存中间结果就可以了。\n\n## [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)\n\n跟212题差别在于首尾两家是相连的。\n\n我想了一会没有想出来怎么解决。像这样**环**的有点不会处理，之前还做到过一个[503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)，这道题中是对**数组循环遍历**，这道题目里对数组遍历两次就可以。\n\n题解：拆成偷第一家和偷最后一家两种情况，分别求出两种情况下能取得的最大金额，两者之中更大的那个就是答案。\n\n## [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)\n\n这道题能想到的解题思路：对于当前节点，如果我偷当前节点，那就不能偷它的左右节点；如果我不偷，那就左右节点最大金额之和。但是我WA了... 联想到动态规划的思想：记忆化来减少搜索时间。我们可以保存已经求过的节点的值。\n\n再更进一步，我们可以保存两种情况的值（我想到了，但是没有想到有什么方法来保存。提醒自己一下：**不是作为值保存在节点中，而是作为函数返回值来传递**！）。也就是保存偷当前节点能取到的最大金额和不偷当前节点能取到的最大金额。\n\n看了题解又有种思路打开的感觉，我觉得很妙，记一笔。\n\n## [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)\n\n和[343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)是同一道题\n\n好神奇，没有太理解！\n\n**DP**\n\ndp[i]为长度为i的绳子，切割后的最大乘积。状态转移公式：`dp[i]=max(j*(i-j), j*dp[i-j])`。\n\n**贪心**\n\n尽量切成三段。\n","source":"_posts/Leetcode刷题之动态规划.md","raw":"---\ntitle: Leetcode刷题之动态规划\ndate: 2022-04-03 22:43:22\nupdated: 2022-04-03 22:43:22\ncategories:\ntags:\n---\n\n终于开始动态规划啦！啊好难的动态规划~目前做了一些题，持续更新！\n\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/emoji/braveDog.jpg\" alt=\"braveDog\" style=\"zoom:50%;\" />\n\n<!--more-->\n\n- 状态压缩：留个档https://zhuanlan.zhihu.com/p/131585177\n- 题单：[花花酱 LeetCode Problem List 题目列表](https://zxi.mytechroad.com/blog/leetcode-problem-categories/)\n- [代码随想录](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)\n\n# 背包问题\n\n什么问题适合用背包来解决呢？\n\n我认为是给了**一组元素（数字、字符、字符串）**（放进背包的东西），让你使用其中的元素，来**满足一定的要求**（背包容量）。这些元素可以是每个只能最多用一次（01背包），也可以是每个可以用无数次（完全背包）。这一类问题可以考虑背包。\n\n## 01背包\n\n有n件物品和一个最多只能背w重量的背包，每件物品只能用一次，求怎么放才能使背包内物品价值最大。\n\n解决问题的关键在于：\n\n1. 当然是想到问题可以用背包来解~然后把问题转换为背包问题，我觉得这一步是最难的，因为题目形式千变万化\n2. 设计背包。\n\n### 中等\n\n#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n\n把问题转换为：数组中是否有一组数字，它们的和为sum/2。\n\n#### [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)\n\n把问题转换为：把石头分成两堆，这两堆和的差尽可能接近。\n\n或者可以看成：把石头重量加上正负号，求这些数列出式子后，和最接近零的。（其实也是在找一堆数字相加可以尽量等于sum/2。）\n\n#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)\n\n416、1049、494这三道题比较类似。\n\n特别和第1049题很像。\n\n#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)\n\n和上面三道题不一样的地方是，**背包有两个容量（1的数量和0的数量）**。\n\n想了半天用二维dp如何表示，也没想出来。参考题解用三维，然后进一步优化为二维。\n\n`dp[i][j][k]`表示在下标`0-i`中选择字符串，字符串中`0`的数量不超过`j`，`1`的数量不超过`k`。状态转移有两种情况，当不选择第`i`个字符串时，`dp[i][j][k] = dp[i-1][j][k]`时；当选择第`i`个字符串时，`dp[i][j][k] = dp[i-1][j-zero[i]][k-one[i]]`。\n\n考虑初始化：多设置一行，第一行为空串也不选择，整行为0。\n\n## 完全背包\n\n### 中等\n\n#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)\n\n相当于求组合数，需要注意的是每种硬币不能重复选择，即(1, 5)和(5, 1)只能出现其中一种。这个体现在双重for循环求解时，外层for循环对硬币面额的循环，内层for循环对硬币总和的循环。而如果反过来，就会产生重复了，列表也可以看出来。\n\n#### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)\n\n这道题虽然标题叫求组合的总和，实际上看一下测试用例就知道在找排列数。跟518思路差不多，就是518的两层循环内外交换一下。\n\nPS. 我感觉这样求组合数、排列数的用动态规划（背包）即可解决，如果需要具体的排列组合方式，就需要回溯。\n\n#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)\n\n518在求组合数，这道题求最少的硬币个数，状态转移方程不同一点。在求`dp[i][j]`时，518题的状态转移方程为：`dp[i][j]=dp[i-1][j] + dp[j-1][j-coins[i]]`。\n\n在这道题中，状态转移方程为：`dp[i][j] = min(dp[i-1][j], dp[i-1][j-coins[i]]+1)`。然后考虑初始化，dp数组的大小为`dp[m+1][n+1]`， `dp[0][0]`表示一个硬币也不取，总和为0时需要的硬币个数（注意不是组合数，组合数即取法为1），即 `dp[0][0] = 0`。其他的先初始化成取不到的数字，用`Integer.MAX_VALUE`即可。\n\n# 简单\n\n## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/) ☆\n\n> 有一个人学DP不会爬楼梯的我都会伤心的OK？\n\n递归方法容易想到，但是会超时。分析一下，先想到可以用一个长度为N的数组来保存每一次结果。再进一步分析一下可以想到其实保存两个数字就够啦。\n\n**动态规划 vs 递归**（[参考](https://leetcode-cn.com/problems/climbing-stairs/solution/cong-zhi-jue-si-wei-fen-xi-dong-tai-gui-hua-si-lu-/)）\n\n将原问题分为子问题来解决的，通常有两种思路：自顶向下和自底向上。递归就是自顶向下的思想，再层层向上返回结果，递归会出现重复解决子问题的情况因此效率较低。而动态规划是自底向上的思想。\n\n虽然动态规划看上去更好用，但是递归也有其优势。比如动态规划一般只保存结果，而不保存路径；但递归用回溯可以得到路径。\n\n变形体：[746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)\n\n## [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)\n\n和爬楼梯解决方法类似。在读题的时候卡了一下emm，然后在计算代价的时候稍微卡了一下。还是自底向上的思路，令f(i)为爬到第i个台阶时需要的代价。$f(i)=min(f(i-1)+cost(i-1), f(i-2)+cost(i-2))$，得到这个公式之后就比较清晰了。\n\n## [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)\n\n这叫泰波那契数，还不是斐波那契数，哈哈，但是解法是类似的。\n\n来点不一样的方法看看叭：[矩阵快速幂](https://leetcode-cn.com/problems/n-th-tribonacci-number/solution/gong-shui-san-xie-yi-ti-si-jie-die-dai-d-m1ie/)\n\n## [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)\n\n用前缀和。\n\n来点不一样的方法看看叭：[分块算法](https://leetcode-cn.com/problems/range-sum-query-immutable/solution/ni-yong-yuan-ke-yi-xiang-xin-fen-kuai-su-ugou/)\n\n# 中等\n\n## [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)\n\n详见二分篇\n\n## [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)\n\n参考题解：[「手画图解」剖析三种解法: DFS, BFS, 动态规划 |139.单词拆分 - 单词拆分 - 力扣（LeetCode）](https://leetcode-cn.com/problems/word-break/solution/shou-hui-tu-jie-san-chong-fang-fa-dfs-bfs-dong-tai/)\n\n**方法1-DFS**\n\n将问题进行拆分，以leetcode为例，拆分为：1. `l`是否在单词表中，剩余子串是否能分解；2. `le`是否在单词表中，剩余子串是否能分解；3. ...\n\n用DFS回溯即可。\n\n\n\n## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)\n\n发现做了一些dp题目之后有点思路了！\n\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/emoji/large.jpg\" alt=\"gejvOpen\" style=\"zoom: 25%;\" />\n\n题目关键点：不能连续偷。\n\n设`dp[i]`表示前i家能取得的最高金额。尝试写一下状态转移公式，既然是求最大，应该是一些状态来比较。如果不偷第i家，就是`dp[i-1]`；如果偷第i家，那就不能偷第`i-1`家，但是第`i-2`家要偷，那就前`i-2`家取得的最高金额加上第`i`家取得的金额，也就是`dp[i-2]+nums[i]`。状态转移方程：`dp[i] = max(dp[i-1], dp[i-2]+nums[i])`。\n\n再考虑初始化，这里初始化需要i=0时，即一家也不偷，显然为0。再看状态转移方程中，其实当前状态`dp[i]`只跟`dp[i-1]`和`dp[i-2]`有关，所以只需要两个变量来保存中间结果就可以了。\n\n## [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)\n\n跟212题差别在于首尾两家是相连的。\n\n我想了一会没有想出来怎么解决。像这样**环**的有点不会处理，之前还做到过一个[503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)，这道题中是对**数组循环遍历**，这道题目里对数组遍历两次就可以。\n\n题解：拆成偷第一家和偷最后一家两种情况，分别求出两种情况下能取得的最大金额，两者之中更大的那个就是答案。\n\n## [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)\n\n这道题能想到的解题思路：对于当前节点，如果我偷当前节点，那就不能偷它的左右节点；如果我不偷，那就左右节点最大金额之和。但是我WA了... 联想到动态规划的思想：记忆化来减少搜索时间。我们可以保存已经求过的节点的值。\n\n再更进一步，我们可以保存两种情况的值（我想到了，但是没有想到有什么方法来保存。提醒自己一下：**不是作为值保存在节点中，而是作为函数返回值来传递**！）。也就是保存偷当前节点能取到的最大金额和不偷当前节点能取到的最大金额。\n\n看了题解又有种思路打开的感觉，我觉得很妙，记一笔。\n\n## [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)\n\n和[343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)是同一道题\n\n好神奇，没有太理解！\n\n**DP**\n\ndp[i]为长度为i的绳子，切割后的最大乘积。状态转移公式：`dp[i]=max(j*(i-j), j*dp[i-j])`。\n\n**贪心**\n\n尽量切成三段。\n","slug":"Leetcode刷题之动态规划","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggs000v38t4ekzvhtf9","content":"<p>终于开始动态规划啦！啊好难的动态规划~目前做了一些题，持续更新！</p>\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/emoji/braveDog.jpg\" alt=\"braveDog\" style=\"zoom:50%;\" />\n\n<span id=\"more\"></span>\n\n<ul>\n<li>状态压缩：留个档<a href=\"https://zhuanlan.zhihu.com/p/131585177\">https://zhuanlan.zhihu.com/p/131585177</a></li>\n<li>题单：<a href=\"https://zxi.mytechroad.com/blog/leetcode-problem-categories/\">花花酱 LeetCode Problem List 题目列表</a></li>\n<li><a href=\"https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html\">代码随想录</a></li>\n</ul>\n<h1 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h1><p>什么问题适合用背包来解决呢？</p>\n<p>我认为是给了<strong>一组元素（数字、字符、字符串）</strong>（放进背包的东西），让你使用其中的元素，来<strong>满足一定的要求</strong>（背包容量）。这些元素可以是每个只能最多用一次（01背包），也可以是每个可以用无数次（完全背包）。这一类问题可以考虑背包。</p>\n<h2 id=\"01背包\"><a href=\"#01背包\" class=\"headerlink\" title=\"01背包\"></a>01背包</h2><p>有n件物品和一个最多只能背w重量的背包，每件物品只能用一次，求怎么放才能使背包内物品价值最大。</p>\n<p>解决问题的关键在于：</p>\n<ol>\n<li>当然是想到问题可以用背包来解~然后把问题转换为背包问题，我觉得这一步是最难的，因为题目形式千变万化</li>\n<li>设计背包。</li>\n</ol>\n<h3 id=\"中等\"><a href=\"#中等\" class=\"headerlink\" title=\"中等\"></a>中等</h3><h4 id=\"416-分割等和子集\"><a href=\"#416-分割等和子集\" class=\"headerlink\" title=\"416. 分割等和子集\"></a><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\">416. 分割等和子集</a></h4><p>把问题转换为：数组中是否有一组数字，它们的和为sum/2。</p>\n<h4 id=\"1049-最后一块石头的重量-II\"><a href=\"#1049-最后一块石头的重量-II\" class=\"headerlink\" title=\"1049. 最后一块石头的重量 II\"></a><a href=\"https://leetcode-cn.com/problems/last-stone-weight-ii/\">1049. 最后一块石头的重量 II</a></h4><p>把问题转换为：把石头分成两堆，这两堆和的差尽可能接近。</p>\n<p>或者可以看成：把石头重量加上正负号，求这些数列出式子后，和最接近零的。（其实也是在找一堆数字相加可以尽量等于sum/2。）</p>\n<h4 id=\"494-目标和\"><a href=\"#494-目标和\" class=\"headerlink\" title=\"494. 目标和\"></a><a href=\"https://leetcode-cn.com/problems/target-sum/\">494. 目标和</a></h4><p>416、1049、494这三道题比较类似。</p>\n<p>特别和第1049题很像。</p>\n<h4 id=\"474-一和零\"><a href=\"#474-一和零\" class=\"headerlink\" title=\"474. 一和零\"></a><a href=\"https://leetcode-cn.com/problems/ones-and-zeroes/\">474. 一和零</a></h4><p>和上面三道题不一样的地方是，<strong>背包有两个容量（1的数量和0的数量）</strong>。</p>\n<p>想了半天用二维dp如何表示，也没想出来。参考题解用三维，然后进一步优化为二维。</p>\n<p><code>dp[i][j][k]</code>表示在下标<code>0-i</code>中选择字符串，字符串中<code>0</code>的数量不超过<code>j</code>，<code>1</code>的数量不超过<code>k</code>。状态转移有两种情况，当不选择第<code>i</code>个字符串时，<code>dp[i][j][k] = dp[i-1][j][k]</code>时；当选择第<code>i</code>个字符串时，<code>dp[i][j][k] = dp[i-1][j-zero[i]][k-one[i]]</code>。</p>\n<p>考虑初始化：多设置一行，第一行为空串也不选择，整行为0。</p>\n<h2 id=\"完全背包\"><a href=\"#完全背包\" class=\"headerlink\" title=\"完全背包\"></a>完全背包</h2><h3 id=\"中等-1\"><a href=\"#中等-1\" class=\"headerlink\" title=\"中等\"></a>中等</h3><h4 id=\"518-零钱兑换-II\"><a href=\"#518-零钱兑换-II\" class=\"headerlink\" title=\"518. 零钱兑换 II\"></a><a href=\"https://leetcode-cn.com/problems/coin-change-2/\">518. 零钱兑换 II</a></h4><p>相当于求组合数，需要注意的是每种硬币不能重复选择，即(1, 5)和(5, 1)只能出现其中一种。这个体现在双重for循环求解时，外层for循环对硬币面额的循环，内层for循环对硬币总和的循环。而如果反过来，就会产生重复了，列表也可以看出来。</p>\n<h4 id=\"377-组合总和-Ⅳ\"><a href=\"#377-组合总和-Ⅳ\" class=\"headerlink\" title=\"377. 组合总和 Ⅳ\"></a><a href=\"https://leetcode-cn.com/problems/combination-sum-iv/\">377. 组合总和 Ⅳ</a></h4><p>这道题虽然标题叫求组合的总和，实际上看一下测试用例就知道在找排列数。跟518思路差不多，就是518的两层循环内外交换一下。</p>\n<p>PS. 我感觉这样求组合数、排列数的用动态规划（背包）即可解决，如果需要具体的排列组合方式，就需要回溯。</p>\n<h4 id=\"322-零钱兑换\"><a href=\"#322-零钱兑换\" class=\"headerlink\" title=\"322. 零钱兑换\"></a><a href=\"https://leetcode-cn.com/problems/coin-change/\">322. 零钱兑换</a></h4><p>518在求组合数，这道题求最少的硬币个数，状态转移方程不同一点。在求<code>dp[i][j]</code>时，518题的状态转移方程为：<code>dp[i][j]=dp[i-1][j] + dp[j-1][j-coins[i]]</code>。</p>\n<p>在这道题中，状态转移方程为：<code>dp[i][j] = min(dp[i-1][j], dp[i-1][j-coins[i]]+1)</code>。然后考虑初始化，dp数组的大小为<code>dp[m+1][n+1]</code>， <code>dp[0][0]</code>表示一个硬币也不取，总和为0时需要的硬币个数（注意不是组合数，组合数即取法为1），即 <code>dp[0][0] = 0</code>。其他的先初始化成取不到的数字，用<code>Integer.MAX_VALUE</code>即可。</p>\n<h1 id=\"简单\"><a href=\"#简单\" class=\"headerlink\" title=\"简单\"></a>简单</h1><h2 id=\"70-爬楼梯-☆\"><a href=\"#70-爬楼梯-☆\" class=\"headerlink\" title=\"70. 爬楼梯 ☆\"></a><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">70. 爬楼梯</a> ☆</h2><blockquote>\n<p>有一个人学DP不会爬楼梯的我都会伤心的OK？</p>\n</blockquote>\n<p>递归方法容易想到，但是会超时。分析一下，先想到可以用一个长度为N的数组来保存每一次结果。再进一步分析一下可以想到其实保存两个数字就够啦。</p>\n<p><strong>动态规划 vs 递归</strong>（<a href=\"https://leetcode-cn.com/problems/climbing-stairs/solution/cong-zhi-jue-si-wei-fen-xi-dong-tai-gui-hua-si-lu-/\">参考</a>）</p>\n<p>将原问题分为子问题来解决的，通常有两种思路：自顶向下和自底向上。递归就是自顶向下的思想，再层层向上返回结果，递归会出现重复解决子问题的情况因此效率较低。而动态规划是自底向上的思想。</p>\n<p>虽然动态规划看上去更好用，但是递归也有其优势。比如动态规划一般只保存结果，而不保存路径；但递归用回溯可以得到路径。</p>\n<p>变形体：<a href=\"https://leetcode-cn.com/problems/min-cost-climbing-stairs/\">746. 使用最小花费爬楼梯</a></p>\n<h2 id=\"746-使用最小花费爬楼梯\"><a href=\"#746-使用最小花费爬楼梯\" class=\"headerlink\" title=\"746. 使用最小花费爬楼梯\"></a><a href=\"https://leetcode-cn.com/problems/min-cost-climbing-stairs/\">746. 使用最小花费爬楼梯</a></h2><p>和爬楼梯解决方法类似。在读题的时候卡了一下emm，然后在计算代价的时候稍微卡了一下。还是自底向上的思路，令f(i)为爬到第i个台阶时需要的代价。$f(i)=min(f(i-1)+cost(i-1), f(i-2)+cost(i-2))$，得到这个公式之后就比较清晰了。</p>\n<h2 id=\"1137-第-N-个泰波那契数\"><a href=\"#1137-第-N-个泰波那契数\" class=\"headerlink\" title=\"1137. 第 N 个泰波那契数\"></a><a href=\"https://leetcode-cn.com/problems/n-th-tribonacci-number/\">1137. 第 N 个泰波那契数</a></h2><p>这叫泰波那契数，还不是斐波那契数，哈哈，但是解法是类似的。</p>\n<p>来点不一样的方法看看叭：<a href=\"https://leetcode-cn.com/problems/n-th-tribonacci-number/solution/gong-shui-san-xie-yi-ti-si-jie-die-dai-d-m1ie/\">矩阵快速幂</a></p>\n<h2 id=\"303-区域和检索-数组不可变\"><a href=\"#303-区域和检索-数组不可变\" class=\"headerlink\" title=\"303. 区域和检索 - 数组不可变\"></a><a href=\"https://leetcode-cn.com/problems/range-sum-query-immutable/\">303. 区域和检索 - 数组不可变</a></h2><p>用前缀和。</p>\n<p>来点不一样的方法看看叭：<a href=\"https://leetcode-cn.com/problems/range-sum-query-immutable/solution/ni-yong-yuan-ke-yi-xiang-xin-fen-kuai-su-ugou/\">分块算法</a></p>\n<h1 id=\"中等-2\"><a href=\"#中等-2\" class=\"headerlink\" title=\"中等\"></a>中等</h1><h2 id=\"300-最长递增子序列\"><a href=\"#300-最长递增子序列\" class=\"headerlink\" title=\"300. 最长递增子序列\"></a><a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\">300. 最长递增子序列</a></h2><p>详见二分篇</p>\n<h2 id=\"139-单词拆分\"><a href=\"#139-单词拆分\" class=\"headerlink\" title=\"139. 单词拆分\"></a><a href=\"https://leetcode-cn.com/problems/word-break/\">139. 单词拆分</a></h2><p>参考题解：<a href=\"https://leetcode-cn.com/problems/word-break/solution/shou-hui-tu-jie-san-chong-fang-fa-dfs-bfs-dong-tai/\">「手画图解」剖析三种解法: DFS, BFS, 动态规划 |139.单词拆分 - 单词拆分 - 力扣（LeetCode）</a></p>\n<p><strong>方法1-DFS</strong></p>\n<p>将问题进行拆分，以leetcode为例，拆分为：1. <code>l</code>是否在单词表中，剩余子串是否能分解；2. <code>le</code>是否在单词表中，剩余子串是否能分解；3. …</p>\n<p>用DFS回溯即可。</p>\n<h2 id=\"198-打家劫舍\"><a href=\"#198-打家劫舍\" class=\"headerlink\" title=\"198. 打家劫舍\"></a><a href=\"https://leetcode-cn.com/problems/house-robber/\">198. 打家劫舍</a></h2><p>发现做了一些dp题目之后有点思路了！</p>\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/emoji/large.jpg\" alt=\"gejvOpen\" style=\"zoom: 25%;\" />\n\n<p>题目关键点：不能连续偷。</p>\n<p>设<code>dp[i]</code>表示前i家能取得的最高金额。尝试写一下状态转移公式，既然是求最大，应该是一些状态来比较。如果不偷第i家，就是<code>dp[i-1]</code>；如果偷第i家，那就不能偷第<code>i-1</code>家，但是第<code>i-2</code>家要偷，那就前<code>i-2</code>家取得的最高金额加上第<code>i</code>家取得的金额，也就是<code>dp[i-2]+nums[i]</code>。状态转移方程：<code>dp[i] = max(dp[i-1], dp[i-2]+nums[i])</code>。</p>\n<p>再考虑初始化，这里初始化需要i=0时，即一家也不偷，显然为0。再看状态转移方程中，其实当前状态<code>dp[i]</code>只跟<code>dp[i-1]</code>和<code>dp[i-2]</code>有关，所以只需要两个变量来保存中间结果就可以了。</p>\n<h2 id=\"213-打家劫舍-II\"><a href=\"#213-打家劫舍-II\" class=\"headerlink\" title=\"213. 打家劫舍 II\"></a><a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">213. 打家劫舍 II</a></h2><p>跟212题差别在于首尾两家是相连的。</p>\n<p>我想了一会没有想出来怎么解决。像这样<strong>环</strong>的有点不会处理，之前还做到过一个<a href=\"https://leetcode-cn.com/problems/next-greater-element-ii/\">503. 下一个更大元素 II</a>，这道题中是对<strong>数组循环遍历</strong>，这道题目里对数组遍历两次就可以。</p>\n<p>题解：拆成偷第一家和偷最后一家两种情况，分别求出两种情况下能取得的最大金额，两者之中更大的那个就是答案。</p>\n<h2 id=\"337-打家劫舍-III\"><a href=\"#337-打家劫舍-III\" class=\"headerlink\" title=\"337. 打家劫舍 III\"></a><a href=\"https://leetcode-cn.com/problems/house-robber-iii/\">337. 打家劫舍 III</a></h2><p>这道题能想到的解题思路：对于当前节点，如果我偷当前节点，那就不能偷它的左右节点；如果我不偷，那就左右节点最大金额之和。但是我WA了… 联想到动态规划的思想：记忆化来减少搜索时间。我们可以保存已经求过的节点的值。</p>\n<p>再更进一步，我们可以保存两种情况的值（我想到了，但是没有想到有什么方法来保存。提醒自己一下：<strong>不是作为值保存在节点中，而是作为函数返回值来传递</strong>！）。也就是保存偷当前节点能取到的最大金额和不偷当前节点能取到的最大金额。</p>\n<p>看了题解又有种思路打开的感觉，我觉得很妙，记一笔。</p>\n<h2 id=\"剑指-Offer-14-I-剪绳子\"><a href=\"#剑指-Offer-14-I-剪绳子\" class=\"headerlink\" title=\"剑指 Offer 14- I. 剪绳子\"></a><a href=\"https://leetcode-cn.com/problems/jian-sheng-zi-lcof/\">剑指 Offer 14- I. 剪绳子</a></h2><p>和<a href=\"https://leetcode-cn.com/problems/integer-break/\">343. 整数拆分</a>是同一道题</p>\n<p>好神奇，没有太理解！</p>\n<p><strong>DP</strong></p>\n<p>dp[i]为长度为i的绳子，切割后的最大乘积。状态转移公式：<code>dp[i]=max(j*(i-j), j*dp[i-j])</code>。</p>\n<p><strong>贪心</strong></p>\n<p>尽量切成三段。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>终于开始动态规划啦！啊好难的动态规划~目前做了一些题，持续更新！</p>\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/emoji/braveDog.jpg\" alt=\"braveDog\" style=\"zoom:50%;\" />","more":"<ul>\n<li>状态压缩：留个档<a href=\"https://zhuanlan.zhihu.com/p/131585177\">https://zhuanlan.zhihu.com/p/131585177</a></li>\n<li>题单：<a href=\"https://zxi.mytechroad.com/blog/leetcode-problem-categories/\">花花酱 LeetCode Problem List 题目列表</a></li>\n<li><a href=\"https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html\">代码随想录</a></li>\n</ul>\n<h1 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h1><p>什么问题适合用背包来解决呢？</p>\n<p>我认为是给了<strong>一组元素（数字、字符、字符串）</strong>（放进背包的东西），让你使用其中的元素，来<strong>满足一定的要求</strong>（背包容量）。这些元素可以是每个只能最多用一次（01背包），也可以是每个可以用无数次（完全背包）。这一类问题可以考虑背包。</p>\n<h2 id=\"01背包\"><a href=\"#01背包\" class=\"headerlink\" title=\"01背包\"></a>01背包</h2><p>有n件物品和一个最多只能背w重量的背包，每件物品只能用一次，求怎么放才能使背包内物品价值最大。</p>\n<p>解决问题的关键在于：</p>\n<ol>\n<li>当然是想到问题可以用背包来解~然后把问题转换为背包问题，我觉得这一步是最难的，因为题目形式千变万化</li>\n<li>设计背包。</li>\n</ol>\n<h3 id=\"中等\"><a href=\"#中等\" class=\"headerlink\" title=\"中等\"></a>中等</h3><h4 id=\"416-分割等和子集\"><a href=\"#416-分割等和子集\" class=\"headerlink\" title=\"416. 分割等和子集\"></a><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\">416. 分割等和子集</a></h4><p>把问题转换为：数组中是否有一组数字，它们的和为sum/2。</p>\n<h4 id=\"1049-最后一块石头的重量-II\"><a href=\"#1049-最后一块石头的重量-II\" class=\"headerlink\" title=\"1049. 最后一块石头的重量 II\"></a><a href=\"https://leetcode-cn.com/problems/last-stone-weight-ii/\">1049. 最后一块石头的重量 II</a></h4><p>把问题转换为：把石头分成两堆，这两堆和的差尽可能接近。</p>\n<p>或者可以看成：把石头重量加上正负号，求这些数列出式子后，和最接近零的。（其实也是在找一堆数字相加可以尽量等于sum/2。）</p>\n<h4 id=\"494-目标和\"><a href=\"#494-目标和\" class=\"headerlink\" title=\"494. 目标和\"></a><a href=\"https://leetcode-cn.com/problems/target-sum/\">494. 目标和</a></h4><p>416、1049、494这三道题比较类似。</p>\n<p>特别和第1049题很像。</p>\n<h4 id=\"474-一和零\"><a href=\"#474-一和零\" class=\"headerlink\" title=\"474. 一和零\"></a><a href=\"https://leetcode-cn.com/problems/ones-and-zeroes/\">474. 一和零</a></h4><p>和上面三道题不一样的地方是，<strong>背包有两个容量（1的数量和0的数量）</strong>。</p>\n<p>想了半天用二维dp如何表示，也没想出来。参考题解用三维，然后进一步优化为二维。</p>\n<p><code>dp[i][j][k]</code>表示在下标<code>0-i</code>中选择字符串，字符串中<code>0</code>的数量不超过<code>j</code>，<code>1</code>的数量不超过<code>k</code>。状态转移有两种情况，当不选择第<code>i</code>个字符串时，<code>dp[i][j][k] = dp[i-1][j][k]</code>时；当选择第<code>i</code>个字符串时，<code>dp[i][j][k] = dp[i-1][j-zero[i]][k-one[i]]</code>。</p>\n<p>考虑初始化：多设置一行，第一行为空串也不选择，整行为0。</p>\n<h2 id=\"完全背包\"><a href=\"#完全背包\" class=\"headerlink\" title=\"完全背包\"></a>完全背包</h2><h3 id=\"中等-1\"><a href=\"#中等-1\" class=\"headerlink\" title=\"中等\"></a>中等</h3><h4 id=\"518-零钱兑换-II\"><a href=\"#518-零钱兑换-II\" class=\"headerlink\" title=\"518. 零钱兑换 II\"></a><a href=\"https://leetcode-cn.com/problems/coin-change-2/\">518. 零钱兑换 II</a></h4><p>相当于求组合数，需要注意的是每种硬币不能重复选择，即(1, 5)和(5, 1)只能出现其中一种。这个体现在双重for循环求解时，外层for循环对硬币面额的循环，内层for循环对硬币总和的循环。而如果反过来，就会产生重复了，列表也可以看出来。</p>\n<h4 id=\"377-组合总和-Ⅳ\"><a href=\"#377-组合总和-Ⅳ\" class=\"headerlink\" title=\"377. 组合总和 Ⅳ\"></a><a href=\"https://leetcode-cn.com/problems/combination-sum-iv/\">377. 组合总和 Ⅳ</a></h4><p>这道题虽然标题叫求组合的总和，实际上看一下测试用例就知道在找排列数。跟518思路差不多，就是518的两层循环内外交换一下。</p>\n<p>PS. 我感觉这样求组合数、排列数的用动态规划（背包）即可解决，如果需要具体的排列组合方式，就需要回溯。</p>\n<h4 id=\"322-零钱兑换\"><a href=\"#322-零钱兑换\" class=\"headerlink\" title=\"322. 零钱兑换\"></a><a href=\"https://leetcode-cn.com/problems/coin-change/\">322. 零钱兑换</a></h4><p>518在求组合数，这道题求最少的硬币个数，状态转移方程不同一点。在求<code>dp[i][j]</code>时，518题的状态转移方程为：<code>dp[i][j]=dp[i-1][j] + dp[j-1][j-coins[i]]</code>。</p>\n<p>在这道题中，状态转移方程为：<code>dp[i][j] = min(dp[i-1][j], dp[i-1][j-coins[i]]+1)</code>。然后考虑初始化，dp数组的大小为<code>dp[m+1][n+1]</code>， <code>dp[0][0]</code>表示一个硬币也不取，总和为0时需要的硬币个数（注意不是组合数，组合数即取法为1），即 <code>dp[0][0] = 0</code>。其他的先初始化成取不到的数字，用<code>Integer.MAX_VALUE</code>即可。</p>\n<h1 id=\"简单\"><a href=\"#简单\" class=\"headerlink\" title=\"简单\"></a>简单</h1><h2 id=\"70-爬楼梯-☆\"><a href=\"#70-爬楼梯-☆\" class=\"headerlink\" title=\"70. 爬楼梯 ☆\"></a><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">70. 爬楼梯</a> ☆</h2><blockquote>\n<p>有一个人学DP不会爬楼梯的我都会伤心的OK？</p>\n</blockquote>\n<p>递归方法容易想到，但是会超时。分析一下，先想到可以用一个长度为N的数组来保存每一次结果。再进一步分析一下可以想到其实保存两个数字就够啦。</p>\n<p><strong>动态规划 vs 递归</strong>（<a href=\"https://leetcode-cn.com/problems/climbing-stairs/solution/cong-zhi-jue-si-wei-fen-xi-dong-tai-gui-hua-si-lu-/\">参考</a>）</p>\n<p>将原问题分为子问题来解决的，通常有两种思路：自顶向下和自底向上。递归就是自顶向下的思想，再层层向上返回结果，递归会出现重复解决子问题的情况因此效率较低。而动态规划是自底向上的思想。</p>\n<p>虽然动态规划看上去更好用，但是递归也有其优势。比如动态规划一般只保存结果，而不保存路径；但递归用回溯可以得到路径。</p>\n<p>变形体：<a href=\"https://leetcode-cn.com/problems/min-cost-climbing-stairs/\">746. 使用最小花费爬楼梯</a></p>\n<h2 id=\"746-使用最小花费爬楼梯\"><a href=\"#746-使用最小花费爬楼梯\" class=\"headerlink\" title=\"746. 使用最小花费爬楼梯\"></a><a href=\"https://leetcode-cn.com/problems/min-cost-climbing-stairs/\">746. 使用最小花费爬楼梯</a></h2><p>和爬楼梯解决方法类似。在读题的时候卡了一下emm，然后在计算代价的时候稍微卡了一下。还是自底向上的思路，令f(i)为爬到第i个台阶时需要的代价。$f(i)=min(f(i-1)+cost(i-1), f(i-2)+cost(i-2))$，得到这个公式之后就比较清晰了。</p>\n<h2 id=\"1137-第-N-个泰波那契数\"><a href=\"#1137-第-N-个泰波那契数\" class=\"headerlink\" title=\"1137. 第 N 个泰波那契数\"></a><a href=\"https://leetcode-cn.com/problems/n-th-tribonacci-number/\">1137. 第 N 个泰波那契数</a></h2><p>这叫泰波那契数，还不是斐波那契数，哈哈，但是解法是类似的。</p>\n<p>来点不一样的方法看看叭：<a href=\"https://leetcode-cn.com/problems/n-th-tribonacci-number/solution/gong-shui-san-xie-yi-ti-si-jie-die-dai-d-m1ie/\">矩阵快速幂</a></p>\n<h2 id=\"303-区域和检索-数组不可变\"><a href=\"#303-区域和检索-数组不可变\" class=\"headerlink\" title=\"303. 区域和检索 - 数组不可变\"></a><a href=\"https://leetcode-cn.com/problems/range-sum-query-immutable/\">303. 区域和检索 - 数组不可变</a></h2><p>用前缀和。</p>\n<p>来点不一样的方法看看叭：<a href=\"https://leetcode-cn.com/problems/range-sum-query-immutable/solution/ni-yong-yuan-ke-yi-xiang-xin-fen-kuai-su-ugou/\">分块算法</a></p>\n<h1 id=\"中等-2\"><a href=\"#中等-2\" class=\"headerlink\" title=\"中等\"></a>中等</h1><h2 id=\"300-最长递增子序列\"><a href=\"#300-最长递增子序列\" class=\"headerlink\" title=\"300. 最长递增子序列\"></a><a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\">300. 最长递增子序列</a></h2><p>详见二分篇</p>\n<h2 id=\"139-单词拆分\"><a href=\"#139-单词拆分\" class=\"headerlink\" title=\"139. 单词拆分\"></a><a href=\"https://leetcode-cn.com/problems/word-break/\">139. 单词拆分</a></h2><p>参考题解：<a href=\"https://leetcode-cn.com/problems/word-break/solution/shou-hui-tu-jie-san-chong-fang-fa-dfs-bfs-dong-tai/\">「手画图解」剖析三种解法: DFS, BFS, 动态规划 |139.单词拆分 - 单词拆分 - 力扣（LeetCode）</a></p>\n<p><strong>方法1-DFS</strong></p>\n<p>将问题进行拆分，以leetcode为例，拆分为：1. <code>l</code>是否在单词表中，剩余子串是否能分解；2. <code>le</code>是否在单词表中，剩余子串是否能分解；3. …</p>\n<p>用DFS回溯即可。</p>\n<h2 id=\"198-打家劫舍\"><a href=\"#198-打家劫舍\" class=\"headerlink\" title=\"198. 打家劫舍\"></a><a href=\"https://leetcode-cn.com/problems/house-robber/\">198. 打家劫舍</a></h2><p>发现做了一些dp题目之后有点思路了！</p>\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/emoji/large.jpg\" alt=\"gejvOpen\" style=\"zoom: 25%;\" />\n\n<p>题目关键点：不能连续偷。</p>\n<p>设<code>dp[i]</code>表示前i家能取得的最高金额。尝试写一下状态转移公式，既然是求最大，应该是一些状态来比较。如果不偷第i家，就是<code>dp[i-1]</code>；如果偷第i家，那就不能偷第<code>i-1</code>家，但是第<code>i-2</code>家要偷，那就前<code>i-2</code>家取得的最高金额加上第<code>i</code>家取得的金额，也就是<code>dp[i-2]+nums[i]</code>。状态转移方程：<code>dp[i] = max(dp[i-1], dp[i-2]+nums[i])</code>。</p>\n<p>再考虑初始化，这里初始化需要i=0时，即一家也不偷，显然为0。再看状态转移方程中，其实当前状态<code>dp[i]</code>只跟<code>dp[i-1]</code>和<code>dp[i-2]</code>有关，所以只需要两个变量来保存中间结果就可以了。</p>\n<h2 id=\"213-打家劫舍-II\"><a href=\"#213-打家劫舍-II\" class=\"headerlink\" title=\"213. 打家劫舍 II\"></a><a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">213. 打家劫舍 II</a></h2><p>跟212题差别在于首尾两家是相连的。</p>\n<p>我想了一会没有想出来怎么解决。像这样<strong>环</strong>的有点不会处理，之前还做到过一个<a href=\"https://leetcode-cn.com/problems/next-greater-element-ii/\">503. 下一个更大元素 II</a>，这道题中是对<strong>数组循环遍历</strong>，这道题目里对数组遍历两次就可以。</p>\n<p>题解：拆成偷第一家和偷最后一家两种情况，分别求出两种情况下能取得的最大金额，两者之中更大的那个就是答案。</p>\n<h2 id=\"337-打家劫舍-III\"><a href=\"#337-打家劫舍-III\" class=\"headerlink\" title=\"337. 打家劫舍 III\"></a><a href=\"https://leetcode-cn.com/problems/house-robber-iii/\">337. 打家劫舍 III</a></h2><p>这道题能想到的解题思路：对于当前节点，如果我偷当前节点，那就不能偷它的左右节点；如果我不偷，那就左右节点最大金额之和。但是我WA了… 联想到动态规划的思想：记忆化来减少搜索时间。我们可以保存已经求过的节点的值。</p>\n<p>再更进一步，我们可以保存两种情况的值（我想到了，但是没有想到有什么方法来保存。提醒自己一下：<strong>不是作为值保存在节点中，而是作为函数返回值来传递</strong>！）。也就是保存偷当前节点能取到的最大金额和不偷当前节点能取到的最大金额。</p>\n<p>看了题解又有种思路打开的感觉，我觉得很妙，记一笔。</p>\n<h2 id=\"剑指-Offer-14-I-剪绳子\"><a href=\"#剑指-Offer-14-I-剪绳子\" class=\"headerlink\" title=\"剑指 Offer 14- I. 剪绳子\"></a><a href=\"https://leetcode-cn.com/problems/jian-sheng-zi-lcof/\">剑指 Offer 14- I. 剪绳子</a></h2><p>和<a href=\"https://leetcode-cn.com/problems/integer-break/\">343. 整数拆分</a>是同一道题</p>\n<p>好神奇，没有太理解！</p>\n<p><strong>DP</strong></p>\n<p>dp[i]为长度为i的绳子，切割后的最大乘积。状态转移公式：<code>dp[i]=max(j*(i-j), j*dp[i-j])</code>。</p>\n<p><strong>贪心</strong></p>\n<p>尽量切成三段。</p>"},{"title":"Leetcode刷题之双指针","date":"2022-02-10T07:22:34.000Z","updated":"2022-02-10T07:22:34.000Z","_content":"\n双指针类型题目，持续更新\n\n<!--more-->\n\nTips：\n\n- 双指针来**减小搜索空间**\n\n- 双指针可以分为对撞指针和快慢指针。对撞指针一般从序列的两端向中间进行遍历。而快慢指针从同一侧开始遍历但以不同的策略进行移动，直到两个指针的值相等或满足其他特殊条件（比如快指针走到序列底了）为止。\n\n- 和滑动窗口相辅相成。\n\n- 一个双指针模板（by[负雪明烛](https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/fen-xiang-zhen-cang-de-shuang-zhi-zhen-m-fdsk/)）（感觉说是滑动窗口模板更合适）\n\n  \n\n# Easy\n\n## [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)\n\n方法一：双指针，把不符合条件的数字移到后面\n\n方法二：遍历数组，如果不等于val就保留。\n\n## [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)\n\n- 从后向前合并，利用num1的空余位置\n\n## [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)\n\n- 一个指针从前往后，一个指针从后往前，都去找元音字母，我用一个set保存元音，要注意的是大小写都考虑到。\n- String2Array：str.toCharArray(); Array2String：String.valueOf(ch)\n\n## [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)\n\n贪心。先满足胃口小的孩子。\n\n这里记一笔：我在判断大小的时候先相减，在判断减的结果是否小于零，这样可能会因为越界产生错误，所以直接判断大小就可以了。所以在做题的时候先要保证思路（代码框架和逻辑）正确（这里需要练习与随之而来的自信），然后再确定细节（比如越界、超时等等）（当然这里也需要很多练习与随之而来的经验）\n\n## [485. 最大连续 1 的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)\n\n简单题重拳出击。\n\n- 我的方法是每次循环找到第一个为1的位置，然后再找到第一个为0的位置\n- 也可以在对数组进行遍历，遇到1的时候，找0的位置；遇到0的时候，i++\n\n## [1446. 连续字符](https://leetcode-cn.com/problems/consecutive-characters/)\n\n- 设置两个指针，第一个固定，第二个移动到与第一个指向的字符不同的位置。\n\n\n\n# Medium\n\n## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n双指针，也是滑动窗口题\n\n用到了双指针的思想（一个指向首字母，一个指向尾字母）。\n\n1. 设置指针start和end，用哈希表map来保存出现的字符和出现次数\n2. end指向的字符如果不在map中，加入map并使value+1\n3. 当value大于1时，说明之前出现过这个字符\n4. 移动start，并使map中对应字符value-1（即不出现在当前字符串中），直到end指向字符的value等于1（即只出现在刚才加入的地方），此时字符串中又没有重复字符了\n5. 比较当前字符串长度（end-start+1）和之前保留结果maxLen，取大的那个值\n\n## [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)\n\n双指针来减小搜索空间\n\n- 注意容器面积只取决于两边的板\n- 移动两者其中的短板，才有可能使面积变大；若移动长板，面积不变或变小；从而可以减小搜索空间\n\n## [15. 三数之和](https://leetcode-cn.com/problems/3sum/)\n\n也是用双指针来减小搜索空间（固定一个元素，移动两个元素，两个指针往固定的方向移动，可以更好控制搜索空间的变化）\n\n1. 先讲数组排序，可以更好处理重复的情况\n2. 固定一个指针k，从第一个元素开始\n3. 设置双指针left和right，分别在k+1和数组最后一个元素\n4. 如果nums[k]>0，三者之和一定大于零\n5. 如果nums[k]==nums[k-1]，避免重复，直接跳过\n6. 三者之和小于0，说明数太小，left往右移；大于0，则说明数太大，right往左移\n\n变形题：\n\n[16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)\n\n[18. 四数之和](https://leetcode-cn.com/problems/4sum/)\n\n## [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)\n\n维护一个最大边界（maxPosition），保存这次跳跃能到达的最远位置。\n\n当小人移动到本次跳跃的最远边界（end）时，就进入下一次跳跃，所以step++。\n\n初始状态下，end为0。\n\n## [395. 至少有 K 个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)\n\n三叶的题解有点没看懂，有条件的滑动窗口。\n\n[【宫水三叶の相信科学系列】为什么不能用「滑动窗口」？以及如何发掘题目性质 ](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/xiang-jie-mei-ju-shuang-zhi-zhen-jie-fa-50ri1/)\n\n为什么三叶的第一反应是二分？我猜测一下，找到不满足条件的字符，将字符串一分为二，再接着找。\n\n为什么这就不满足二段性了啊？为什么这里双指针不具有单调性啊？\n\n假如说我现在用双指针来维护一个区间，让他满足左边界左侧的字符和右边界右侧的字符都不出现在子字符串内。如果我把右指针往右移，他有可能满足也可能不满足，那只要判断一下就行了呀，如果这个字符出现在里面，那就移，如果不出现就不移。\n\n或者如果不出现，那就移到出现为止，但是这样的话，移动不是单调的，就是说一直移动还是可能不满足条件的。\n\n为什么第三题可以用滑动窗口来做呢？如果我现在用双指针来维护一个区间，让他里面的字符不重复。如果我把右指针往右移，也是可能满足可能不满足。如果这个字符出现在里面，我就移动，然后让左指针移到原来出现的位置。\n\n但是这道题他不行。因为我右指针移动的话，左指针要怎么移呢。窗口内子字符串的”包含字符的数量“这一属性一直在变化，也就导致窗口内子字符串“满足每个字符出现次数大于等于k”这一属性也一直变化。因此说他是非单调的。\n\n我们换一个思路，换一个移动条件。那就是固定窗口内字符类型：比如说只有一种字符，aa满足条件；只有两种字符，aabb满足条件。这样一来的话，只要外层加个26个字母的循环即可。维护一个区间，让他满足区间内出现的字符类型为x。\n\n## [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)\n\n可变长度的滑动窗，我在建模的时候出了一点问题。可以将题目转换成：寻找一个区间，使得这个区间内出现次数最多的字母+k小于区间长度。\n\n思路好理解，但是加上一个优化的话这理解就在大气层了emm\n\n需要再做一遍的。\n\nTips：\n\n- 滑动窗，右指针主动移动一个，左指针被动移动。\n- 窗口只可变大或不变。\n\n\n\n## [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)\n\n总是考虑得不太对，唉。\n\n\n\n## [443. 压缩字符串](https://leetcode-cn.com/problems/string-compression/)\n\n做出了空间复杂度为O(n)的方法，主要是在数字填入字符串的部分。\n\nTips：\n\n* 一般能做出O(n)但是要用O(1)的，需要时间换空间，不要觉得太复杂什么的就不写了，尝试一下。\n* 现在做题很难一次AC，需要根据错误的测试用例来debug，这样一来在不提供错误测试用例的笔试就会比较头疼，之前也都是这种情况。\n* 这道题目里，碰到的情况是：忘记覆盖无用字符了！也就是**[\"a\",\"a\",\"a\",\"b\",\"b\",\"a\",\"a\"]**会返回**[\"a\",\"3\",\"a\",\"b\",\"2\",\"a\",\"2\"]**的情况，第三个字符没有被覆盖，也是在做题最初的时候没有考虑到的。没想好，着急了\n\n\n\n记一个有点奇怪的事情\n\n这是我写的代码，最后一个测试用例过不了。。问题发现在哪里了！第九行应该是大于等于！！不然如果出现重复值的heater它就不会后移了！！！就检查不到后面的heater了！\n\n```java\nclass Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n        int res = 0;\n        int i=0, j=0;\n        Arrays.sort(houses);\n        Arrays.sort(heaters);\n        while(i<houses.length){\n            int len = Math.abs(heaters[j] - houses[i]);\n            while(j+1<heaters.length && Math.abs(heaters[j] - houses[i]) > Math.abs(heaters[j+1]- houses[i])){\n                j++;\n                len = Math.min(len, Math.abs(heaters[j]- houses[i]));\n            }\n            res = Math.max(res, len);\n            i++;\n        }\n        return res;\n    }\n}\n```\n\n## [519. 随机翻转矩阵](https://leetcode-cn.com/problems/random-flip-matrix/)\n\n感觉和数据结构的关系更大，见：XX\n\n## [524. 通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)\n\n这道题，咱们先来学习一下JAVA中的排序。\n\n[Java8中Comparable和Comparator区别小结 - Java开发 - 程序喵](http://www.ibloger.net/article/2773.html)\n\nArrays.sort用于对数组排序，Collections.sort用于对集合排序。这两种方法默认是升序，都可以自定义实现，即通过**重写比较器**来自定义对象排序。\n\n> **数组和集合的区别**\n>\n> 数组是静态的，声明之后就无法改变容量；而集合是动态的。\n>\n> 数组：array；集合：set，list\n>\n> 数组->集合：Arrays.asList(arr)；集合->数组：list.toArray()\n\n唉思路对了，可是比较的时候居然又出问题了。逻辑没想清楚，容易出错。\n\n原来的写法：\n\n```java\nfor(String item:dictionary){\n    int i=0, j=0;\n    while(j<item.length()){\n        char ch = item.charAt(j);\n        while(i<s.length() && s.charAt(i++)!=ch);\n        if(i==s.length()) break;\t// ！如果正好i在最后一个位置相等，造成j没有++而出错\n        j++;\t\t\t\t\t\n    }\n    if(j==item.length()){\n        res = item;\n        break;\n    }\n}\n```\n\n参考题解后的写法：\n\n```java\n for(String item:dictionary){\n     int i=0, j=0;\n     while(j<item.length() && i<s.length()){\n         if(item.charAt(j) == s.charAt(i)) j++;\t\t// 一个指针指向item，一个指针指向s，相等就都前进，不等就只有i前进。不提前break，程序可能更不易出错。\n         i++;\n     }\n     if(j==item.length()){\n         res = item;\n         break;\n     }\n }\n```\n\n\n\n## [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)\n\n看题解确实技巧性比较强。\n\n我的思路：从前往后找到第一个不满足nums[i]<=nums[i+1]的索引，作为不符合升序的begin位置，再从后往前找到第一个不满足nums[j]>=nums[j-1]的索引，作为不符合升序的end位置。遍历begin到end，找到区间[begin, end]内的最大值maxNum和最小值minNum。\n\n从begin-1往前找到第一个nums[i] <= minNum的索引i，从end+1往后找到第一个nums[j] >= maxNum的索引，j-i-1就是答案。这个算法最多扫描两次数组，算法复杂度为O(n)。\n\n题解：从前往后找最大值，并且找到最后一个小于最大值的索引。从后往前找最小值，并且找到最后一个大于最小值的索引。\n\n## [611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)\n\n我只会暴力解法（表面：呜呜呜我好菜；内心：暴力yyds！\n\n咳，可以优化一下。仔细看看，三重循环事实上固定两个最小的，找大的边。转换一下思路，**固定最大边**，找剩下两个小的，运用双指针。这也是双指针减小搜索空间的应用。\n\n题解里还有数学解法的，没有仔细看。\n\n## [825. 适龄的朋友](https://leetcode-cn.com/problems/friends-of-appropriate-ages/)\n\n先要把题意分析清楚，可以发送请求的用户年龄在一个区间内。\n\n一个比较明显的思路：只要找到这个区间的左右端点即可。将数组排序后，左端点是第一个满足要求的用户的下标，右端点则是最后一个满足要求的用户下标。相减的时候减掉自身即可。这里如果每次左端点从零开始的话，运行会超时，像这样数字连续的序列，可以接着上次的搜索结果继续找。\n\n另外有一个思路，使用的**前缀和**。我们需要统计出在区间`(0.5 * age[x] + 7, age[x]]`之间的人数。就是说，设置一个前缀和数组`p[121]`，`p[i]`保存的就是年龄为`[0, i]`的总人数，那么`p[age[x]] - p[0.5 * age[x] + 7]`就是上述区间内的人数，然后再减去x自身，即减1就是下标x对应的答案。因为年龄小于120，按年龄遍历即可，每个年龄的结果记得乘上这个年龄的人数。\n\n","source":"_posts/Leetcode刷题之双指针.md","raw":"---\ntitle: Leetcode刷题之双指针\ndate: 2022-02-10 15:22:34\nupdated: \ncategories: 刷题\ntags: 双指针\n---\n\n双指针类型题目，持续更新\n\n<!--more-->\n\nTips：\n\n- 双指针来**减小搜索空间**\n\n- 双指针可以分为对撞指针和快慢指针。对撞指针一般从序列的两端向中间进行遍历。而快慢指针从同一侧开始遍历但以不同的策略进行移动，直到两个指针的值相等或满足其他特殊条件（比如快指针走到序列底了）为止。\n\n- 和滑动窗口相辅相成。\n\n- 一个双指针模板（by[负雪明烛](https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/fen-xiang-zhen-cang-de-shuang-zhi-zhen-m-fdsk/)）（感觉说是滑动窗口模板更合适）\n\n  \n\n# Easy\n\n## [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)\n\n方法一：双指针，把不符合条件的数字移到后面\n\n方法二：遍历数组，如果不等于val就保留。\n\n## [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)\n\n- 从后向前合并，利用num1的空余位置\n\n## [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)\n\n- 一个指针从前往后，一个指针从后往前，都去找元音字母，我用一个set保存元音，要注意的是大小写都考虑到。\n- String2Array：str.toCharArray(); Array2String：String.valueOf(ch)\n\n## [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)\n\n贪心。先满足胃口小的孩子。\n\n这里记一笔：我在判断大小的时候先相减，在判断减的结果是否小于零，这样可能会因为越界产生错误，所以直接判断大小就可以了。所以在做题的时候先要保证思路（代码框架和逻辑）正确（这里需要练习与随之而来的自信），然后再确定细节（比如越界、超时等等）（当然这里也需要很多练习与随之而来的经验）\n\n## [485. 最大连续 1 的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)\n\n简单题重拳出击。\n\n- 我的方法是每次循环找到第一个为1的位置，然后再找到第一个为0的位置\n- 也可以在对数组进行遍历，遇到1的时候，找0的位置；遇到0的时候，i++\n\n## [1446. 连续字符](https://leetcode-cn.com/problems/consecutive-characters/)\n\n- 设置两个指针，第一个固定，第二个移动到与第一个指向的字符不同的位置。\n\n\n\n# Medium\n\n## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n双指针，也是滑动窗口题\n\n用到了双指针的思想（一个指向首字母，一个指向尾字母）。\n\n1. 设置指针start和end，用哈希表map来保存出现的字符和出现次数\n2. end指向的字符如果不在map中，加入map并使value+1\n3. 当value大于1时，说明之前出现过这个字符\n4. 移动start，并使map中对应字符value-1（即不出现在当前字符串中），直到end指向字符的value等于1（即只出现在刚才加入的地方），此时字符串中又没有重复字符了\n5. 比较当前字符串长度（end-start+1）和之前保留结果maxLen，取大的那个值\n\n## [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)\n\n双指针来减小搜索空间\n\n- 注意容器面积只取决于两边的板\n- 移动两者其中的短板，才有可能使面积变大；若移动长板，面积不变或变小；从而可以减小搜索空间\n\n## [15. 三数之和](https://leetcode-cn.com/problems/3sum/)\n\n也是用双指针来减小搜索空间（固定一个元素，移动两个元素，两个指针往固定的方向移动，可以更好控制搜索空间的变化）\n\n1. 先讲数组排序，可以更好处理重复的情况\n2. 固定一个指针k，从第一个元素开始\n3. 设置双指针left和right，分别在k+1和数组最后一个元素\n4. 如果nums[k]>0，三者之和一定大于零\n5. 如果nums[k]==nums[k-1]，避免重复，直接跳过\n6. 三者之和小于0，说明数太小，left往右移；大于0，则说明数太大，right往左移\n\n变形题：\n\n[16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)\n\n[18. 四数之和](https://leetcode-cn.com/problems/4sum/)\n\n## [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)\n\n维护一个最大边界（maxPosition），保存这次跳跃能到达的最远位置。\n\n当小人移动到本次跳跃的最远边界（end）时，就进入下一次跳跃，所以step++。\n\n初始状态下，end为0。\n\n## [395. 至少有 K 个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)\n\n三叶的题解有点没看懂，有条件的滑动窗口。\n\n[【宫水三叶の相信科学系列】为什么不能用「滑动窗口」？以及如何发掘题目性质 ](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/xiang-jie-mei-ju-shuang-zhi-zhen-jie-fa-50ri1/)\n\n为什么三叶的第一反应是二分？我猜测一下，找到不满足条件的字符，将字符串一分为二，再接着找。\n\n为什么这就不满足二段性了啊？为什么这里双指针不具有单调性啊？\n\n假如说我现在用双指针来维护一个区间，让他满足左边界左侧的字符和右边界右侧的字符都不出现在子字符串内。如果我把右指针往右移，他有可能满足也可能不满足，那只要判断一下就行了呀，如果这个字符出现在里面，那就移，如果不出现就不移。\n\n或者如果不出现，那就移到出现为止，但是这样的话，移动不是单调的，就是说一直移动还是可能不满足条件的。\n\n为什么第三题可以用滑动窗口来做呢？如果我现在用双指针来维护一个区间，让他里面的字符不重复。如果我把右指针往右移，也是可能满足可能不满足。如果这个字符出现在里面，我就移动，然后让左指针移到原来出现的位置。\n\n但是这道题他不行。因为我右指针移动的话，左指针要怎么移呢。窗口内子字符串的”包含字符的数量“这一属性一直在变化，也就导致窗口内子字符串“满足每个字符出现次数大于等于k”这一属性也一直变化。因此说他是非单调的。\n\n我们换一个思路，换一个移动条件。那就是固定窗口内字符类型：比如说只有一种字符，aa满足条件；只有两种字符，aabb满足条件。这样一来的话，只要外层加个26个字母的循环即可。维护一个区间，让他满足区间内出现的字符类型为x。\n\n## [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)\n\n可变长度的滑动窗，我在建模的时候出了一点问题。可以将题目转换成：寻找一个区间，使得这个区间内出现次数最多的字母+k小于区间长度。\n\n思路好理解，但是加上一个优化的话这理解就在大气层了emm\n\n需要再做一遍的。\n\nTips：\n\n- 滑动窗，右指针主动移动一个，左指针被动移动。\n- 窗口只可变大或不变。\n\n\n\n## [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)\n\n总是考虑得不太对，唉。\n\n\n\n## [443. 压缩字符串](https://leetcode-cn.com/problems/string-compression/)\n\n做出了空间复杂度为O(n)的方法，主要是在数字填入字符串的部分。\n\nTips：\n\n* 一般能做出O(n)但是要用O(1)的，需要时间换空间，不要觉得太复杂什么的就不写了，尝试一下。\n* 现在做题很难一次AC，需要根据错误的测试用例来debug，这样一来在不提供错误测试用例的笔试就会比较头疼，之前也都是这种情况。\n* 这道题目里，碰到的情况是：忘记覆盖无用字符了！也就是**[\"a\",\"a\",\"a\",\"b\",\"b\",\"a\",\"a\"]**会返回**[\"a\",\"3\",\"a\",\"b\",\"2\",\"a\",\"2\"]**的情况，第三个字符没有被覆盖，也是在做题最初的时候没有考虑到的。没想好，着急了\n\n\n\n记一个有点奇怪的事情\n\n这是我写的代码，最后一个测试用例过不了。。问题发现在哪里了！第九行应该是大于等于！！不然如果出现重复值的heater它就不会后移了！！！就检查不到后面的heater了！\n\n```java\nclass Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n        int res = 0;\n        int i=0, j=0;\n        Arrays.sort(houses);\n        Arrays.sort(heaters);\n        while(i<houses.length){\n            int len = Math.abs(heaters[j] - houses[i]);\n            while(j+1<heaters.length && Math.abs(heaters[j] - houses[i]) > Math.abs(heaters[j+1]- houses[i])){\n                j++;\n                len = Math.min(len, Math.abs(heaters[j]- houses[i]));\n            }\n            res = Math.max(res, len);\n            i++;\n        }\n        return res;\n    }\n}\n```\n\n## [519. 随机翻转矩阵](https://leetcode-cn.com/problems/random-flip-matrix/)\n\n感觉和数据结构的关系更大，见：XX\n\n## [524. 通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)\n\n这道题，咱们先来学习一下JAVA中的排序。\n\n[Java8中Comparable和Comparator区别小结 - Java开发 - 程序喵](http://www.ibloger.net/article/2773.html)\n\nArrays.sort用于对数组排序，Collections.sort用于对集合排序。这两种方法默认是升序，都可以自定义实现，即通过**重写比较器**来自定义对象排序。\n\n> **数组和集合的区别**\n>\n> 数组是静态的，声明之后就无法改变容量；而集合是动态的。\n>\n> 数组：array；集合：set，list\n>\n> 数组->集合：Arrays.asList(arr)；集合->数组：list.toArray()\n\n唉思路对了，可是比较的时候居然又出问题了。逻辑没想清楚，容易出错。\n\n原来的写法：\n\n```java\nfor(String item:dictionary){\n    int i=0, j=0;\n    while(j<item.length()){\n        char ch = item.charAt(j);\n        while(i<s.length() && s.charAt(i++)!=ch);\n        if(i==s.length()) break;\t// ！如果正好i在最后一个位置相等，造成j没有++而出错\n        j++;\t\t\t\t\t\n    }\n    if(j==item.length()){\n        res = item;\n        break;\n    }\n}\n```\n\n参考题解后的写法：\n\n```java\n for(String item:dictionary){\n     int i=0, j=0;\n     while(j<item.length() && i<s.length()){\n         if(item.charAt(j) == s.charAt(i)) j++;\t\t// 一个指针指向item，一个指针指向s，相等就都前进，不等就只有i前进。不提前break，程序可能更不易出错。\n         i++;\n     }\n     if(j==item.length()){\n         res = item;\n         break;\n     }\n }\n```\n\n\n\n## [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)\n\n看题解确实技巧性比较强。\n\n我的思路：从前往后找到第一个不满足nums[i]<=nums[i+1]的索引，作为不符合升序的begin位置，再从后往前找到第一个不满足nums[j]>=nums[j-1]的索引，作为不符合升序的end位置。遍历begin到end，找到区间[begin, end]内的最大值maxNum和最小值minNum。\n\n从begin-1往前找到第一个nums[i] <= minNum的索引i，从end+1往后找到第一个nums[j] >= maxNum的索引，j-i-1就是答案。这个算法最多扫描两次数组，算法复杂度为O(n)。\n\n题解：从前往后找最大值，并且找到最后一个小于最大值的索引。从后往前找最小值，并且找到最后一个大于最小值的索引。\n\n## [611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)\n\n我只会暴力解法（表面：呜呜呜我好菜；内心：暴力yyds！\n\n咳，可以优化一下。仔细看看，三重循环事实上固定两个最小的，找大的边。转换一下思路，**固定最大边**，找剩下两个小的，运用双指针。这也是双指针减小搜索空间的应用。\n\n题解里还有数学解法的，没有仔细看。\n\n## [825. 适龄的朋友](https://leetcode-cn.com/problems/friends-of-appropriate-ages/)\n\n先要把题意分析清楚，可以发送请求的用户年龄在一个区间内。\n\n一个比较明显的思路：只要找到这个区间的左右端点即可。将数组排序后，左端点是第一个满足要求的用户的下标，右端点则是最后一个满足要求的用户下标。相减的时候减掉自身即可。这里如果每次左端点从零开始的话，运行会超时，像这样数字连续的序列，可以接着上次的搜索结果继续找。\n\n另外有一个思路，使用的**前缀和**。我们需要统计出在区间`(0.5 * age[x] + 7, age[x]]`之间的人数。就是说，设置一个前缀和数组`p[121]`，`p[i]`保存的就是年龄为`[0, i]`的总人数，那么`p[age[x]] - p[0.5 * age[x] + 7]`就是上述区间内的人数，然后再减去x自身，即减1就是下标x对应的答案。因为年龄小于120，按年龄遍历即可，每个年龄的结果记得乘上这个年龄的人数。\n\n","slug":"Leetcode刷题之双指针","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggt000x38t41sbfcjco","content":"<p>双指针类型题目，持续更新</p>\n<span id=\"more\"></span>\n\n<p>Tips：</p>\n<ul>\n<li><p>双指针来<strong>减小搜索空间</strong></p>\n</li>\n<li><p>双指针可以分为对撞指针和快慢指针。对撞指针一般从序列的两端向中间进行遍历。而快慢指针从同一侧开始遍历但以不同的策略进行移动，直到两个指针的值相等或满足其他特殊条件（比如快指针走到序列底了）为止。</p>\n</li>\n<li><p>和滑动窗口相辅相成。</p>\n</li>\n<li><p>一个双指针模板（by<a href=\"https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/fen-xiang-zhen-cang-de-shuang-zhi-zhen-m-fdsk/\">负雪明烛</a>）（感觉说是滑动窗口模板更合适）</p>\n</li>\n</ul>\n<h1 id=\"Easy\"><a href=\"#Easy\" class=\"headerlink\" title=\"Easy\"></a>Easy</h1><h2 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a><a href=\"https://leetcode-cn.com/problems/remove-element/\">27. 移除元素</a></h2><p>方法一：双指针，把不符合条件的数字移到后面</p>\n<p>方法二：遍历数组，如果不等于val就保留。</p>\n<h2 id=\"88-合并两个有序数组\"><a href=\"#88-合并两个有序数组\" class=\"headerlink\" title=\"88. 合并两个有序数组\"></a><a href=\"https://leetcode-cn.com/problems/merge-sorted-array/\">88. 合并两个有序数组</a></h2><ul>\n<li>从后向前合并，利用num1的空余位置</li>\n</ul>\n<h2 id=\"345-反转字符串中的元音字母\"><a href=\"#345-反转字符串中的元音字母\" class=\"headerlink\" title=\"345. 反转字符串中的元音字母\"></a><a href=\"https://leetcode-cn.com/problems/reverse-vowels-of-a-string/\">345. 反转字符串中的元音字母</a></h2><ul>\n<li>一个指针从前往后，一个指针从后往前，都去找元音字母，我用一个set保存元音，要注意的是大小写都考虑到。</li>\n<li>String2Array：str.toCharArray(); Array2String：String.valueOf(ch)</li>\n</ul>\n<h2 id=\"455-分发饼干\"><a href=\"#455-分发饼干\" class=\"headerlink\" title=\"455. 分发饼干\"></a><a href=\"https://leetcode-cn.com/problems/assign-cookies/\">455. 分发饼干</a></h2><p>贪心。先满足胃口小的孩子。</p>\n<p>这里记一笔：我在判断大小的时候先相减，在判断减的结果是否小于零，这样可能会因为越界产生错误，所以直接判断大小就可以了。所以在做题的时候先要保证思路（代码框架和逻辑）正确（这里需要练习与随之而来的自信），然后再确定细节（比如越界、超时等等）（当然这里也需要很多练习与随之而来的经验）</p>\n<h2 id=\"485-最大连续-1-的个数\"><a href=\"#485-最大连续-1-的个数\" class=\"headerlink\" title=\"485. 最大连续 1 的个数\"></a><a href=\"https://leetcode-cn.com/problems/max-consecutive-ones/\">485. 最大连续 1 的个数</a></h2><p>简单题重拳出击。</p>\n<ul>\n<li>我的方法是每次循环找到第一个为1的位置，然后再找到第一个为0的位置</li>\n<li>也可以在对数组进行遍历，遇到1的时候，找0的位置；遇到0的时候，i++</li>\n</ul>\n<h2 id=\"1446-连续字符\"><a href=\"#1446-连续字符\" class=\"headerlink\" title=\"1446. 连续字符\"></a><a href=\"https://leetcode-cn.com/problems/consecutive-characters/\">1446. 连续字符</a></h2><ul>\n<li>设置两个指针，第一个固定，第二个移动到与第一个指向的字符不同的位置。</li>\n</ul>\n<h1 id=\"Medium\"><a href=\"#Medium\" class=\"headerlink\" title=\"Medium\"></a>Medium</h1><h2 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3. 无重复字符的最长子串\"></a><a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">3. 无重复字符的最长子串</a></h2><p>双指针，也是滑动窗口题</p>\n<p>用到了双指针的思想（一个指向首字母，一个指向尾字母）。</p>\n<ol>\n<li>设置指针start和end，用哈希表map来保存出现的字符和出现次数</li>\n<li>end指向的字符如果不在map中，加入map并使value+1</li>\n<li>当value大于1时，说明之前出现过这个字符</li>\n<li>移动start，并使map中对应字符value-1（即不出现在当前字符串中），直到end指向字符的value等于1（即只出现在刚才加入的地方），此时字符串中又没有重复字符了</li>\n<li>比较当前字符串长度（end-start+1）和之前保留结果maxLen，取大的那个值</li>\n</ol>\n<h2 id=\"11-盛最多水的容器\"><a href=\"#11-盛最多水的容器\" class=\"headerlink\" title=\"11. 盛最多水的容器\"></a><a href=\"https://leetcode-cn.com/problems/container-with-most-water/\">11. 盛最多水的容器</a></h2><p>双指针来减小搜索空间</p>\n<ul>\n<li>注意容器面积只取决于两边的板</li>\n<li>移动两者其中的短板，才有可能使面积变大；若移动长板，面积不变或变小；从而可以减小搜索空间</li>\n</ul>\n<h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15. 三数之和\"></a><a href=\"https://leetcode-cn.com/problems/3sum/\">15. 三数之和</a></h2><p>也是用双指针来减小搜索空间（固定一个元素，移动两个元素，两个指针往固定的方向移动，可以更好控制搜索空间的变化）</p>\n<ol>\n<li>先讲数组排序，可以更好处理重复的情况</li>\n<li>固定一个指针k，从第一个元素开始</li>\n<li>设置双指针left和right，分别在k+1和数组最后一个元素</li>\n<li>如果nums[k]&gt;0，三者之和一定大于零</li>\n<li>如果nums[k]==nums[k-1]，避免重复，直接跳过</li>\n<li>三者之和小于0，说明数太小，left往右移；大于0，则说明数太大，right往左移</li>\n</ol>\n<p>变形题：</p>\n<p><a href=\"https://leetcode-cn.com/problems/3sum-closest/\">16. 最接近的三数之和</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/4sum/\">18. 四数之和</a></p>\n<h2 id=\"45-跳跃游戏-II\"><a href=\"#45-跳跃游戏-II\" class=\"headerlink\" title=\"45. 跳跃游戏 II\"></a><a href=\"https://leetcode-cn.com/problems/jump-game-ii/\">45. 跳跃游戏 II</a></h2><p>维护一个最大边界（maxPosition），保存这次跳跃能到达的最远位置。</p>\n<p>当小人移动到本次跳跃的最远边界（end）时，就进入下一次跳跃，所以step++。</p>\n<p>初始状态下，end为0。</p>\n<h2 id=\"395-至少有-K-个重复字符的最长子串\"><a href=\"#395-至少有-K-个重复字符的最长子串\" class=\"headerlink\" title=\"395. 至少有 K 个重复字符的最长子串\"></a><a href=\"https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/\">395. 至少有 K 个重复字符的最长子串</a></h2><p>三叶的题解有点没看懂，有条件的滑动窗口。</p>\n<p><a href=\"https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/xiang-jie-mei-ju-shuang-zhi-zhen-jie-fa-50ri1/\">【宫水三叶の相信科学系列】为什么不能用「滑动窗口」？以及如何发掘题目性质 </a></p>\n<p>为什么三叶的第一反应是二分？我猜测一下，找到不满足条件的字符，将字符串一分为二，再接着找。</p>\n<p>为什么这就不满足二段性了啊？为什么这里双指针不具有单调性啊？</p>\n<p>假如说我现在用双指针来维护一个区间，让他满足左边界左侧的字符和右边界右侧的字符都不出现在子字符串内。如果我把右指针往右移，他有可能满足也可能不满足，那只要判断一下就行了呀，如果这个字符出现在里面，那就移，如果不出现就不移。</p>\n<p>或者如果不出现，那就移到出现为止，但是这样的话，移动不是单调的，就是说一直移动还是可能不满足条件的。</p>\n<p>为什么第三题可以用滑动窗口来做呢？如果我现在用双指针来维护一个区间，让他里面的字符不重复。如果我把右指针往右移，也是可能满足可能不满足。如果这个字符出现在里面，我就移动，然后让左指针移到原来出现的位置。</p>\n<p>但是这道题他不行。因为我右指针移动的话，左指针要怎么移呢。窗口内子字符串的”包含字符的数量“这一属性一直在变化，也就导致窗口内子字符串“满足每个字符出现次数大于等于k”这一属性也一直变化。因此说他是非单调的。</p>\n<p>我们换一个思路，换一个移动条件。那就是固定窗口内字符类型：比如说只有一种字符，aa满足条件；只有两种字符，aabb满足条件。这样一来的话，只要外层加个26个字母的循环即可。维护一个区间，让他满足区间内出现的字符类型为x。</p>\n<h2 id=\"424-替换后的最长重复字符\"><a href=\"#424-替换后的最长重复字符\" class=\"headerlink\" title=\"424. 替换后的最长重复字符\"></a><a href=\"https://leetcode-cn.com/problems/longest-repeating-character-replacement/\">424. 替换后的最长重复字符</a></h2><p>可变长度的滑动窗，我在建模的时候出了一点问题。可以将题目转换成：寻找一个区间，使得这个区间内出现次数最多的字母+k小于区间长度。</p>\n<p>思路好理解，但是加上一个优化的话这理解就在大气层了emm</p>\n<p>需要再做一遍的。</p>\n<p>Tips：</p>\n<ul>\n<li>滑动窗，右指针主动移动一个，左指针被动移动。</li>\n<li>窗口只可变大或不变。</li>\n</ul>\n<h2 id=\"438-找到字符串中所有字母异位词\"><a href=\"#438-找到字符串中所有字母异位词\" class=\"headerlink\" title=\"438. 找到字符串中所有字母异位词\"></a><a href=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/\">438. 找到字符串中所有字母异位词</a></h2><p>总是考虑得不太对，唉。</p>\n<h2 id=\"443-压缩字符串\"><a href=\"#443-压缩字符串\" class=\"headerlink\" title=\"443. 压缩字符串\"></a><a href=\"https://leetcode-cn.com/problems/string-compression/\">443. 压缩字符串</a></h2><p>做出了空间复杂度为O(n)的方法，主要是在数字填入字符串的部分。</p>\n<p>Tips：</p>\n<ul>\n<li>一般能做出O(n)但是要用O(1)的，需要时间换空间，不要觉得太复杂什么的就不写了，尝试一下。</li>\n<li>现在做题很难一次AC，需要根据错误的测试用例来debug，这样一来在不提供错误测试用例的笔试就会比较头疼，之前也都是这种情况。</li>\n<li>这道题目里，碰到的情况是：忘记覆盖无用字符了！也就是**[“a”,”a”,”a”,”b”,”b”,”a”,”a”]<strong>会返回</strong>[“a”,”3”,”a”,”b”,”2”,”a”,”2”]**的情况，第三个字符没有被覆盖，也是在做题最初的时候没有考虑到的。没想好，着急了</li>\n</ul>\n<p>记一个有点奇怪的事情</p>\n<p>这是我写的代码，最后一个测试用例过不了。。问题发现在哪里了！第九行应该是大于等于！！不然如果出现重复值的heater它就不会后移了！！！就检查不到后面的heater了！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findRadius</span><span class=\"params\">(<span class=\"keyword\">int</span>[] houses, <span class=\"keyword\">int</span>[] heaters)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, j=<span class=\"number\">0</span>;</span><br><span class=\"line\">        Arrays.sort(houses);</span><br><span class=\"line\">        Arrays.sort(heaters);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;houses.length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = Math.abs(heaters[j] - houses[i]);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(j+<span class=\"number\">1</span>&lt;heaters.length &amp;&amp; Math.abs(heaters[j] - houses[i]) &gt; Math.abs(heaters[j+<span class=\"number\">1</span>]- houses[i]))&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                len = Math.min(len, Math.abs(heaters[j]- houses[i]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = Math.max(res, len);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"519-随机翻转矩阵\"><a href=\"#519-随机翻转矩阵\" class=\"headerlink\" title=\"519. 随机翻转矩阵\"></a><a href=\"https://leetcode-cn.com/problems/random-flip-matrix/\">519. 随机翻转矩阵</a></h2><p>感觉和数据结构的关系更大，见：XX</p>\n<h2 id=\"524-通过删除字母匹配到字典里最长单词\"><a href=\"#524-通过删除字母匹配到字典里最长单词\" class=\"headerlink\" title=\"524. 通过删除字母匹配到字典里最长单词\"></a><a href=\"https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/\">524. 通过删除字母匹配到字典里最长单词</a></h2><p>这道题，咱们先来学习一下JAVA中的排序。</p>\n<p><a href=\"http://www.ibloger.net/article/2773.html\">Java8中Comparable和Comparator区别小结 - Java开发 - 程序喵</a></p>\n<p>Arrays.sort用于对数组排序，Collections.sort用于对集合排序。这两种方法默认是升序，都可以自定义实现，即通过<strong>重写比较器</strong>来自定义对象排序。</p>\n<blockquote>\n<p><strong>数组和集合的区别</strong></p>\n<p>数组是静态的，声明之后就无法改变容量；而集合是动态的。</p>\n<p>数组：array；集合：set，list</p>\n<p>数组-&gt;集合：Arrays.asList(arr)；集合-&gt;数组：list.toArray()</p>\n</blockquote>\n<p>唉思路对了，可是比较的时候居然又出问题了。逻辑没想清楚，容易出错。</p>\n<p>原来的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(String item:dictionary)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, j=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j&lt;item.length())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> ch = item.charAt(j);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;s.length() &amp;&amp; s.charAt(i++)!=ch);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==s.length()) <span class=\"keyword\">break</span>;\t<span class=\"comment\">// ！如果正好i在最后一个位置相等，造成j没有++而出错</span></span><br><span class=\"line\">        j++;\t\t\t\t\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j==item.length())&#123;</span><br><span class=\"line\">        res = item;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考题解后的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(String item:dictionary)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, j=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j&lt;item.length() &amp;&amp; i&lt;s.length())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(item.charAt(j) == s.charAt(i)) j++;\t\t<span class=\"comment\">// 一个指针指向item，一个指针指向s，相等就都前进，不等就只有i前进。不提前break，程序可能更不易出错。</span></span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j==item.length())&#123;</span><br><span class=\"line\">        res = item;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"581-最短无序连续子数组\"><a href=\"#581-最短无序连续子数组\" class=\"headerlink\" title=\"581. 最短无序连续子数组\"></a><a href=\"https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/\">581. 最短无序连续子数组</a></h2><p>看题解确实技巧性比较强。</p>\n<p>我的思路：从前往后找到第一个不满足nums[i]&lt;=nums[i+1]的索引，作为不符合升序的begin位置，再从后往前找到第一个不满足nums[j]&gt;=nums[j-1]的索引，作为不符合升序的end位置。遍历begin到end，找到区间[begin, end]内的最大值maxNum和最小值minNum。</p>\n<p>从begin-1往前找到第一个nums[i] &lt;= minNum的索引i，从end+1往后找到第一个nums[j] &gt;= maxNum的索引，j-i-1就是答案。这个算法最多扫描两次数组，算法复杂度为O(n)。</p>\n<p>题解：从前往后找最大值，并且找到最后一个小于最大值的索引。从后往前找最小值，并且找到最后一个大于最小值的索引。</p>\n<h2 id=\"611-有效三角形的个数\"><a href=\"#611-有效三角形的个数\" class=\"headerlink\" title=\"611. 有效三角形的个数\"></a><a href=\"https://leetcode-cn.com/problems/valid-triangle-number/\">611. 有效三角形的个数</a></h2><p>我只会暴力解法（表面：呜呜呜我好菜；内心：暴力yyds！</p>\n<p>咳，可以优化一下。仔细看看，三重循环事实上固定两个最小的，找大的边。转换一下思路，<strong>固定最大边</strong>，找剩下两个小的，运用双指针。这也是双指针减小搜索空间的应用。</p>\n<p>题解里还有数学解法的，没有仔细看。</p>\n<h2 id=\"825-适龄的朋友\"><a href=\"#825-适龄的朋友\" class=\"headerlink\" title=\"825. 适龄的朋友\"></a><a href=\"https://leetcode-cn.com/problems/friends-of-appropriate-ages/\">825. 适龄的朋友</a></h2><p>先要把题意分析清楚，可以发送请求的用户年龄在一个区间内。</p>\n<p>一个比较明显的思路：只要找到这个区间的左右端点即可。将数组排序后，左端点是第一个满足要求的用户的下标，右端点则是最后一个满足要求的用户下标。相减的时候减掉自身即可。这里如果每次左端点从零开始的话，运行会超时，像这样数字连续的序列，可以接着上次的搜索结果继续找。</p>\n<p>另外有一个思路，使用的<strong>前缀和</strong>。我们需要统计出在区间<code>(0.5 * age[x] + 7, age[x]]</code>之间的人数。就是说，设置一个前缀和数组<code>p[121]</code>，<code>p[i]</code>保存的就是年龄为<code>[0, i]</code>的总人数，那么<code>p[age[x]] - p[0.5 * age[x] + 7]</code>就是上述区间内的人数，然后再减去x自身，即减1就是下标x对应的答案。因为年龄小于120，按年龄遍历即可，每个年龄的结果记得乘上这个年龄的人数。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>双指针类型题目，持续更新</p>","more":"<p>Tips：</p>\n<ul>\n<li><p>双指针来<strong>减小搜索空间</strong></p>\n</li>\n<li><p>双指针可以分为对撞指针和快慢指针。对撞指针一般从序列的两端向中间进行遍历。而快慢指针从同一侧开始遍历但以不同的策略进行移动，直到两个指针的值相等或满足其他特殊条件（比如快指针走到序列底了）为止。</p>\n</li>\n<li><p>和滑动窗口相辅相成。</p>\n</li>\n<li><p>一个双指针模板（by<a href=\"https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/fen-xiang-zhen-cang-de-shuang-zhi-zhen-m-fdsk/\">负雪明烛</a>）（感觉说是滑动窗口模板更合适）</p>\n</li>\n</ul>\n<h1 id=\"Easy\"><a href=\"#Easy\" class=\"headerlink\" title=\"Easy\"></a>Easy</h1><h2 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a><a href=\"https://leetcode-cn.com/problems/remove-element/\">27. 移除元素</a></h2><p>方法一：双指针，把不符合条件的数字移到后面</p>\n<p>方法二：遍历数组，如果不等于val就保留。</p>\n<h2 id=\"88-合并两个有序数组\"><a href=\"#88-合并两个有序数组\" class=\"headerlink\" title=\"88. 合并两个有序数组\"></a><a href=\"https://leetcode-cn.com/problems/merge-sorted-array/\">88. 合并两个有序数组</a></h2><ul>\n<li>从后向前合并，利用num1的空余位置</li>\n</ul>\n<h2 id=\"345-反转字符串中的元音字母\"><a href=\"#345-反转字符串中的元音字母\" class=\"headerlink\" title=\"345. 反转字符串中的元音字母\"></a><a href=\"https://leetcode-cn.com/problems/reverse-vowels-of-a-string/\">345. 反转字符串中的元音字母</a></h2><ul>\n<li>一个指针从前往后，一个指针从后往前，都去找元音字母，我用一个set保存元音，要注意的是大小写都考虑到。</li>\n<li>String2Array：str.toCharArray(); Array2String：String.valueOf(ch)</li>\n</ul>\n<h2 id=\"455-分发饼干\"><a href=\"#455-分发饼干\" class=\"headerlink\" title=\"455. 分发饼干\"></a><a href=\"https://leetcode-cn.com/problems/assign-cookies/\">455. 分发饼干</a></h2><p>贪心。先满足胃口小的孩子。</p>\n<p>这里记一笔：我在判断大小的时候先相减，在判断减的结果是否小于零，这样可能会因为越界产生错误，所以直接判断大小就可以了。所以在做题的时候先要保证思路（代码框架和逻辑）正确（这里需要练习与随之而来的自信），然后再确定细节（比如越界、超时等等）（当然这里也需要很多练习与随之而来的经验）</p>\n<h2 id=\"485-最大连续-1-的个数\"><a href=\"#485-最大连续-1-的个数\" class=\"headerlink\" title=\"485. 最大连续 1 的个数\"></a><a href=\"https://leetcode-cn.com/problems/max-consecutive-ones/\">485. 最大连续 1 的个数</a></h2><p>简单题重拳出击。</p>\n<ul>\n<li>我的方法是每次循环找到第一个为1的位置，然后再找到第一个为0的位置</li>\n<li>也可以在对数组进行遍历，遇到1的时候，找0的位置；遇到0的时候，i++</li>\n</ul>\n<h2 id=\"1446-连续字符\"><a href=\"#1446-连续字符\" class=\"headerlink\" title=\"1446. 连续字符\"></a><a href=\"https://leetcode-cn.com/problems/consecutive-characters/\">1446. 连续字符</a></h2><ul>\n<li>设置两个指针，第一个固定，第二个移动到与第一个指向的字符不同的位置。</li>\n</ul>\n<h1 id=\"Medium\"><a href=\"#Medium\" class=\"headerlink\" title=\"Medium\"></a>Medium</h1><h2 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3. 无重复字符的最长子串\"></a><a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">3. 无重复字符的最长子串</a></h2><p>双指针，也是滑动窗口题</p>\n<p>用到了双指针的思想（一个指向首字母，一个指向尾字母）。</p>\n<ol>\n<li>设置指针start和end，用哈希表map来保存出现的字符和出现次数</li>\n<li>end指向的字符如果不在map中，加入map并使value+1</li>\n<li>当value大于1时，说明之前出现过这个字符</li>\n<li>移动start，并使map中对应字符value-1（即不出现在当前字符串中），直到end指向字符的value等于1（即只出现在刚才加入的地方），此时字符串中又没有重复字符了</li>\n<li>比较当前字符串长度（end-start+1）和之前保留结果maxLen，取大的那个值</li>\n</ol>\n<h2 id=\"11-盛最多水的容器\"><a href=\"#11-盛最多水的容器\" class=\"headerlink\" title=\"11. 盛最多水的容器\"></a><a href=\"https://leetcode-cn.com/problems/container-with-most-water/\">11. 盛最多水的容器</a></h2><p>双指针来减小搜索空间</p>\n<ul>\n<li>注意容器面积只取决于两边的板</li>\n<li>移动两者其中的短板，才有可能使面积变大；若移动长板，面积不变或变小；从而可以减小搜索空间</li>\n</ul>\n<h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15. 三数之和\"></a><a href=\"https://leetcode-cn.com/problems/3sum/\">15. 三数之和</a></h2><p>也是用双指针来减小搜索空间（固定一个元素，移动两个元素，两个指针往固定的方向移动，可以更好控制搜索空间的变化）</p>\n<ol>\n<li>先讲数组排序，可以更好处理重复的情况</li>\n<li>固定一个指针k，从第一个元素开始</li>\n<li>设置双指针left和right，分别在k+1和数组最后一个元素</li>\n<li>如果nums[k]&gt;0，三者之和一定大于零</li>\n<li>如果nums[k]==nums[k-1]，避免重复，直接跳过</li>\n<li>三者之和小于0，说明数太小，left往右移；大于0，则说明数太大，right往左移</li>\n</ol>\n<p>变形题：</p>\n<p><a href=\"https://leetcode-cn.com/problems/3sum-closest/\">16. 最接近的三数之和</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/4sum/\">18. 四数之和</a></p>\n<h2 id=\"45-跳跃游戏-II\"><a href=\"#45-跳跃游戏-II\" class=\"headerlink\" title=\"45. 跳跃游戏 II\"></a><a href=\"https://leetcode-cn.com/problems/jump-game-ii/\">45. 跳跃游戏 II</a></h2><p>维护一个最大边界（maxPosition），保存这次跳跃能到达的最远位置。</p>\n<p>当小人移动到本次跳跃的最远边界（end）时，就进入下一次跳跃，所以step++。</p>\n<p>初始状态下，end为0。</p>\n<h2 id=\"395-至少有-K-个重复字符的最长子串\"><a href=\"#395-至少有-K-个重复字符的最长子串\" class=\"headerlink\" title=\"395. 至少有 K 个重复字符的最长子串\"></a><a href=\"https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/\">395. 至少有 K 个重复字符的最长子串</a></h2><p>三叶的题解有点没看懂，有条件的滑动窗口。</p>\n<p><a href=\"https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/xiang-jie-mei-ju-shuang-zhi-zhen-jie-fa-50ri1/\">【宫水三叶の相信科学系列】为什么不能用「滑动窗口」？以及如何发掘题目性质 </a></p>\n<p>为什么三叶的第一反应是二分？我猜测一下，找到不满足条件的字符，将字符串一分为二，再接着找。</p>\n<p>为什么这就不满足二段性了啊？为什么这里双指针不具有单调性啊？</p>\n<p>假如说我现在用双指针来维护一个区间，让他满足左边界左侧的字符和右边界右侧的字符都不出现在子字符串内。如果我把右指针往右移，他有可能满足也可能不满足，那只要判断一下就行了呀，如果这个字符出现在里面，那就移，如果不出现就不移。</p>\n<p>或者如果不出现，那就移到出现为止，但是这样的话，移动不是单调的，就是说一直移动还是可能不满足条件的。</p>\n<p>为什么第三题可以用滑动窗口来做呢？如果我现在用双指针来维护一个区间，让他里面的字符不重复。如果我把右指针往右移，也是可能满足可能不满足。如果这个字符出现在里面，我就移动，然后让左指针移到原来出现的位置。</p>\n<p>但是这道题他不行。因为我右指针移动的话，左指针要怎么移呢。窗口内子字符串的”包含字符的数量“这一属性一直在变化，也就导致窗口内子字符串“满足每个字符出现次数大于等于k”这一属性也一直变化。因此说他是非单调的。</p>\n<p>我们换一个思路，换一个移动条件。那就是固定窗口内字符类型：比如说只有一种字符，aa满足条件；只有两种字符，aabb满足条件。这样一来的话，只要外层加个26个字母的循环即可。维护一个区间，让他满足区间内出现的字符类型为x。</p>\n<h2 id=\"424-替换后的最长重复字符\"><a href=\"#424-替换后的最长重复字符\" class=\"headerlink\" title=\"424. 替换后的最长重复字符\"></a><a href=\"https://leetcode-cn.com/problems/longest-repeating-character-replacement/\">424. 替换后的最长重复字符</a></h2><p>可变长度的滑动窗，我在建模的时候出了一点问题。可以将题目转换成：寻找一个区间，使得这个区间内出现次数最多的字母+k小于区间长度。</p>\n<p>思路好理解，但是加上一个优化的话这理解就在大气层了emm</p>\n<p>需要再做一遍的。</p>\n<p>Tips：</p>\n<ul>\n<li>滑动窗，右指针主动移动一个，左指针被动移动。</li>\n<li>窗口只可变大或不变。</li>\n</ul>\n<h2 id=\"438-找到字符串中所有字母异位词\"><a href=\"#438-找到字符串中所有字母异位词\" class=\"headerlink\" title=\"438. 找到字符串中所有字母异位词\"></a><a href=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/\">438. 找到字符串中所有字母异位词</a></h2><p>总是考虑得不太对，唉。</p>\n<h2 id=\"443-压缩字符串\"><a href=\"#443-压缩字符串\" class=\"headerlink\" title=\"443. 压缩字符串\"></a><a href=\"https://leetcode-cn.com/problems/string-compression/\">443. 压缩字符串</a></h2><p>做出了空间复杂度为O(n)的方法，主要是在数字填入字符串的部分。</p>\n<p>Tips：</p>\n<ul>\n<li>一般能做出O(n)但是要用O(1)的，需要时间换空间，不要觉得太复杂什么的就不写了，尝试一下。</li>\n<li>现在做题很难一次AC，需要根据错误的测试用例来debug，这样一来在不提供错误测试用例的笔试就会比较头疼，之前也都是这种情况。</li>\n<li>这道题目里，碰到的情况是：忘记覆盖无用字符了！也就是**[“a”,”a”,”a”,”b”,”b”,”a”,”a”]<strong>会返回</strong>[“a”,”3”,”a”,”b”,”2”,”a”,”2”]**的情况，第三个字符没有被覆盖，也是在做题最初的时候没有考虑到的。没想好，着急了</li>\n</ul>\n<p>记一个有点奇怪的事情</p>\n<p>这是我写的代码，最后一个测试用例过不了。。问题发现在哪里了！第九行应该是大于等于！！不然如果出现重复值的heater它就不会后移了！！！就检查不到后面的heater了！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findRadius</span><span class=\"params\">(<span class=\"keyword\">int</span>[] houses, <span class=\"keyword\">int</span>[] heaters)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, j=<span class=\"number\">0</span>;</span><br><span class=\"line\">        Arrays.sort(houses);</span><br><span class=\"line\">        Arrays.sort(heaters);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;houses.length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = Math.abs(heaters[j] - houses[i]);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(j+<span class=\"number\">1</span>&lt;heaters.length &amp;&amp; Math.abs(heaters[j] - houses[i]) &gt; Math.abs(heaters[j+<span class=\"number\">1</span>]- houses[i]))&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                len = Math.min(len, Math.abs(heaters[j]- houses[i]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = Math.max(res, len);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"519-随机翻转矩阵\"><a href=\"#519-随机翻转矩阵\" class=\"headerlink\" title=\"519. 随机翻转矩阵\"></a><a href=\"https://leetcode-cn.com/problems/random-flip-matrix/\">519. 随机翻转矩阵</a></h2><p>感觉和数据结构的关系更大，见：XX</p>\n<h2 id=\"524-通过删除字母匹配到字典里最长单词\"><a href=\"#524-通过删除字母匹配到字典里最长单词\" class=\"headerlink\" title=\"524. 通过删除字母匹配到字典里最长单词\"></a><a href=\"https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/\">524. 通过删除字母匹配到字典里最长单词</a></h2><p>这道题，咱们先来学习一下JAVA中的排序。</p>\n<p><a href=\"http://www.ibloger.net/article/2773.html\">Java8中Comparable和Comparator区别小结 - Java开发 - 程序喵</a></p>\n<p>Arrays.sort用于对数组排序，Collections.sort用于对集合排序。这两种方法默认是升序，都可以自定义实现，即通过<strong>重写比较器</strong>来自定义对象排序。</p>\n<blockquote>\n<p><strong>数组和集合的区别</strong></p>\n<p>数组是静态的，声明之后就无法改变容量；而集合是动态的。</p>\n<p>数组：array；集合：set，list</p>\n<p>数组-&gt;集合：Arrays.asList(arr)；集合-&gt;数组：list.toArray()</p>\n</blockquote>\n<p>唉思路对了，可是比较的时候居然又出问题了。逻辑没想清楚，容易出错。</p>\n<p>原来的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(String item:dictionary)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, j=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j&lt;item.length())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> ch = item.charAt(j);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;s.length() &amp;&amp; s.charAt(i++)!=ch);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==s.length()) <span class=\"keyword\">break</span>;\t<span class=\"comment\">// ！如果正好i在最后一个位置相等，造成j没有++而出错</span></span><br><span class=\"line\">        j++;\t\t\t\t\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j==item.length())&#123;</span><br><span class=\"line\">        res = item;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考题解后的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(String item:dictionary)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, j=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j&lt;item.length() &amp;&amp; i&lt;s.length())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(item.charAt(j) == s.charAt(i)) j++;\t\t<span class=\"comment\">// 一个指针指向item，一个指针指向s，相等就都前进，不等就只有i前进。不提前break，程序可能更不易出错。</span></span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j==item.length())&#123;</span><br><span class=\"line\">        res = item;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"581-最短无序连续子数组\"><a href=\"#581-最短无序连续子数组\" class=\"headerlink\" title=\"581. 最短无序连续子数组\"></a><a href=\"https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/\">581. 最短无序连续子数组</a></h2><p>看题解确实技巧性比较强。</p>\n<p>我的思路：从前往后找到第一个不满足nums[i]&lt;=nums[i+1]的索引，作为不符合升序的begin位置，再从后往前找到第一个不满足nums[j]&gt;=nums[j-1]的索引，作为不符合升序的end位置。遍历begin到end，找到区间[begin, end]内的最大值maxNum和最小值minNum。</p>\n<p>从begin-1往前找到第一个nums[i] &lt;= minNum的索引i，从end+1往后找到第一个nums[j] &gt;= maxNum的索引，j-i-1就是答案。这个算法最多扫描两次数组，算法复杂度为O(n)。</p>\n<p>题解：从前往后找最大值，并且找到最后一个小于最大值的索引。从后往前找最小值，并且找到最后一个大于最小值的索引。</p>\n<h2 id=\"611-有效三角形的个数\"><a href=\"#611-有效三角形的个数\" class=\"headerlink\" title=\"611. 有效三角形的个数\"></a><a href=\"https://leetcode-cn.com/problems/valid-triangle-number/\">611. 有效三角形的个数</a></h2><p>我只会暴力解法（表面：呜呜呜我好菜；内心：暴力yyds！</p>\n<p>咳，可以优化一下。仔细看看，三重循环事实上固定两个最小的，找大的边。转换一下思路，<strong>固定最大边</strong>，找剩下两个小的，运用双指针。这也是双指针减小搜索空间的应用。</p>\n<p>题解里还有数学解法的，没有仔细看。</p>\n<h2 id=\"825-适龄的朋友\"><a href=\"#825-适龄的朋友\" class=\"headerlink\" title=\"825. 适龄的朋友\"></a><a href=\"https://leetcode-cn.com/problems/friends-of-appropriate-ages/\">825. 适龄的朋友</a></h2><p>先要把题意分析清楚，可以发送请求的用户年龄在一个区间内。</p>\n<p>一个比较明显的思路：只要找到这个区间的左右端点即可。将数组排序后，左端点是第一个满足要求的用户的下标，右端点则是最后一个满足要求的用户下标。相减的时候减掉自身即可。这里如果每次左端点从零开始的话，运行会超时，像这样数字连续的序列，可以接着上次的搜索结果继续找。</p>\n<p>另外有一个思路，使用的<strong>前缀和</strong>。我们需要统计出在区间<code>(0.5 * age[x] + 7, age[x]]</code>之间的人数。就是说，设置一个前缀和数组<code>p[121]</code>，<code>p[i]</code>保存的就是年龄为<code>[0, i]</code>的总人数，那么<code>p[age[x]] - p[0.5 * age[x] + 7]</code>就是上述区间内的人数，然后再减去x自身，即减1就是下标x对应的答案。因为年龄小于120，按年龄遍历即可，每个年龄的结果记得乘上这个年龄的人数。</p>"},{"title":"Leetcode刷题之模拟","date":"2022-01-11T03:17:44.000Z","updated":"2022-01-11T03:17:44.000Z","_content":"\n\n\n模拟类型题目，持续更新\n\n<!--more-->\n\n参考网站：\n\n[模拟 · SharingSource/LogicStack-LeetCode Wiki](https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E6%A8%A1%E6%8B%9F)\n\nTips：\n\n- 其实一直不太理解模拟是什么意思...个人理解是模拟人碰到这个会怎么做（模拟“怎样才能得到答案”这个过程）\n- 哈希映射\n- 这个类型的题很明显地反映我Java用得不熟练.........\n\n# **简单**\n\n## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)\n\n- 咱就是说，经典题目\n- 除了暴力求解，就是用哈希表，但是哈希表的空间复杂度会高一些\n\n## [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)\n\n- String的一些方法：int indexOf(char ch)找元素下标，char charAt(int i)找下标对应的元素\n- 字符串可以相加。如果要加上一个字符可以写作：`str += String.valueOf('a')`\n- 我先求了最短字符串的长度，再循环的，可以在循环中判断不要超出长度。\n- 还有一种思路是从最后开始看，即判断字符串1是否在字符串2中，不存在就减小字符串1（另外设置一个变量）\n\n## [58. 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)\n\n- 比较简单。\n- 用while比起用for，代码会更好看（三叶的回答真的，又能给出题解又能给出漂亮的代码）。\n\n## [66. 加一](https://leetcode-cn.com/problems/plus-one/)\n\n- 模拟加法过程\n\n- 注意最后可能要加一位。至于最后加一位，直接这样写就可以了（Wow~）：\n\n  ```java\n  digits = new int[len + 1];\n  digits[0] = 1;\n  ```\n\n  为什么这样可以呢，不是复制了，而是取巧！因为最后要加一位的情况只有999到1000这一类，这个时候除了第一位都是0，而Java的int数组在初始化的时候就默认初始化为0！我靠！\n\n## [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n- 和第268题很像，不过268是固定范围内的数字，所以可以先相加再减出结果\n- 用位运算，异或即可\n\n## [168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)\n\n- 思路参考了二进制、十六进制的转换方法，但是这里从1而不是从0开始，验算的时候发现需要先减1。\n- 另外要注意`for`循环中`n1`和`n2`的前后关系！\n\n## [171. Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)\n\n- 和十进制一样\n\n## [263. 丑数](https://leetcode-cn.com/problems/ugly-number/)\n\n- 2、3、5每个都除一下，每个都要除到不能再除为止（即余数不为零）\n- 我设了一个变量保存余数，发现直接写在while条件里面会更好看，代码还是得看三叶姐姐：[【宫水三叶】简单的分情况讨论题](https://leetcode-cn.com/problems/ugly-number/solution/gong-shui-san-xie-jian-dan-de-fen-qing-k-dlvg/)\n\n## [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)\n\n- 我是**相加然后求差**~\n\n- 先排序后求。排序方法：Arrays.sort(nums)\n\n- 找缺失数、找出现一次数都是**异或**的经典应用。 ——三叶姐姐\n\n  异或性质：$0 \\oplus x=x$，$x\\oplus x=0$\n\n  所以如果要找缺失数，就把完整序列和0异或一次，再和当前序列异或一次，得到的就是缺失数啦！\n\n## [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)\n\n- 因为字符串由26个小写字母组成，所以只要先统计magazine里的字母，再减去ransomNote里的字母出现次数就可以了\n- 注意magazine的字符只能用一次，**当然也可以不用**（谁想当然了？我想当然了）\n\n## [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)\n\n也是需要关注代码更优雅的一个写法\n\n- 因为想要用到字符串反转，所以得用StringBuilder不用String，StringBuilder可以直接append数字。\n- 更简洁明了的表示：三元运算符；超出数字的部分就是0。\n- 注意最后的进位\n- 做完这一题就可以去做[43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)\n\n\n\n# **中等**\n\n## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)\n\n- 模拟两式相加的过程\n- 注意点见链表部分：[Leetcode刷题之链表 | StrayInCosmos](https://cosmos227.top/2021/12/29/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E9%93%BE%E8%A1%A8/#%E4%B8%AD%E7%AD%89)\n\n\n\n## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n经典题，但我不会（只能想到暴力循环）\n\n[详细通俗的思路分析，多解法 - 最长回文子串 - 力扣（LeetCode）](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/)\n\n- 动态规划\n\n先定义**状态S(i, j)**表示从i到j的子字符串，是否为回文串表示为P(i,j)。**如果一个字符串是回文串，它去掉两端还是一个回文串**，这就有了**状态转移方程**，$P(i,j)=P(i+1,j-1) \\and (S_i == S_j)$。边界条件，长度为1的子字符串为回文串，长度为2的子字符串若字符相等也为回文串。\n\n- 最长公共子串（回文就是正着反着读都一样，把原始字符串倒置后找两者最长公共子字符串）\n\n用动态规划的思想做，同时在找到最长公共子串的时候也要确定下标是不是匹配（只需要看结尾下标是不是匹配）。\n\n- 中心扩展法\n\n列举所有可能的回文中心并向两边进行拓展。注意字符串长度为奇数和偶数两种情况，奇数时以一个字符作中心，偶数以两个字符作为中心。\n\n- Manacher算法\n\n只有O(n)的算法复杂度。插入#符号来考虑偶回文串，利用对称性。\n\n只能处理回文串问题，一般面试不考，略过。\n\n\n\n## [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)\n\n- 利用好StringBuilder类\n- 设置标志位，确定是否需要变换行索引\n- 对String对象做遍历的时候，可以用：`for(char c: str.toArray()) ...`\n\n\n\n## [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)\n\n- Integer.MAX_VALUE和Integer.MIN_VALUE\n- 我用了long类型来保存，从而可以判断是否越界，return的时候再换回去就行。\n- 但是保持用int类型会更好，判断的方法是在**把result乘十之前**，判断一下**result有没有大于Integer.MAX_VALUE/10**，或者**如果等于Integer.MAX_VALUE/10时，当前位置的数字有没有大于Integer.MAX_VALU%10**\n\n\n\n## [38. 外观数列](https://leetcode-cn.com/problems/count-and-say/)\n\n这道题目理解题意都花了会时间（doge\n\n- 找重复序列的方法需要更优雅一点，一开始自己想的越想越复杂，简洁明了的才是好办法~\n- 设置双指针，一个在标记点，另一个移动直到和标记点不同的索引为止。\n- 另外整数合并到字符串上，用Integer.toString()或者直接加到字符串上，但是要注意的是直接数字加字符会出错（比如`1+'a'`)，这个时候加上一个空字符串即可（比如`1+\"\"+'a'`）\n\n\n\n## [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)\n\n- [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)的下一题\n- 我自己用的是模拟列竖式手算然后两个字符串相加的过程，和415这题一样要注意**进位**的问题！同时要注意补零，以及判断是否有字符串为\"0\"，这时只要输出一个\"0\"而不是\"0000\"\n- 看了几个题解都提到优化竖式，方法比较巧妙，讲解可以看：[优化版竖式(打败99.4%)](https://leetcode-cn.com/problems/multiply-strings/solution/you-hua-ban-shu-shi-da-bai-994-by-breezean/)；代码我更喜欢三叶写的：[只要你会手算乘法，这题能能过 ~](https://leetcode-cn.com/problems/multiply-strings/solution/zhi-yao-ni-hui-shou-suan-cheng-fa-zhe-ti-ainl/)\n\n\n\n## [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)\n\n- 看到这个[题解](https://leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/)的时候，我只会\"Wow~~\"\n\n\n\n## [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)\n\n- 用**栈**。注意考虑边界条件，栈为空的时候返回\"/\"；另外用好条件判断（if，else if）；可以用split来划分出目录名。\n\n- Java中的**Deque**，对Queue的拓展，实现了头尾都可以进出。Deque是一个接口，可以用LinkedList或ArrayDeque来实现（两者区别，ArrayDeque是不能用索引操作的，因此如果只用到头尾，ArrayDeque的效率更高）\n\n- pollLast和removeLast，都是删除最后元素，但是后者不允许数组为空，前者允许，为空时返回null。\n\n\n\n## [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)\n\n- 某行或某列有零，该行或列全为零，利用这个特点来记录标志\n- 需要设置标志，表示该位置是否需要置零。除了额外m+n的空间，直接在当前数组上设置标记，会使额外空间更小。\n- 注意特殊情况的记录，即第一行、第一列上有为零的情况。\n\n\n\n## [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)\n\n- 直接看答案了，记住得了\n- 没有理解为什么求第几个数的格雷码就是$g(i) = b(i)\\oplus b(i/2) $。先搁着，真遇到了就用对称来求解。\n\n\n\n## [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)\n\n- 直接按序比较即可，本来想说用栈，其实是把简单问题复杂化了。对于前导零，和别的数字一样计算即可。\n- 可以用split对字符串分组，此时注意要用`split(\"\\\\.\")`，因为split是利用正则来分割的，对于`.`之类的特殊符号前面要加`\\\\`转义符。\n- 也可以直接用while，到字符`.`为止即可。\n\n\n\n## [166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)\n\n- 模拟手算除法的过程，如果遇到已经出现过的余数，循环就开始了，所以要**记录余数以及出现的位置**。可以用哈希表来记录。\n- 注意模拟除法手算的过程，一直都是和余数有关的。\n- 另外，要避免计算溢出，因此要把int转换为long来计算。注意在加负号之后，需要把分子和分母取绝对值。\n- 参考题解：[【宫水三叶】模拟竖式计算（除法）](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/gong-shui-san-xie-mo-ni-shu-shi-ji-suan-kq8c4/)\n\n\n\n## [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)\n\n- 朴素方法用哈希表\n\n- 常数空间复杂度的用位运算。因为除了一个数字出现一次以外，别的数字出现三次，利用这一点取余数操作。具体而言，首先统计每一位上的数（求和），如果统计得到的数可以被3整除，说明多出来的那个数字为0（其余为1或0的相加结果都会被3整除）；若统计得到的数不能被3整除，说明多出来的那个数字为1。由此可以保存这个数字每一位的值，再从二进制转为十进制返回即可。\n\n- 从操作上来看，由于数字是int类型，所以用int[32] cnt的数组保存每一位上的值即可。在统计时，外循环是对nums中的每个数，内循环是对每一位（一共32位）统计到cnt中去。这里可以用右移操作与1比较，从而得到每一位上的值，当与1相等时，cnt对应位的值++。而在从二进制数组返回得到十进制值时，可以用左移操作来加。\n\n- 另外还有有限状态自动机，这个看得一知半解，也先搁着了~（可参考[只出现一次的数字 II（有限状态自动机 + 位运算，清晰图解）](https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/)）\n\n  \n\n## [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)\n\n- 朴素方法用哈希表来保存出现过的数字，但题目要求空间复杂度是常数的，能想到用位运算，但是不会了\n- 位运算看了一会才有点理解。首先所有数字异或，得到的结果一定不为零（因为有两个只出现一次的数字）。拿这个异或结果，取任意一个有效位（即值为1的位）（这个位表示这两个数字在这一位上是不一样的，一个在这一位上为1另一个为0），得到一个mask（比如第二位有效则mask是`0010`)（这里有一种简洁的方法，取最低有效位LSB）。再用这个mask去和所有数字异或，就可以把数字们分成两组了，即这个位为1的是一组，这个位为0的是另一组，因为其他数字都是出现两次的，所以每组异或出来的结果就是我们想要找的数字。\n\n- 异或：`^`；与：`&`；或：`|`（注意和逻辑判断区分开）\n- 哈希表方法`getOrDefault(key, defaultValue)`：获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值\n\n>  参考题解：\n>\n> [采用分治的思想将问题降维](https://leetcode-cn.com/problems/single-number-iii/solution/cai-yong-fen-zhi-de-si-xiang-jiang-wen-ti-jiang-we/)\n>\n> [【宫水三叶】一题双解 :「哈希表」&「异或」](https://leetcode-cn.com/problems/single-number-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-zgi4/)\n\n# 困难\n\n## [233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/)\n\n- tmd看不懂\n- 我可以理解**数位DP**，引用咱们[K神的话](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/)就是说 1~ n 的个位、十位、百位、...的 1 出现次数相加，即为 1 出现的总次数。\n- 于是我们可以按位循环。令第i位上的数值$n^i=b$，位数为${10} ^ i =m$（i从零开始）。思想就是固定这一位，然后看它左边（高位）的数字和右边（低位）的数字，来得到此时的个数。我们再令高位数字为a，低位数字为b。比如原始数字为56219，再比如我们现在循环到千位上了，也就是b=2，m=100，a=56，c=19。现在呢我们要找的数字是1，由于这一位上的2是大于1的，**那么我们现在可以另它为1，左半部分变化一下就会让1出现次数加一次，右半部分变化一下也会让1的出现次数加一次**。而因为2大于1，左边数字取的只要不大于高位部分，右边数字可以随便取都能保证可以取到的。所以这个时候，1出现在千位上的次数只和a有关，是$(a+1)*m$。换个角度理解一下：可以把高位和低位拼起来，不超过5699就可以，即可以取到0~5699，即$(a+1)*m$\n\n- 为了好理解，我还是拿千分位的数字做例子，所以把原始数字换成56119，现在b=1，其他还是不变的m=100，a=56，c=19。那么现在b和要找的数字1一样大了，我们看看会左右部分可以怎么变了：右边还是一样，只要不大于a就行，但是左边就不是，当a=56的时候，左边不能超过19了。这个时候我们还是把千位拿掉，看看高位拼低位能取到多少，最大应该是5619，最小还是可以到0，所以可以取到的数字0~5619。即$a*m+c+1$\n- 然后就剩最后一种情况了，即把原始数字换成56019，现在b=0，其他还是不变的m=100，a=56，c=19。现在b小于1了，那如果还是想统计千位为1的出现次数，那就左边不能大于56了，最多取到55即a-1，这样才能让千位取到1，然后这个时候，咱们的低位又可以随便取啦！所以此时只和左边的数字有关，即$a*m$。我们再千位拿掉，把高位低位拼起来，最大是多少相信你也会了：5599，所以这个时候的范围是0~5599，即$a*m$\n\n- 扩展一下：[P1980 [NOIP2013 普及组] 计数问题 - 洛谷](https://www.luogu.com.cn/problem/P1980)\n  \n","source":"_posts/Leetcode刷题之模拟.md","raw":"---\ntitle: Leetcode刷题之模拟\ndate: 2022-01-11 11:17:44\nupdated: 2022-01-11 11:17:44\ncategories: 刷题\ntags: 模拟\n---\n\n\n\n模拟类型题目，持续更新\n\n<!--more-->\n\n参考网站：\n\n[模拟 · SharingSource/LogicStack-LeetCode Wiki](https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E6%A8%A1%E6%8B%9F)\n\nTips：\n\n- 其实一直不太理解模拟是什么意思...个人理解是模拟人碰到这个会怎么做（模拟“怎样才能得到答案”这个过程）\n- 哈希映射\n- 这个类型的题很明显地反映我Java用得不熟练.........\n\n# **简单**\n\n## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)\n\n- 咱就是说，经典题目\n- 除了暴力求解，就是用哈希表，但是哈希表的空间复杂度会高一些\n\n## [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)\n\n- String的一些方法：int indexOf(char ch)找元素下标，char charAt(int i)找下标对应的元素\n- 字符串可以相加。如果要加上一个字符可以写作：`str += String.valueOf('a')`\n- 我先求了最短字符串的长度，再循环的，可以在循环中判断不要超出长度。\n- 还有一种思路是从最后开始看，即判断字符串1是否在字符串2中，不存在就减小字符串1（另外设置一个变量）\n\n## [58. 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)\n\n- 比较简单。\n- 用while比起用for，代码会更好看（三叶的回答真的，又能给出题解又能给出漂亮的代码）。\n\n## [66. 加一](https://leetcode-cn.com/problems/plus-one/)\n\n- 模拟加法过程\n\n- 注意最后可能要加一位。至于最后加一位，直接这样写就可以了（Wow~）：\n\n  ```java\n  digits = new int[len + 1];\n  digits[0] = 1;\n  ```\n\n  为什么这样可以呢，不是复制了，而是取巧！因为最后要加一位的情况只有999到1000这一类，这个时候除了第一位都是0，而Java的int数组在初始化的时候就默认初始化为0！我靠！\n\n## [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n- 和第268题很像，不过268是固定范围内的数字，所以可以先相加再减出结果\n- 用位运算，异或即可\n\n## [168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)\n\n- 思路参考了二进制、十六进制的转换方法，但是这里从1而不是从0开始，验算的时候发现需要先减1。\n- 另外要注意`for`循环中`n1`和`n2`的前后关系！\n\n## [171. Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)\n\n- 和十进制一样\n\n## [263. 丑数](https://leetcode-cn.com/problems/ugly-number/)\n\n- 2、3、5每个都除一下，每个都要除到不能再除为止（即余数不为零）\n- 我设了一个变量保存余数，发现直接写在while条件里面会更好看，代码还是得看三叶姐姐：[【宫水三叶】简单的分情况讨论题](https://leetcode-cn.com/problems/ugly-number/solution/gong-shui-san-xie-jian-dan-de-fen-qing-k-dlvg/)\n\n## [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)\n\n- 我是**相加然后求差**~\n\n- 先排序后求。排序方法：Arrays.sort(nums)\n\n- 找缺失数、找出现一次数都是**异或**的经典应用。 ——三叶姐姐\n\n  异或性质：$0 \\oplus x=x$，$x\\oplus x=0$\n\n  所以如果要找缺失数，就把完整序列和0异或一次，再和当前序列异或一次，得到的就是缺失数啦！\n\n## [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)\n\n- 因为字符串由26个小写字母组成，所以只要先统计magazine里的字母，再减去ransomNote里的字母出现次数就可以了\n- 注意magazine的字符只能用一次，**当然也可以不用**（谁想当然了？我想当然了）\n\n## [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)\n\n也是需要关注代码更优雅的一个写法\n\n- 因为想要用到字符串反转，所以得用StringBuilder不用String，StringBuilder可以直接append数字。\n- 更简洁明了的表示：三元运算符；超出数字的部分就是0。\n- 注意最后的进位\n- 做完这一题就可以去做[43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)\n\n\n\n# **中等**\n\n## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)\n\n- 模拟两式相加的过程\n- 注意点见链表部分：[Leetcode刷题之链表 | StrayInCosmos](https://cosmos227.top/2021/12/29/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E9%93%BE%E8%A1%A8/#%E4%B8%AD%E7%AD%89)\n\n\n\n## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n经典题，但我不会（只能想到暴力循环）\n\n[详细通俗的思路分析，多解法 - 最长回文子串 - 力扣（LeetCode）](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/)\n\n- 动态规划\n\n先定义**状态S(i, j)**表示从i到j的子字符串，是否为回文串表示为P(i,j)。**如果一个字符串是回文串，它去掉两端还是一个回文串**，这就有了**状态转移方程**，$P(i,j)=P(i+1,j-1) \\and (S_i == S_j)$。边界条件，长度为1的子字符串为回文串，长度为2的子字符串若字符相等也为回文串。\n\n- 最长公共子串（回文就是正着反着读都一样，把原始字符串倒置后找两者最长公共子字符串）\n\n用动态规划的思想做，同时在找到最长公共子串的时候也要确定下标是不是匹配（只需要看结尾下标是不是匹配）。\n\n- 中心扩展法\n\n列举所有可能的回文中心并向两边进行拓展。注意字符串长度为奇数和偶数两种情况，奇数时以一个字符作中心，偶数以两个字符作为中心。\n\n- Manacher算法\n\n只有O(n)的算法复杂度。插入#符号来考虑偶回文串，利用对称性。\n\n只能处理回文串问题，一般面试不考，略过。\n\n\n\n## [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)\n\n- 利用好StringBuilder类\n- 设置标志位，确定是否需要变换行索引\n- 对String对象做遍历的时候，可以用：`for(char c: str.toArray()) ...`\n\n\n\n## [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)\n\n- Integer.MAX_VALUE和Integer.MIN_VALUE\n- 我用了long类型来保存，从而可以判断是否越界，return的时候再换回去就行。\n- 但是保持用int类型会更好，判断的方法是在**把result乘十之前**，判断一下**result有没有大于Integer.MAX_VALUE/10**，或者**如果等于Integer.MAX_VALUE/10时，当前位置的数字有没有大于Integer.MAX_VALU%10**\n\n\n\n## [38. 外观数列](https://leetcode-cn.com/problems/count-and-say/)\n\n这道题目理解题意都花了会时间（doge\n\n- 找重复序列的方法需要更优雅一点，一开始自己想的越想越复杂，简洁明了的才是好办法~\n- 设置双指针，一个在标记点，另一个移动直到和标记点不同的索引为止。\n- 另外整数合并到字符串上，用Integer.toString()或者直接加到字符串上，但是要注意的是直接数字加字符会出错（比如`1+'a'`)，这个时候加上一个空字符串即可（比如`1+\"\"+'a'`）\n\n\n\n## [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)\n\n- [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)的下一题\n- 我自己用的是模拟列竖式手算然后两个字符串相加的过程，和415这题一样要注意**进位**的问题！同时要注意补零，以及判断是否有字符串为\"0\"，这时只要输出一个\"0\"而不是\"0000\"\n- 看了几个题解都提到优化竖式，方法比较巧妙，讲解可以看：[优化版竖式(打败99.4%)](https://leetcode-cn.com/problems/multiply-strings/solution/you-hua-ban-shu-shi-da-bai-994-by-breezean/)；代码我更喜欢三叶写的：[只要你会手算乘法，这题能能过 ~](https://leetcode-cn.com/problems/multiply-strings/solution/zhi-yao-ni-hui-shou-suan-cheng-fa-zhe-ti-ainl/)\n\n\n\n## [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)\n\n- 看到这个[题解](https://leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/)的时候，我只会\"Wow~~\"\n\n\n\n## [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)\n\n- 用**栈**。注意考虑边界条件，栈为空的时候返回\"/\"；另外用好条件判断（if，else if）；可以用split来划分出目录名。\n\n- Java中的**Deque**，对Queue的拓展，实现了头尾都可以进出。Deque是一个接口，可以用LinkedList或ArrayDeque来实现（两者区别，ArrayDeque是不能用索引操作的，因此如果只用到头尾，ArrayDeque的效率更高）\n\n- pollLast和removeLast，都是删除最后元素，但是后者不允许数组为空，前者允许，为空时返回null。\n\n\n\n## [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)\n\n- 某行或某列有零，该行或列全为零，利用这个特点来记录标志\n- 需要设置标志，表示该位置是否需要置零。除了额外m+n的空间，直接在当前数组上设置标记，会使额外空间更小。\n- 注意特殊情况的记录，即第一行、第一列上有为零的情况。\n\n\n\n## [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)\n\n- 直接看答案了，记住得了\n- 没有理解为什么求第几个数的格雷码就是$g(i) = b(i)\\oplus b(i/2) $。先搁着，真遇到了就用对称来求解。\n\n\n\n## [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)\n\n- 直接按序比较即可，本来想说用栈，其实是把简单问题复杂化了。对于前导零，和别的数字一样计算即可。\n- 可以用split对字符串分组，此时注意要用`split(\"\\\\.\")`，因为split是利用正则来分割的，对于`.`之类的特殊符号前面要加`\\\\`转义符。\n- 也可以直接用while，到字符`.`为止即可。\n\n\n\n## [166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)\n\n- 模拟手算除法的过程，如果遇到已经出现过的余数，循环就开始了，所以要**记录余数以及出现的位置**。可以用哈希表来记录。\n- 注意模拟除法手算的过程，一直都是和余数有关的。\n- 另外，要避免计算溢出，因此要把int转换为long来计算。注意在加负号之后，需要把分子和分母取绝对值。\n- 参考题解：[【宫水三叶】模拟竖式计算（除法）](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/gong-shui-san-xie-mo-ni-shu-shi-ji-suan-kq8c4/)\n\n\n\n## [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)\n\n- 朴素方法用哈希表\n\n- 常数空间复杂度的用位运算。因为除了一个数字出现一次以外，别的数字出现三次，利用这一点取余数操作。具体而言，首先统计每一位上的数（求和），如果统计得到的数可以被3整除，说明多出来的那个数字为0（其余为1或0的相加结果都会被3整除）；若统计得到的数不能被3整除，说明多出来的那个数字为1。由此可以保存这个数字每一位的值，再从二进制转为十进制返回即可。\n\n- 从操作上来看，由于数字是int类型，所以用int[32] cnt的数组保存每一位上的值即可。在统计时，外循环是对nums中的每个数，内循环是对每一位（一共32位）统计到cnt中去。这里可以用右移操作与1比较，从而得到每一位上的值，当与1相等时，cnt对应位的值++。而在从二进制数组返回得到十进制值时，可以用左移操作来加。\n\n- 另外还有有限状态自动机，这个看得一知半解，也先搁着了~（可参考[只出现一次的数字 II（有限状态自动机 + 位运算，清晰图解）](https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/)）\n\n  \n\n## [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)\n\n- 朴素方法用哈希表来保存出现过的数字，但题目要求空间复杂度是常数的，能想到用位运算，但是不会了\n- 位运算看了一会才有点理解。首先所有数字异或，得到的结果一定不为零（因为有两个只出现一次的数字）。拿这个异或结果，取任意一个有效位（即值为1的位）（这个位表示这两个数字在这一位上是不一样的，一个在这一位上为1另一个为0），得到一个mask（比如第二位有效则mask是`0010`)（这里有一种简洁的方法，取最低有效位LSB）。再用这个mask去和所有数字异或，就可以把数字们分成两组了，即这个位为1的是一组，这个位为0的是另一组，因为其他数字都是出现两次的，所以每组异或出来的结果就是我们想要找的数字。\n\n- 异或：`^`；与：`&`；或：`|`（注意和逻辑判断区分开）\n- 哈希表方法`getOrDefault(key, defaultValue)`：获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值\n\n>  参考题解：\n>\n> [采用分治的思想将问题降维](https://leetcode-cn.com/problems/single-number-iii/solution/cai-yong-fen-zhi-de-si-xiang-jiang-wen-ti-jiang-we/)\n>\n> [【宫水三叶】一题双解 :「哈希表」&「异或」](https://leetcode-cn.com/problems/single-number-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-zgi4/)\n\n# 困难\n\n## [233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/)\n\n- tmd看不懂\n- 我可以理解**数位DP**，引用咱们[K神的话](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/)就是说 1~ n 的个位、十位、百位、...的 1 出现次数相加，即为 1 出现的总次数。\n- 于是我们可以按位循环。令第i位上的数值$n^i=b$，位数为${10} ^ i =m$（i从零开始）。思想就是固定这一位，然后看它左边（高位）的数字和右边（低位）的数字，来得到此时的个数。我们再令高位数字为a，低位数字为b。比如原始数字为56219，再比如我们现在循环到千位上了，也就是b=2，m=100，a=56，c=19。现在呢我们要找的数字是1，由于这一位上的2是大于1的，**那么我们现在可以另它为1，左半部分变化一下就会让1出现次数加一次，右半部分变化一下也会让1的出现次数加一次**。而因为2大于1，左边数字取的只要不大于高位部分，右边数字可以随便取都能保证可以取到的。所以这个时候，1出现在千位上的次数只和a有关，是$(a+1)*m$。换个角度理解一下：可以把高位和低位拼起来，不超过5699就可以，即可以取到0~5699，即$(a+1)*m$\n\n- 为了好理解，我还是拿千分位的数字做例子，所以把原始数字换成56119，现在b=1，其他还是不变的m=100，a=56，c=19。那么现在b和要找的数字1一样大了，我们看看会左右部分可以怎么变了：右边还是一样，只要不大于a就行，但是左边就不是，当a=56的时候，左边不能超过19了。这个时候我们还是把千位拿掉，看看高位拼低位能取到多少，最大应该是5619，最小还是可以到0，所以可以取到的数字0~5619。即$a*m+c+1$\n- 然后就剩最后一种情况了，即把原始数字换成56019，现在b=0，其他还是不变的m=100，a=56，c=19。现在b小于1了，那如果还是想统计千位为1的出现次数，那就左边不能大于56了，最多取到55即a-1，这样才能让千位取到1，然后这个时候，咱们的低位又可以随便取啦！所以此时只和左边的数字有关，即$a*m$。我们再千位拿掉，把高位低位拼起来，最大是多少相信你也会了：5599，所以这个时候的范围是0~5599，即$a*m$\n\n- 扩展一下：[P1980 [NOIP2013 普及组] 计数问题 - 洛谷](https://www.luogu.com.cn/problem/P1980)\n  \n","slug":"Leetcode刷题之模拟","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggt001138t4cdh382hs","content":"<p>模拟类型题目，持续更新</p>\n<span id=\"more\"></span>\n\n<p>参考网站：</p>\n<p><a href=\"https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E6%A8%A1%E6%8B%9F\">模拟 · SharingSource/LogicStack-LeetCode Wiki</a></p>\n<p>Tips：</p>\n<ul>\n<li>其实一直不太理解模拟是什么意思…个人理解是模拟人碰到这个会怎么做（模拟“怎样才能得到答案”这个过程）</li>\n<li>哈希映射</li>\n<li>这个类型的题很明显地反映我Java用得不熟练………</li>\n</ul>\n<h1 id=\"简单\"><a href=\"#简单\" class=\"headerlink\" title=\"简单\"></a><strong>简单</strong></h1><h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1. 两数之和\"></a><a href=\"https://leetcode-cn.com/problems/two-sum/\">1. 两数之和</a></h2><ul>\n<li>咱就是说，经典题目</li>\n<li>除了暴力求解，就是用哈希表，但是哈希表的空间复杂度会高一些</li>\n</ul>\n<h2 id=\"14-最长公共前缀\"><a href=\"#14-最长公共前缀\" class=\"headerlink\" title=\"14. 最长公共前缀\"></a><a href=\"https://leetcode-cn.com/problems/longest-common-prefix/\">14. 最长公共前缀</a></h2><ul>\n<li>String的一些方法：int indexOf(char ch)找元素下标，char charAt(int i)找下标对应的元素</li>\n<li>字符串可以相加。如果要加上一个字符可以写作：<code>str += String.valueOf(&#39;a&#39;)</code></li>\n<li>我先求了最短字符串的长度，再循环的，可以在循环中判断不要超出长度。</li>\n<li>还有一种思路是从最后开始看，即判断字符串1是否在字符串2中，不存在就减小字符串1（另外设置一个变量）</li>\n</ul>\n<h2 id=\"58-最后一个单词的长度\"><a href=\"#58-最后一个单词的长度\" class=\"headerlink\" title=\"58. 最后一个单词的长度\"></a><a href=\"https://leetcode-cn.com/problems/length-of-last-word/\">58. 最后一个单词的长度</a></h2><ul>\n<li>比较简单。</li>\n<li>用while比起用for，代码会更好看（三叶的回答真的，又能给出题解又能给出漂亮的代码）。</li>\n</ul>\n<h2 id=\"66-加一\"><a href=\"#66-加一\" class=\"headerlink\" title=\"66. 加一\"></a><a href=\"https://leetcode-cn.com/problems/plus-one/\">66. 加一</a></h2><ul>\n<li><p>模拟加法过程</p>\n</li>\n<li><p>注意最后可能要加一位。至于最后加一位，直接这样写就可以了（Wow~）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">digits = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len + <span class=\"number\">1</span>];</span><br><span class=\"line\">digits[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>为什么这样可以呢，不是复制了，而是取巧！因为最后要加一位的情况只有999到1000这一类，这个时候除了第一位都是0，而Java的int数组在初始化的时候就默认初始化为0！我靠！</p>\n</li>\n</ul>\n<h2 id=\"136-只出现一次的数字\"><a href=\"#136-只出现一次的数字\" class=\"headerlink\" title=\"136. 只出现一次的数字\"></a><a href=\"https://leetcode-cn.com/problems/single-number/\">136. 只出现一次的数字</a></h2><ul>\n<li>和第268题很像，不过268是固定范围内的数字，所以可以先相加再减出结果</li>\n<li>用位运算，异或即可</li>\n</ul>\n<h2 id=\"168-Excel表列名称\"><a href=\"#168-Excel表列名称\" class=\"headerlink\" title=\"168. Excel表列名称\"></a><a href=\"https://leetcode-cn.com/problems/excel-sheet-column-title/\">168. Excel表列名称</a></h2><ul>\n<li>思路参考了二进制、十六进制的转换方法，但是这里从1而不是从0开始，验算的时候发现需要先减1。</li>\n<li>另外要注意<code>for</code>循环中<code>n1</code>和<code>n2</code>的前后关系！</li>\n</ul>\n<h2 id=\"171-Excel表列序号\"><a href=\"#171-Excel表列序号\" class=\"headerlink\" title=\"171. Excel表列序号\"></a><a href=\"https://leetcode-cn.com/problems/excel-sheet-column-number/\">171. Excel表列序号</a></h2><ul>\n<li>和十进制一样</li>\n</ul>\n<h2 id=\"263-丑数\"><a href=\"#263-丑数\" class=\"headerlink\" title=\"263. 丑数\"></a><a href=\"https://leetcode-cn.com/problems/ugly-number/\">263. 丑数</a></h2><ul>\n<li>2、3、5每个都除一下，每个都要除到不能再除为止（即余数不为零）</li>\n<li>我设了一个变量保存余数，发现直接写在while条件里面会更好看，代码还是得看三叶姐姐：<a href=\"https://leetcode-cn.com/problems/ugly-number/solution/gong-shui-san-xie-jian-dan-de-fen-qing-k-dlvg/\">【宫水三叶】简单的分情况讨论题</a></li>\n</ul>\n<h2 id=\"268-丢失的数字\"><a href=\"#268-丢失的数字\" class=\"headerlink\" title=\"268. 丢失的数字\"></a><a href=\"https://leetcode-cn.com/problems/missing-number/\">268. 丢失的数字</a></h2><ul>\n<li><p>我是<strong>相加然后求差</strong>~</p>\n</li>\n<li><p>先排序后求。排序方法：Arrays.sort(nums)</p>\n</li>\n<li><p>找缺失数、找出现一次数都是<strong>异或</strong>的经典应用。 ——三叶姐姐</p>\n<p>异或性质：$0 \\oplus x=x$，$x\\oplus x=0$</p>\n<p>所以如果要找缺失数，就把完整序列和0异或一次，再和当前序列异或一次，得到的就是缺失数啦！</p>\n</li>\n</ul>\n<h2 id=\"383-赎金信\"><a href=\"#383-赎金信\" class=\"headerlink\" title=\"383. 赎金信\"></a><a href=\"https://leetcode-cn.com/problems/ransom-note/\">383. 赎金信</a></h2><ul>\n<li>因为字符串由26个小写字母组成，所以只要先统计magazine里的字母，再减去ransomNote里的字母出现次数就可以了</li>\n<li>注意magazine的字符只能用一次，<strong>当然也可以不用</strong>（谁想当然了？我想当然了）</li>\n</ul>\n<h2 id=\"415-字符串相加\"><a href=\"#415-字符串相加\" class=\"headerlink\" title=\"415. 字符串相加\"></a><a href=\"https://leetcode-cn.com/problems/add-strings/\">415. 字符串相加</a></h2><p>也是需要关注代码更优雅的一个写法</p>\n<ul>\n<li>因为想要用到字符串反转，所以得用StringBuilder不用String，StringBuilder可以直接append数字。</li>\n<li>更简洁明了的表示：三元运算符；超出数字的部分就是0。</li>\n<li>注意最后的进位</li>\n<li>做完这一题就可以去做<a href=\"https://leetcode-cn.com/problems/multiply-strings/\">43. 字符串相乘</a></li>\n</ul>\n<h1 id=\"中等\"><a href=\"#中等\" class=\"headerlink\" title=\"中等\"></a><strong>中等</strong></h1><h2 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2. 两数相加\"></a><a href=\"https://leetcode-cn.com/problems/add-two-numbers/\">2. 两数相加</a></h2><ul>\n<li>模拟两式相加的过程</li>\n<li>注意点见链表部分：<a href=\"https://cosmos227.top/2021/12/29/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E9%93%BE%E8%A1%A8/#%E4%B8%AD%E7%AD%89\">Leetcode刷题之链表 | StrayInCosmos</a></li>\n</ul>\n<h2 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5. 最长回文子串\"></a><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\">5. 最长回文子串</a></h2><p>经典题，但我不会（只能想到暴力循环）</p>\n<p><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/\">详细通俗的思路分析，多解法 - 最长回文子串 - 力扣（LeetCode）</a></p>\n<ul>\n<li>动态规划</li>\n</ul>\n<p>先定义<strong>状态S(i, j)<strong>表示从i到j的子字符串，是否为回文串表示为P(i,j)。</strong>如果一个字符串是回文串，它去掉两端还是一个回文串</strong>，这就有了<strong>状态转移方程</strong>，$P(i,j)=P(i+1,j-1) \\and (S_i == S_j)$。边界条件，长度为1的子字符串为回文串，长度为2的子字符串若字符相等也为回文串。</p>\n<ul>\n<li>最长公共子串（回文就是正着反着读都一样，把原始字符串倒置后找两者最长公共子字符串）</li>\n</ul>\n<p>用动态规划的思想做，同时在找到最长公共子串的时候也要确定下标是不是匹配（只需要看结尾下标是不是匹配）。</p>\n<ul>\n<li>中心扩展法</li>\n</ul>\n<p>列举所有可能的回文中心并向两边进行拓展。注意字符串长度为奇数和偶数两种情况，奇数时以一个字符作中心，偶数以两个字符作为中心。</p>\n<ul>\n<li>Manacher算法</li>\n</ul>\n<p>只有O(n)的算法复杂度。插入#符号来考虑偶回文串，利用对称性。</p>\n<p>只能处理回文串问题，一般面试不考，略过。</p>\n<h2 id=\"6-Z-字形变换\"><a href=\"#6-Z-字形变换\" class=\"headerlink\" title=\"6. Z 字形变换\"></a><a href=\"https://leetcode-cn.com/problems/zigzag-conversion/\">6. Z 字形变换</a></h2><ul>\n<li>利用好StringBuilder类</li>\n<li>设置标志位，确定是否需要变换行索引</li>\n<li>对String对象做遍历的时候，可以用：<code>for(char c: str.toArray()) ...</code></li>\n</ul>\n<h2 id=\"8-字符串转换整数-atoi\"><a href=\"#8-字符串转换整数-atoi\" class=\"headerlink\" title=\"8. 字符串转换整数 (atoi)\"></a><a href=\"https://leetcode-cn.com/problems/string-to-integer-atoi/\">8. 字符串转换整数 (atoi)</a></h2><ul>\n<li>Integer.MAX_VALUE和Integer.MIN_VALUE</li>\n<li>我用了long类型来保存，从而可以判断是否越界，return的时候再换回去就行。</li>\n<li>但是保持用int类型会更好，判断的方法是在<strong>把result乘十之前</strong>，判断一下<strong>result有没有大于Integer.MAX_VALUE/10</strong>，或者<strong>如果等于Integer.MAX_VALUE/10时，当前位置的数字有没有大于Integer.MAX_VALU%10</strong></li>\n</ul>\n<h2 id=\"38-外观数列\"><a href=\"#38-外观数列\" class=\"headerlink\" title=\"38. 外观数列\"></a><a href=\"https://leetcode-cn.com/problems/count-and-say/\">38. 外观数列</a></h2><p>这道题目理解题意都花了会时间（doge</p>\n<ul>\n<li>找重复序列的方法需要更优雅一点，一开始自己想的越想越复杂，简洁明了的才是好办法~</li>\n<li>设置双指针，一个在标记点，另一个移动直到和标记点不同的索引为止。</li>\n<li>另外整数合并到字符串上，用Integer.toString()或者直接加到字符串上，但是要注意的是直接数字加字符会出错（比如<code>1+&#39;a&#39;</code>)，这个时候加上一个空字符串即可（比如<code>1+&quot;&quot;+&#39;a&#39;</code>）</li>\n</ul>\n<h2 id=\"43-字符串相乘\"><a href=\"#43-字符串相乘\" class=\"headerlink\" title=\"43. 字符串相乘\"></a><a href=\"https://leetcode-cn.com/problems/multiply-strings/\">43. 字符串相乘</a></h2><ul>\n<li><a href=\"https://leetcode-cn.com/problems/add-strings/\">415. 字符串相加</a>的下一题</li>\n<li>我自己用的是模拟列竖式手算然后两个字符串相加的过程，和415这题一样要注意<strong>进位</strong>的问题！同时要注意补零，以及判断是否有字符串为”0”，这时只要输出一个”0”而不是”0000”</li>\n<li>看了几个题解都提到优化竖式，方法比较巧妙，讲解可以看：<a href=\"https://leetcode-cn.com/problems/multiply-strings/solution/you-hua-ban-shu-shi-da-bai-994-by-breezean/\">优化版竖式(打败99.4%)</a>；代码我更喜欢三叶写的：<a href=\"https://leetcode-cn.com/problems/multiply-strings/solution/zhi-yao-ni-hui-shou-suan-cheng-fa-zhe-ti-ainl/\">只要你会手算乘法，这题能能过 ~</a></li>\n</ul>\n<h2 id=\"59-螺旋矩阵-II\"><a href=\"#59-螺旋矩阵-II\" class=\"headerlink\" title=\"59. 螺旋矩阵 II\"></a><a href=\"https://leetcode-cn.com/problems/spiral-matrix-ii/\">59. 螺旋矩阵 II</a></h2><ul>\n<li>看到这个<a href=\"https://leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/\">题解</a>的时候，我只会”Wow~~”</li>\n</ul>\n<h2 id=\"71-简化路径\"><a href=\"#71-简化路径\" class=\"headerlink\" title=\"71. 简化路径\"></a><a href=\"https://leetcode-cn.com/problems/simplify-path/\">71. 简化路径</a></h2><ul>\n<li><p>用<strong>栈</strong>。注意考虑边界条件，栈为空的时候返回”/“；另外用好条件判断（if，else if）；可以用split来划分出目录名。</p>\n</li>\n<li><p>Java中的<strong>Deque</strong>，对Queue的拓展，实现了头尾都可以进出。Deque是一个接口，可以用LinkedList或ArrayDeque来实现（两者区别，ArrayDeque是不能用索引操作的，因此如果只用到头尾，ArrayDeque的效率更高）</p>\n</li>\n<li><p>pollLast和removeLast，都是删除最后元素，但是后者不允许数组为空，前者允许，为空时返回null。</p>\n</li>\n</ul>\n<h2 id=\"73-矩阵置零\"><a href=\"#73-矩阵置零\" class=\"headerlink\" title=\"73. 矩阵置零\"></a><a href=\"https://leetcode-cn.com/problems/set-matrix-zeroes/\">73. 矩阵置零</a></h2><ul>\n<li>某行或某列有零，该行或列全为零，利用这个特点来记录标志</li>\n<li>需要设置标志，表示该位置是否需要置零。除了额外m+n的空间，直接在当前数组上设置标记，会使额外空间更小。</li>\n<li>注意特殊情况的记录，即第一行、第一列上有为零的情况。</li>\n</ul>\n<h2 id=\"89-格雷编码\"><a href=\"#89-格雷编码\" class=\"headerlink\" title=\"89. 格雷编码\"></a><a href=\"https://leetcode-cn.com/problems/gray-code/\">89. 格雷编码</a></h2><ul>\n<li>直接看答案了，记住得了</li>\n<li>没有理解为什么求第几个数的格雷码就是$g(i) = b(i)\\oplus b(i/2) $。先搁着，真遇到了就用对称来求解。</li>\n</ul>\n<h2 id=\"165-比较版本号\"><a href=\"#165-比较版本号\" class=\"headerlink\" title=\"165. 比较版本号\"></a><a href=\"https://leetcode-cn.com/problems/compare-version-numbers/\">165. 比较版本号</a></h2><ul>\n<li>直接按序比较即可，本来想说用栈，其实是把简单问题复杂化了。对于前导零，和别的数字一样计算即可。</li>\n<li>可以用split对字符串分组，此时注意要用<code>split(&quot;\\\\.&quot;)</code>，因为split是利用正则来分割的，对于<code>.</code>之类的特殊符号前面要加<code>\\\\</code>转义符。</li>\n<li>也可以直接用while，到字符<code>.</code>为止即可。</li>\n</ul>\n<h2 id=\"166-分数到小数\"><a href=\"#166-分数到小数\" class=\"headerlink\" title=\"166. 分数到小数\"></a><a href=\"https://leetcode-cn.com/problems/fraction-to-recurring-decimal/\">166. 分数到小数</a></h2><ul>\n<li>模拟手算除法的过程，如果遇到已经出现过的余数，循环就开始了，所以要<strong>记录余数以及出现的位置</strong>。可以用哈希表来记录。</li>\n<li>注意模拟除法手算的过程，一直都是和余数有关的。</li>\n<li>另外，要避免计算溢出，因此要把int转换为long来计算。注意在加负号之后，需要把分子和分母取绝对值。</li>\n<li>参考题解：<a href=\"https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/gong-shui-san-xie-mo-ni-shu-shi-ji-suan-kq8c4/\">【宫水三叶】模拟竖式计算（除法）</a></li>\n</ul>\n<h2 id=\"137-只出现一次的数字-II\"><a href=\"#137-只出现一次的数字-II\" class=\"headerlink\" title=\"137. 只出现一次的数字 II\"></a><a href=\"https://leetcode-cn.com/problems/single-number-ii/\">137. 只出现一次的数字 II</a></h2><ul>\n<li><p>朴素方法用哈希表</p>\n</li>\n<li><p>常数空间复杂度的用位运算。因为除了一个数字出现一次以外，别的数字出现三次，利用这一点取余数操作。具体而言，首先统计每一位上的数（求和），如果统计得到的数可以被3整除，说明多出来的那个数字为0（其余为1或0的相加结果都会被3整除）；若统计得到的数不能被3整除，说明多出来的那个数字为1。由此可以保存这个数字每一位的值，再从二进制转为十进制返回即可。</p>\n</li>\n<li><p>从操作上来看，由于数字是int类型，所以用int[32] cnt的数组保存每一位上的值即可。在统计时，外循环是对nums中的每个数，内循环是对每一位（一共32位）统计到cnt中去。这里可以用右移操作与1比较，从而得到每一位上的值，当与1相等时，cnt对应位的值++。而在从二进制数组返回得到十进制值时，可以用左移操作来加。</p>\n</li>\n<li><p>另外还有有限状态自动机，这个看得一知半解，也先搁着了~（可参考<a href=\"https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/\">只出现一次的数字 II（有限状态自动机 + 位运算，清晰图解）</a>）</p>\n</li>\n</ul>\n<h2 id=\"260-只出现一次的数字-III\"><a href=\"#260-只出现一次的数字-III\" class=\"headerlink\" title=\"260. 只出现一次的数字 III\"></a><a href=\"https://leetcode-cn.com/problems/single-number-iii/\">260. 只出现一次的数字 III</a></h2><ul>\n<li><p>朴素方法用哈希表来保存出现过的数字，但题目要求空间复杂度是常数的，能想到用位运算，但是不会了</p>\n</li>\n<li><p>位运算看了一会才有点理解。首先所有数字异或，得到的结果一定不为零（因为有两个只出现一次的数字）。拿这个异或结果，取任意一个有效位（即值为1的位）（这个位表示这两个数字在这一位上是不一样的，一个在这一位上为1另一个为0），得到一个mask（比如第二位有效则mask是<code>0010</code>)（这里有一种简洁的方法，取最低有效位LSB）。再用这个mask去和所有数字异或，就可以把数字们分成两组了，即这个位为1的是一组，这个位为0的是另一组，因为其他数字都是出现两次的，所以每组异或出来的结果就是我们想要找的数字。</p>\n</li>\n<li><p>异或：<code>^</code>；与：<code>&amp;</code>；或：<code>|</code>（注意和逻辑判断区分开）</p>\n</li>\n<li><p>哈希表方法<code>getOrDefault(key, defaultValue)</code>：获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值</p>\n</li>\n</ul>\n<blockquote>\n<p> 参考题解：</p>\n<p><a href=\"https://leetcode-cn.com/problems/single-number-iii/solution/cai-yong-fen-zhi-de-si-xiang-jiang-wen-ti-jiang-we/\">采用分治的思想将问题降维</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/single-number-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-zgi4/\">【宫水三叶】一题双解 :「哈希表」&amp;「异或」</a></p>\n</blockquote>\n<h1 id=\"困难\"><a href=\"#困难\" class=\"headerlink\" title=\"困难\"></a>困难</h1><h2 id=\"233-数字-1-的个数\"><a href=\"#233-数字-1-的个数\" class=\"headerlink\" title=\"233. 数字 1 的个数\"></a><a href=\"https://leetcode-cn.com/problems/number-of-digit-one/\">233. 数字 1 的个数</a></h2><ul>\n<li><p>tmd看不懂</p>\n</li>\n<li><p>我可以理解<strong>数位DP</strong>，引用咱们<a href=\"https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/\">K神的话</a>就是说 1~ n 的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。</p>\n</li>\n<li><p>于是我们可以按位循环。令第i位上的数值$n^i=b$，位数为${10} ^ i =m$（i从零开始）。思想就是固定这一位，然后看它左边（高位）的数字和右边（低位）的数字，来得到此时的个数。我们再令高位数字为a，低位数字为b。比如原始数字为56219，再比如我们现在循环到千位上了，也就是b=2，m=100，a=56，c=19。现在呢我们要找的数字是1，由于这一位上的2是大于1的，<strong>那么我们现在可以另它为1，左半部分变化一下就会让1出现次数加一次，右半部分变化一下也会让1的出现次数加一次</strong>。而因为2大于1，左边数字取的只要不大于高位部分，右边数字可以随便取都能保证可以取到的。所以这个时候，1出现在千位上的次数只和a有关，是$(a+1)*m$。换个角度理解一下：可以把高位和低位拼起来，不超过5699就可以，即可以取到0~5699，即$(a+1)*m$</p>\n</li>\n<li><p>为了好理解，我还是拿千分位的数字做例子，所以把原始数字换成56119，现在b=1，其他还是不变的m=100，a=56，c=19。那么现在b和要找的数字1一样大了，我们看看会左右部分可以怎么变了：右边还是一样，只要不大于a就行，但是左边就不是，当a=56的时候，左边不能超过19了。这个时候我们还是把千位拿掉，看看高位拼低位能取到多少，最大应该是5619，最小还是可以到0，所以可以取到的数字0~5619。即$a*m+c+1$</p>\n</li>\n<li><p>然后就剩最后一种情况了，即把原始数字换成56019，现在b=0，其他还是不变的m=100，a=56，c=19。现在b小于1了，那如果还是想统计千位为1的出现次数，那就左边不能大于56了，最多取到55即a-1，这样才能让千位取到1，然后这个时候，咱们的低位又可以随便取啦！所以此时只和左边的数字有关，即$a<em>m$。我们再千位拿掉，把高位低位拼起来，最大是多少相信你也会了：5599，所以这个时候的范围是0~5599，即$a</em>m$</p>\n</li>\n<li><p>扩展一下：<a href=\"https://www.luogu.com.cn/problem/P1980\">P1980 [NOIP2013 普及组] 计数问题 - 洛谷</a></p>\n</li>\n</ul>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>模拟类型题目，持续更新</p>","more":"<p>参考网站：</p>\n<p><a href=\"https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E6%A8%A1%E6%8B%9F\">模拟 · SharingSource/LogicStack-LeetCode Wiki</a></p>\n<p>Tips：</p>\n<ul>\n<li>其实一直不太理解模拟是什么意思…个人理解是模拟人碰到这个会怎么做（模拟“怎样才能得到答案”这个过程）</li>\n<li>哈希映射</li>\n<li>这个类型的题很明显地反映我Java用得不熟练………</li>\n</ul>\n<h1 id=\"简单\"><a href=\"#简单\" class=\"headerlink\" title=\"简单\"></a><strong>简单</strong></h1><h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1. 两数之和\"></a><a href=\"https://leetcode-cn.com/problems/two-sum/\">1. 两数之和</a></h2><ul>\n<li>咱就是说，经典题目</li>\n<li>除了暴力求解，就是用哈希表，但是哈希表的空间复杂度会高一些</li>\n</ul>\n<h2 id=\"14-最长公共前缀\"><a href=\"#14-最长公共前缀\" class=\"headerlink\" title=\"14. 最长公共前缀\"></a><a href=\"https://leetcode-cn.com/problems/longest-common-prefix/\">14. 最长公共前缀</a></h2><ul>\n<li>String的一些方法：int indexOf(char ch)找元素下标，char charAt(int i)找下标对应的元素</li>\n<li>字符串可以相加。如果要加上一个字符可以写作：<code>str += String.valueOf(&#39;a&#39;)</code></li>\n<li>我先求了最短字符串的长度，再循环的，可以在循环中判断不要超出长度。</li>\n<li>还有一种思路是从最后开始看，即判断字符串1是否在字符串2中，不存在就减小字符串1（另外设置一个变量）</li>\n</ul>\n<h2 id=\"58-最后一个单词的长度\"><a href=\"#58-最后一个单词的长度\" class=\"headerlink\" title=\"58. 最后一个单词的长度\"></a><a href=\"https://leetcode-cn.com/problems/length-of-last-word/\">58. 最后一个单词的长度</a></h2><ul>\n<li>比较简单。</li>\n<li>用while比起用for，代码会更好看（三叶的回答真的，又能给出题解又能给出漂亮的代码）。</li>\n</ul>\n<h2 id=\"66-加一\"><a href=\"#66-加一\" class=\"headerlink\" title=\"66. 加一\"></a><a href=\"https://leetcode-cn.com/problems/plus-one/\">66. 加一</a></h2><ul>\n<li><p>模拟加法过程</p>\n</li>\n<li><p>注意最后可能要加一位。至于最后加一位，直接这样写就可以了（Wow~）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">digits = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len + <span class=\"number\">1</span>];</span><br><span class=\"line\">digits[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>为什么这样可以呢，不是复制了，而是取巧！因为最后要加一位的情况只有999到1000这一类，这个时候除了第一位都是0，而Java的int数组在初始化的时候就默认初始化为0！我靠！</p>\n</li>\n</ul>\n<h2 id=\"136-只出现一次的数字\"><a href=\"#136-只出现一次的数字\" class=\"headerlink\" title=\"136. 只出现一次的数字\"></a><a href=\"https://leetcode-cn.com/problems/single-number/\">136. 只出现一次的数字</a></h2><ul>\n<li>和第268题很像，不过268是固定范围内的数字，所以可以先相加再减出结果</li>\n<li>用位运算，异或即可</li>\n</ul>\n<h2 id=\"168-Excel表列名称\"><a href=\"#168-Excel表列名称\" class=\"headerlink\" title=\"168. Excel表列名称\"></a><a href=\"https://leetcode-cn.com/problems/excel-sheet-column-title/\">168. Excel表列名称</a></h2><ul>\n<li>思路参考了二进制、十六进制的转换方法，但是这里从1而不是从0开始，验算的时候发现需要先减1。</li>\n<li>另外要注意<code>for</code>循环中<code>n1</code>和<code>n2</code>的前后关系！</li>\n</ul>\n<h2 id=\"171-Excel表列序号\"><a href=\"#171-Excel表列序号\" class=\"headerlink\" title=\"171. Excel表列序号\"></a><a href=\"https://leetcode-cn.com/problems/excel-sheet-column-number/\">171. Excel表列序号</a></h2><ul>\n<li>和十进制一样</li>\n</ul>\n<h2 id=\"263-丑数\"><a href=\"#263-丑数\" class=\"headerlink\" title=\"263. 丑数\"></a><a href=\"https://leetcode-cn.com/problems/ugly-number/\">263. 丑数</a></h2><ul>\n<li>2、3、5每个都除一下，每个都要除到不能再除为止（即余数不为零）</li>\n<li>我设了一个变量保存余数，发现直接写在while条件里面会更好看，代码还是得看三叶姐姐：<a href=\"https://leetcode-cn.com/problems/ugly-number/solution/gong-shui-san-xie-jian-dan-de-fen-qing-k-dlvg/\">【宫水三叶】简单的分情况讨论题</a></li>\n</ul>\n<h2 id=\"268-丢失的数字\"><a href=\"#268-丢失的数字\" class=\"headerlink\" title=\"268. 丢失的数字\"></a><a href=\"https://leetcode-cn.com/problems/missing-number/\">268. 丢失的数字</a></h2><ul>\n<li><p>我是<strong>相加然后求差</strong>~</p>\n</li>\n<li><p>先排序后求。排序方法：Arrays.sort(nums)</p>\n</li>\n<li><p>找缺失数、找出现一次数都是<strong>异或</strong>的经典应用。 ——三叶姐姐</p>\n<p>异或性质：$0 \\oplus x=x$，$x\\oplus x=0$</p>\n<p>所以如果要找缺失数，就把完整序列和0异或一次，再和当前序列异或一次，得到的就是缺失数啦！</p>\n</li>\n</ul>\n<h2 id=\"383-赎金信\"><a href=\"#383-赎金信\" class=\"headerlink\" title=\"383. 赎金信\"></a><a href=\"https://leetcode-cn.com/problems/ransom-note/\">383. 赎金信</a></h2><ul>\n<li>因为字符串由26个小写字母组成，所以只要先统计magazine里的字母，再减去ransomNote里的字母出现次数就可以了</li>\n<li>注意magazine的字符只能用一次，<strong>当然也可以不用</strong>（谁想当然了？我想当然了）</li>\n</ul>\n<h2 id=\"415-字符串相加\"><a href=\"#415-字符串相加\" class=\"headerlink\" title=\"415. 字符串相加\"></a><a href=\"https://leetcode-cn.com/problems/add-strings/\">415. 字符串相加</a></h2><p>也是需要关注代码更优雅的一个写法</p>\n<ul>\n<li>因为想要用到字符串反转，所以得用StringBuilder不用String，StringBuilder可以直接append数字。</li>\n<li>更简洁明了的表示：三元运算符；超出数字的部分就是0。</li>\n<li>注意最后的进位</li>\n<li>做完这一题就可以去做<a href=\"https://leetcode-cn.com/problems/multiply-strings/\">43. 字符串相乘</a></li>\n</ul>\n<h1 id=\"中等\"><a href=\"#中等\" class=\"headerlink\" title=\"中等\"></a><strong>中等</strong></h1><h2 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2. 两数相加\"></a><a href=\"https://leetcode-cn.com/problems/add-two-numbers/\">2. 两数相加</a></h2><ul>\n<li>模拟两式相加的过程</li>\n<li>注意点见链表部分：<a href=\"https://cosmos227.top/2021/12/29/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E9%93%BE%E8%A1%A8/#%E4%B8%AD%E7%AD%89\">Leetcode刷题之链表 | StrayInCosmos</a></li>\n</ul>\n<h2 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5. 最长回文子串\"></a><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\">5. 最长回文子串</a></h2><p>经典题，但我不会（只能想到暴力循环）</p>\n<p><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/\">详细通俗的思路分析，多解法 - 最长回文子串 - 力扣（LeetCode）</a></p>\n<ul>\n<li>动态规划</li>\n</ul>\n<p>先定义<strong>状态S(i, j)<strong>表示从i到j的子字符串，是否为回文串表示为P(i,j)。</strong>如果一个字符串是回文串，它去掉两端还是一个回文串</strong>，这就有了<strong>状态转移方程</strong>，$P(i,j)=P(i+1,j-1) \\and (S_i == S_j)$。边界条件，长度为1的子字符串为回文串，长度为2的子字符串若字符相等也为回文串。</p>\n<ul>\n<li>最长公共子串（回文就是正着反着读都一样，把原始字符串倒置后找两者最长公共子字符串）</li>\n</ul>\n<p>用动态规划的思想做，同时在找到最长公共子串的时候也要确定下标是不是匹配（只需要看结尾下标是不是匹配）。</p>\n<ul>\n<li>中心扩展法</li>\n</ul>\n<p>列举所有可能的回文中心并向两边进行拓展。注意字符串长度为奇数和偶数两种情况，奇数时以一个字符作中心，偶数以两个字符作为中心。</p>\n<ul>\n<li>Manacher算法</li>\n</ul>\n<p>只有O(n)的算法复杂度。插入#符号来考虑偶回文串，利用对称性。</p>\n<p>只能处理回文串问题，一般面试不考，略过。</p>\n<h2 id=\"6-Z-字形变换\"><a href=\"#6-Z-字形变换\" class=\"headerlink\" title=\"6. Z 字形变换\"></a><a href=\"https://leetcode-cn.com/problems/zigzag-conversion/\">6. Z 字形变换</a></h2><ul>\n<li>利用好StringBuilder类</li>\n<li>设置标志位，确定是否需要变换行索引</li>\n<li>对String对象做遍历的时候，可以用：<code>for(char c: str.toArray()) ...</code></li>\n</ul>\n<h2 id=\"8-字符串转换整数-atoi\"><a href=\"#8-字符串转换整数-atoi\" class=\"headerlink\" title=\"8. 字符串转换整数 (atoi)\"></a><a href=\"https://leetcode-cn.com/problems/string-to-integer-atoi/\">8. 字符串转换整数 (atoi)</a></h2><ul>\n<li>Integer.MAX_VALUE和Integer.MIN_VALUE</li>\n<li>我用了long类型来保存，从而可以判断是否越界，return的时候再换回去就行。</li>\n<li>但是保持用int类型会更好，判断的方法是在<strong>把result乘十之前</strong>，判断一下<strong>result有没有大于Integer.MAX_VALUE/10</strong>，或者<strong>如果等于Integer.MAX_VALUE/10时，当前位置的数字有没有大于Integer.MAX_VALU%10</strong></li>\n</ul>\n<h2 id=\"38-外观数列\"><a href=\"#38-外观数列\" class=\"headerlink\" title=\"38. 外观数列\"></a><a href=\"https://leetcode-cn.com/problems/count-and-say/\">38. 外观数列</a></h2><p>这道题目理解题意都花了会时间（doge</p>\n<ul>\n<li>找重复序列的方法需要更优雅一点，一开始自己想的越想越复杂，简洁明了的才是好办法~</li>\n<li>设置双指针，一个在标记点，另一个移动直到和标记点不同的索引为止。</li>\n<li>另外整数合并到字符串上，用Integer.toString()或者直接加到字符串上，但是要注意的是直接数字加字符会出错（比如<code>1+&#39;a&#39;</code>)，这个时候加上一个空字符串即可（比如<code>1+&quot;&quot;+&#39;a&#39;</code>）</li>\n</ul>\n<h2 id=\"43-字符串相乘\"><a href=\"#43-字符串相乘\" class=\"headerlink\" title=\"43. 字符串相乘\"></a><a href=\"https://leetcode-cn.com/problems/multiply-strings/\">43. 字符串相乘</a></h2><ul>\n<li><a href=\"https://leetcode-cn.com/problems/add-strings/\">415. 字符串相加</a>的下一题</li>\n<li>我自己用的是模拟列竖式手算然后两个字符串相加的过程，和415这题一样要注意<strong>进位</strong>的问题！同时要注意补零，以及判断是否有字符串为”0”，这时只要输出一个”0”而不是”0000”</li>\n<li>看了几个题解都提到优化竖式，方法比较巧妙，讲解可以看：<a href=\"https://leetcode-cn.com/problems/multiply-strings/solution/you-hua-ban-shu-shi-da-bai-994-by-breezean/\">优化版竖式(打败99.4%)</a>；代码我更喜欢三叶写的：<a href=\"https://leetcode-cn.com/problems/multiply-strings/solution/zhi-yao-ni-hui-shou-suan-cheng-fa-zhe-ti-ainl/\">只要你会手算乘法，这题能能过 ~</a></li>\n</ul>\n<h2 id=\"59-螺旋矩阵-II\"><a href=\"#59-螺旋矩阵-II\" class=\"headerlink\" title=\"59. 螺旋矩阵 II\"></a><a href=\"https://leetcode-cn.com/problems/spiral-matrix-ii/\">59. 螺旋矩阵 II</a></h2><ul>\n<li>看到这个<a href=\"https://leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/\">题解</a>的时候，我只会”Wow~~”</li>\n</ul>\n<h2 id=\"71-简化路径\"><a href=\"#71-简化路径\" class=\"headerlink\" title=\"71. 简化路径\"></a><a href=\"https://leetcode-cn.com/problems/simplify-path/\">71. 简化路径</a></h2><ul>\n<li><p>用<strong>栈</strong>。注意考虑边界条件，栈为空的时候返回”/“；另外用好条件判断（if，else if）；可以用split来划分出目录名。</p>\n</li>\n<li><p>Java中的<strong>Deque</strong>，对Queue的拓展，实现了头尾都可以进出。Deque是一个接口，可以用LinkedList或ArrayDeque来实现（两者区别，ArrayDeque是不能用索引操作的，因此如果只用到头尾，ArrayDeque的效率更高）</p>\n</li>\n<li><p>pollLast和removeLast，都是删除最后元素，但是后者不允许数组为空，前者允许，为空时返回null。</p>\n</li>\n</ul>\n<h2 id=\"73-矩阵置零\"><a href=\"#73-矩阵置零\" class=\"headerlink\" title=\"73. 矩阵置零\"></a><a href=\"https://leetcode-cn.com/problems/set-matrix-zeroes/\">73. 矩阵置零</a></h2><ul>\n<li>某行或某列有零，该行或列全为零，利用这个特点来记录标志</li>\n<li>需要设置标志，表示该位置是否需要置零。除了额外m+n的空间，直接在当前数组上设置标记，会使额外空间更小。</li>\n<li>注意特殊情况的记录，即第一行、第一列上有为零的情况。</li>\n</ul>\n<h2 id=\"89-格雷编码\"><a href=\"#89-格雷编码\" class=\"headerlink\" title=\"89. 格雷编码\"></a><a href=\"https://leetcode-cn.com/problems/gray-code/\">89. 格雷编码</a></h2><ul>\n<li>直接看答案了，记住得了</li>\n<li>没有理解为什么求第几个数的格雷码就是$g(i) = b(i)\\oplus b(i/2) $。先搁着，真遇到了就用对称来求解。</li>\n</ul>\n<h2 id=\"165-比较版本号\"><a href=\"#165-比较版本号\" class=\"headerlink\" title=\"165. 比较版本号\"></a><a href=\"https://leetcode-cn.com/problems/compare-version-numbers/\">165. 比较版本号</a></h2><ul>\n<li>直接按序比较即可，本来想说用栈，其实是把简单问题复杂化了。对于前导零，和别的数字一样计算即可。</li>\n<li>可以用split对字符串分组，此时注意要用<code>split(&quot;\\\\.&quot;)</code>，因为split是利用正则来分割的，对于<code>.</code>之类的特殊符号前面要加<code>\\\\</code>转义符。</li>\n<li>也可以直接用while，到字符<code>.</code>为止即可。</li>\n</ul>\n<h2 id=\"166-分数到小数\"><a href=\"#166-分数到小数\" class=\"headerlink\" title=\"166. 分数到小数\"></a><a href=\"https://leetcode-cn.com/problems/fraction-to-recurring-decimal/\">166. 分数到小数</a></h2><ul>\n<li>模拟手算除法的过程，如果遇到已经出现过的余数，循环就开始了，所以要<strong>记录余数以及出现的位置</strong>。可以用哈希表来记录。</li>\n<li>注意模拟除法手算的过程，一直都是和余数有关的。</li>\n<li>另外，要避免计算溢出，因此要把int转换为long来计算。注意在加负号之后，需要把分子和分母取绝对值。</li>\n<li>参考题解：<a href=\"https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/gong-shui-san-xie-mo-ni-shu-shi-ji-suan-kq8c4/\">【宫水三叶】模拟竖式计算（除法）</a></li>\n</ul>\n<h2 id=\"137-只出现一次的数字-II\"><a href=\"#137-只出现一次的数字-II\" class=\"headerlink\" title=\"137. 只出现一次的数字 II\"></a><a href=\"https://leetcode-cn.com/problems/single-number-ii/\">137. 只出现一次的数字 II</a></h2><ul>\n<li><p>朴素方法用哈希表</p>\n</li>\n<li><p>常数空间复杂度的用位运算。因为除了一个数字出现一次以外，别的数字出现三次，利用这一点取余数操作。具体而言，首先统计每一位上的数（求和），如果统计得到的数可以被3整除，说明多出来的那个数字为0（其余为1或0的相加结果都会被3整除）；若统计得到的数不能被3整除，说明多出来的那个数字为1。由此可以保存这个数字每一位的值，再从二进制转为十进制返回即可。</p>\n</li>\n<li><p>从操作上来看，由于数字是int类型，所以用int[32] cnt的数组保存每一位上的值即可。在统计时，外循环是对nums中的每个数，内循环是对每一位（一共32位）统计到cnt中去。这里可以用右移操作与1比较，从而得到每一位上的值，当与1相等时，cnt对应位的值++。而在从二进制数组返回得到十进制值时，可以用左移操作来加。</p>\n</li>\n<li><p>另外还有有限状态自动机，这个看得一知半解，也先搁着了~（可参考<a href=\"https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/\">只出现一次的数字 II（有限状态自动机 + 位运算，清晰图解）</a>）</p>\n</li>\n</ul>\n<h2 id=\"260-只出现一次的数字-III\"><a href=\"#260-只出现一次的数字-III\" class=\"headerlink\" title=\"260. 只出现一次的数字 III\"></a><a href=\"https://leetcode-cn.com/problems/single-number-iii/\">260. 只出现一次的数字 III</a></h2><ul>\n<li><p>朴素方法用哈希表来保存出现过的数字，但题目要求空间复杂度是常数的，能想到用位运算，但是不会了</p>\n</li>\n<li><p>位运算看了一会才有点理解。首先所有数字异或，得到的结果一定不为零（因为有两个只出现一次的数字）。拿这个异或结果，取任意一个有效位（即值为1的位）（这个位表示这两个数字在这一位上是不一样的，一个在这一位上为1另一个为0），得到一个mask（比如第二位有效则mask是<code>0010</code>)（这里有一种简洁的方法，取最低有效位LSB）。再用这个mask去和所有数字异或，就可以把数字们分成两组了，即这个位为1的是一组，这个位为0的是另一组，因为其他数字都是出现两次的，所以每组异或出来的结果就是我们想要找的数字。</p>\n</li>\n<li><p>异或：<code>^</code>；与：<code>&amp;</code>；或：<code>|</code>（注意和逻辑判断区分开）</p>\n</li>\n<li><p>哈希表方法<code>getOrDefault(key, defaultValue)</code>：获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值</p>\n</li>\n</ul>\n<blockquote>\n<p> 参考题解：</p>\n<p><a href=\"https://leetcode-cn.com/problems/single-number-iii/solution/cai-yong-fen-zhi-de-si-xiang-jiang-wen-ti-jiang-we/\">采用分治的思想将问题降维</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/single-number-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-zgi4/\">【宫水三叶】一题双解 :「哈希表」&amp;「异或」</a></p>\n</blockquote>\n<h1 id=\"困难\"><a href=\"#困难\" class=\"headerlink\" title=\"困难\"></a>困难</h1><h2 id=\"233-数字-1-的个数\"><a href=\"#233-数字-1-的个数\" class=\"headerlink\" title=\"233. 数字 1 的个数\"></a><a href=\"https://leetcode-cn.com/problems/number-of-digit-one/\">233. 数字 1 的个数</a></h2><ul>\n<li><p>tmd看不懂</p>\n</li>\n<li><p>我可以理解<strong>数位DP</strong>，引用咱们<a href=\"https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/\">K神的话</a>就是说 1~ n 的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。</p>\n</li>\n<li><p>于是我们可以按位循环。令第i位上的数值$n^i=b$，位数为${10} ^ i =m$（i从零开始）。思想就是固定这一位，然后看它左边（高位）的数字和右边（低位）的数字，来得到此时的个数。我们再令高位数字为a，低位数字为b。比如原始数字为56219，再比如我们现在循环到千位上了，也就是b=2，m=100，a=56，c=19。现在呢我们要找的数字是1，由于这一位上的2是大于1的，<strong>那么我们现在可以另它为1，左半部分变化一下就会让1出现次数加一次，右半部分变化一下也会让1的出现次数加一次</strong>。而因为2大于1，左边数字取的只要不大于高位部分，右边数字可以随便取都能保证可以取到的。所以这个时候，1出现在千位上的次数只和a有关，是$(a+1)*m$。换个角度理解一下：可以把高位和低位拼起来，不超过5699就可以，即可以取到0~5699，即$(a+1)*m$</p>\n</li>\n<li><p>为了好理解，我还是拿千分位的数字做例子，所以把原始数字换成56119，现在b=1，其他还是不变的m=100，a=56，c=19。那么现在b和要找的数字1一样大了，我们看看会左右部分可以怎么变了：右边还是一样，只要不大于a就行，但是左边就不是，当a=56的时候，左边不能超过19了。这个时候我们还是把千位拿掉，看看高位拼低位能取到多少，最大应该是5619，最小还是可以到0，所以可以取到的数字0~5619。即$a*m+c+1$</p>\n</li>\n<li><p>然后就剩最后一种情况了，即把原始数字换成56019，现在b=0，其他还是不变的m=100，a=56，c=19。现在b小于1了，那如果还是想统计千位为1的出现次数，那就左边不能大于56了，最多取到55即a-1，这样才能让千位取到1，然后这个时候，咱们的低位又可以随便取啦！所以此时只和左边的数字有关，即$a<em>m$。我们再千位拿掉，把高位低位拼起来，最大是多少相信你也会了：5599，所以这个时候的范围是0~5599，即$a</em>m$</p>\n</li>\n<li><p>扩展一下：<a href=\"https://www.luogu.com.cn/problem/P1980\">P1980 [NOIP2013 普及组] 计数问题 - 洛谷</a></p>\n</li>\n</ul>"},{"title":"Leetcode刷题之滑动窗口","date":"2022-02-12T16:02:06.000Z","updated":"2022-02-12T16:02:06.000Z","_content":"\n双指针类型题目，持续更新\n\n<!--more-->\n\n>  邓宁-克鲁格效应是指的是能力欠缺的人在自己欠考虑的决定的基础上得出错误结论，但是无法正确认识到自身的不足，辨别错误行为，是一种认知偏差现象。这些能力欠缺者们沉浸在自我营造的虚幻的优势之中，常常高估自己的能力水平，却无法客观评价他人的能力。\n\n[什么是「滑动窗口算法」（sliding window algorithm），有哪些应用场景？ - 知乎](https://www.zhihu.com/question/314669016)\n\n最高赞的回答不错。滑动窗口在处理数组和字符串上很适用。\n\n窗口大小分为固定的和可变的两种。\n\n固定的滑动窗口：后面加进来一个，前面推出去一个。\n\n可变的滑动窗口：窗口加到到满足条件或不满足条件为止，前面的元素推出去。\n\n[【详细图解】滑动窗口（超99） - 最短超串 - 力扣（LeetCode）](https://leetcode-cn.com/problems/shortest-supersequence-lcci/solution/xiang-xi-tu-jie-hua-dong-chuang-kou-chao-qi7g/)\n\n可用于查找满足某些条件的**连续区间**的性质（如长度）。由于区间连续，当区间变化时，可以通过之前的计算结果来对搜索空间进行剪枝。\n\n# 简单\n\n## [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)\n\n维护一个可变的滑动窗（用Set）\n\n## [643. 子数组最大平均数 I](https://leetcode-cn.com/problems/maximum-average-subarray-i/)\n\n两种方法。1. presum，前缀和。2. 滑动窗\n\npresum：创建一个数组，长度为N。第i个元素存放前i个元素之和（注意自己的代码写的是否包括了第i个元素）。\n\n滑动窗：先取得前k个元素和，形成一个长度为k的窗口。然后开始移动，每向后移动一个元素，加上当前元素，减去第一个元素。\n\n# 中等\n\n## [187. 重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/)\n\n一般的滑动窗感觉占用空间太大了，即用哈希表，子串映射到出现次数。但是对于最大长度为$10^5$的字符串，我觉得太大。（但是还是可以用的，面试的时候想不出更好的就用这个！做出来比做好可能更重要！）\n\n这里第一次学习到了**字符串哈希**。\n\n[字符串哈希 - OI Wiki](https://oi-wiki.org/string/hash/)\n\n记录一下为什么用131313：字符串哈希本身存在哈希冲突的可能，一般会在尝试 131之后尝试使用 13131，然后再尝试使用比 13131 更大的质数。（参考[三叶的答案](https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/)）\n\n\n\n## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/) ☆\n\n~~没有理清楚，记录一下自己的代码。~~\n\n滑动窗口的经典题目。\n\n还有其他方法，比如前缀和。\n\n\n\n## [220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)\n\n暴力解法即遍历元素，对第i个元素向后检查k个元素，但是这样做会超时。\n\n三叶姐的题解展示了两种方法：\n\n**滑动窗&红黑树**\n\n对暴力解法进行优化，可以对检查k个元素的过程进行优化。k个元素用一个**有序集合**来维护，而这个集合需要实现高效的**查询**和**插入删除**操作。由此可以想到使用**树**。\n\n再利用TreeMap中的ceiling和flooring函数，得到最接近当前元素的值。\n\n> AVL：一种**平衡二叉搜索树**。具有两个性质：左边大于右边；任意节点的孩子节点之间高度差最大为1。因为第二个性质，在插入或删除元素时可能需要进行重平衡，可以通过旋转的方法实现。一次平衡操作伴随着多次旋转。\n>\n> RBT：**红黑树**。是一种二叉树，但每一个节点多了一个属性：颜色。是一种弱平衡二叉搜索树，它不像AVL要求左右高度差不大于1，但对路径长度要求“任何一条路径的长度不能大于其他路径长度的两倍”。这样使得RBT比AVL在插删操作上，运行速度更快，因为旋转次数变少。\n>\n> BST：**二叉搜索树**（binary search tree）\n\n**桶**\n\n> **桶排序**\n>\n> 令需要排序的序列一共有n个元素，将这n个元素分到m个桶中，这些桶满足：当前桶中的元素都小于后面桶的元素。然后对每个桶分别进行排序，最后合并每个桶的结果。当m接近于n时，时间复杂度趋近于`O(n)`。桶排序是一种空间换时间的方法，它要求序列分布尽可能均匀，否则会出现空间上的浪费。\n>\n> 顺便再介绍一下计数排序和基数排序，他们和桶排序都是线性时间复杂度的排序算法。他们是非基于比较的排序方法，基于比较的排序方法难以突破`O(nlogn)`的时间复杂度。\n>\n> **计数排序**\n>\n> 一种特殊的桶排序。令序列的最小值为min，最大值为max，创建一个大小为max-min+1的数组。这个数组用来记录每一个数出现的次数。他是一种稳定的排序算法。\n>\n> **基数排序**\n>\n> 基于**多个关键字**的排序。网络上对基数排序的例子以**数位**为主。\n>\n> 从首要关键字开始的排序成为**MSD（Most Significant Dight）**，先根据首要关键字分成一些堆（如百位数），再对每个堆分别进行排序，然后串联这些堆。\n>\n> 从最低有效关键字开始排序，称为**LSD(Least Significant Dight)**。先按照次要关键字来排序，然后按按照首要关键字排序，不需要对每一个堆进行排序，比MSD的开销小。\n>\n> 注意：排序需要稳定的算法，可以用计数排序实现。稳定的排序才可以保留上一次排序的结果。\n>\n> **Tips：**\n>\n> - 以上三种方法虽然灵活性不如快排等方法，但在某些情况下，可以充分利用序列的一些性质，从而取得较好的算法性能。\n>\n> 可参考：[三种线性排序算法 计数排序、桶排序与基数排序](https://byvoid.com/zhs/blog/sort-radix/)\n>\n>  [基数排序、桶排序和计数排序的区别](https://blog.csdn.net/qq_19446965/article/details/81517552)\n\n\n\n## [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/) ☆\n\n滑动窗口的经典题\n\n找到一个序列，使得这个序列的长度小于等于出现次数最多的字符数+k。于是问题来到了怎么确定序列中出现最多的字符数：每次右指针向右移动时，当前字符的出现次数+1，比较当前字符数与最多字符数即可。\n\n注意在当前字符数减小时，不需要改变出现最多的字符数，它确定了滑动窗的大小，更新的滑动窗大小不应该变小。只需要在变大的时候更新。\n\n\n\n## [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)\n\n一个滑动窗，窗口内的元素要满足：1. 窗口内的元素出现在p中；2. 窗口内出现元素的次数要小于等于s中出现的次数。从而，当窗口大小与p长度相等时，将索引加入结果中。将这两个条件可以进行合并：窗口内元素的出现次数小于等于s中出现的次数（p中没有的字符出现次数就是0）。\n\n这样的条件合并就需要统计所有26个字母出现的次数。我一开始的做法用map只统计p中出现了的元素，这样在还原的时候，稍微复杂了一些，不然可以合并。\n\n滑动窗的设计思路和基本框架一致：1. 设置左右指针；2. 更新右指针引起的状态变化；3. 检查是否还满足条件，不满足条件的话左指针右移；4. 右指针右移\n\n参考：[找到字符串中所有字母异位词，滑动窗口 + 数组/双指针](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/438-zhao-dao-zi-fu-chuan-zhong-suo-you-z-nx6b/)\n\n题解下最赞评论：滑动窗方法能从暴力解法出发进行优化。\n\n（PS. 我发现其实很多方法都可以通过暴力解法来出发思考）\n\n## [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)\n\n和438类似。\n\n需要注意的是子串是连续的！\n\n（所以用字符串排列然后找是不是包含子串的方法行不通/doge）\n\n## [904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)\n\n翻译一下题目：找到一个连续序列，这个序列中出现的数字最多为两种，求这个连续序列的最大长度。\n\n这样一来就是滑动窗的基础用法了~\n\n# 困难\n\n## [480. 滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)\n\n见数据结构篇\n\n## [992. K 个不同整数的子数组](https://leetcode-cn.com/problems/subarrays-with-k-different-integers/)\n\n如果理解了做法，就比较好做了。\n\n重点：**K个不同整数的子数组=最多K个整数的子数组-最多K-1个整数的子数组**\n\n然后只要写出**求最多K个整数的子数组**的函数即可。\n\n滑动窗的基本操作。要注意的是求子数组的时候，每次固定右端点计算能得到的子数组，是right-left+1个。\n","source":"_posts/Leetcode刷题之滑动窗口.md","raw":"---\ntitle: Leetcode刷题之滑动窗口\ndate: 2022-02-13 00:02:06\nupdated: \ncategories: 刷题\ntags: 滑动窗口\n\n---\n\n双指针类型题目，持续更新\n\n<!--more-->\n\n>  邓宁-克鲁格效应是指的是能力欠缺的人在自己欠考虑的决定的基础上得出错误结论，但是无法正确认识到自身的不足，辨别错误行为，是一种认知偏差现象。这些能力欠缺者们沉浸在自我营造的虚幻的优势之中，常常高估自己的能力水平，却无法客观评价他人的能力。\n\n[什么是「滑动窗口算法」（sliding window algorithm），有哪些应用场景？ - 知乎](https://www.zhihu.com/question/314669016)\n\n最高赞的回答不错。滑动窗口在处理数组和字符串上很适用。\n\n窗口大小分为固定的和可变的两种。\n\n固定的滑动窗口：后面加进来一个，前面推出去一个。\n\n可变的滑动窗口：窗口加到到满足条件或不满足条件为止，前面的元素推出去。\n\n[【详细图解】滑动窗口（超99） - 最短超串 - 力扣（LeetCode）](https://leetcode-cn.com/problems/shortest-supersequence-lcci/solution/xiang-xi-tu-jie-hua-dong-chuang-kou-chao-qi7g/)\n\n可用于查找满足某些条件的**连续区间**的性质（如长度）。由于区间连续，当区间变化时，可以通过之前的计算结果来对搜索空间进行剪枝。\n\n# 简单\n\n## [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)\n\n维护一个可变的滑动窗（用Set）\n\n## [643. 子数组最大平均数 I](https://leetcode-cn.com/problems/maximum-average-subarray-i/)\n\n两种方法。1. presum，前缀和。2. 滑动窗\n\npresum：创建一个数组，长度为N。第i个元素存放前i个元素之和（注意自己的代码写的是否包括了第i个元素）。\n\n滑动窗：先取得前k个元素和，形成一个长度为k的窗口。然后开始移动，每向后移动一个元素，加上当前元素，减去第一个元素。\n\n# 中等\n\n## [187. 重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/)\n\n一般的滑动窗感觉占用空间太大了，即用哈希表，子串映射到出现次数。但是对于最大长度为$10^5$的字符串，我觉得太大。（但是还是可以用的，面试的时候想不出更好的就用这个！做出来比做好可能更重要！）\n\n这里第一次学习到了**字符串哈希**。\n\n[字符串哈希 - OI Wiki](https://oi-wiki.org/string/hash/)\n\n记录一下为什么用131313：字符串哈希本身存在哈希冲突的可能，一般会在尝试 131之后尝试使用 13131，然后再尝试使用比 13131 更大的质数。（参考[三叶的答案](https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/)）\n\n\n\n## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/) ☆\n\n~~没有理清楚，记录一下自己的代码。~~\n\n滑动窗口的经典题目。\n\n还有其他方法，比如前缀和。\n\n\n\n## [220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)\n\n暴力解法即遍历元素，对第i个元素向后检查k个元素，但是这样做会超时。\n\n三叶姐的题解展示了两种方法：\n\n**滑动窗&红黑树**\n\n对暴力解法进行优化，可以对检查k个元素的过程进行优化。k个元素用一个**有序集合**来维护，而这个集合需要实现高效的**查询**和**插入删除**操作。由此可以想到使用**树**。\n\n再利用TreeMap中的ceiling和flooring函数，得到最接近当前元素的值。\n\n> AVL：一种**平衡二叉搜索树**。具有两个性质：左边大于右边；任意节点的孩子节点之间高度差最大为1。因为第二个性质，在插入或删除元素时可能需要进行重平衡，可以通过旋转的方法实现。一次平衡操作伴随着多次旋转。\n>\n> RBT：**红黑树**。是一种二叉树，但每一个节点多了一个属性：颜色。是一种弱平衡二叉搜索树，它不像AVL要求左右高度差不大于1，但对路径长度要求“任何一条路径的长度不能大于其他路径长度的两倍”。这样使得RBT比AVL在插删操作上，运行速度更快，因为旋转次数变少。\n>\n> BST：**二叉搜索树**（binary search tree）\n\n**桶**\n\n> **桶排序**\n>\n> 令需要排序的序列一共有n个元素，将这n个元素分到m个桶中，这些桶满足：当前桶中的元素都小于后面桶的元素。然后对每个桶分别进行排序，最后合并每个桶的结果。当m接近于n时，时间复杂度趋近于`O(n)`。桶排序是一种空间换时间的方法，它要求序列分布尽可能均匀，否则会出现空间上的浪费。\n>\n> 顺便再介绍一下计数排序和基数排序，他们和桶排序都是线性时间复杂度的排序算法。他们是非基于比较的排序方法，基于比较的排序方法难以突破`O(nlogn)`的时间复杂度。\n>\n> **计数排序**\n>\n> 一种特殊的桶排序。令序列的最小值为min，最大值为max，创建一个大小为max-min+1的数组。这个数组用来记录每一个数出现的次数。他是一种稳定的排序算法。\n>\n> **基数排序**\n>\n> 基于**多个关键字**的排序。网络上对基数排序的例子以**数位**为主。\n>\n> 从首要关键字开始的排序成为**MSD（Most Significant Dight）**，先根据首要关键字分成一些堆（如百位数），再对每个堆分别进行排序，然后串联这些堆。\n>\n> 从最低有效关键字开始排序，称为**LSD(Least Significant Dight)**。先按照次要关键字来排序，然后按按照首要关键字排序，不需要对每一个堆进行排序，比MSD的开销小。\n>\n> 注意：排序需要稳定的算法，可以用计数排序实现。稳定的排序才可以保留上一次排序的结果。\n>\n> **Tips：**\n>\n> - 以上三种方法虽然灵活性不如快排等方法，但在某些情况下，可以充分利用序列的一些性质，从而取得较好的算法性能。\n>\n> 可参考：[三种线性排序算法 计数排序、桶排序与基数排序](https://byvoid.com/zhs/blog/sort-radix/)\n>\n>  [基数排序、桶排序和计数排序的区别](https://blog.csdn.net/qq_19446965/article/details/81517552)\n\n\n\n## [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/) ☆\n\n滑动窗口的经典题\n\n找到一个序列，使得这个序列的长度小于等于出现次数最多的字符数+k。于是问题来到了怎么确定序列中出现最多的字符数：每次右指针向右移动时，当前字符的出现次数+1，比较当前字符数与最多字符数即可。\n\n注意在当前字符数减小时，不需要改变出现最多的字符数，它确定了滑动窗的大小，更新的滑动窗大小不应该变小。只需要在变大的时候更新。\n\n\n\n## [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)\n\n一个滑动窗，窗口内的元素要满足：1. 窗口内的元素出现在p中；2. 窗口内出现元素的次数要小于等于s中出现的次数。从而，当窗口大小与p长度相等时，将索引加入结果中。将这两个条件可以进行合并：窗口内元素的出现次数小于等于s中出现的次数（p中没有的字符出现次数就是0）。\n\n这样的条件合并就需要统计所有26个字母出现的次数。我一开始的做法用map只统计p中出现了的元素，这样在还原的时候，稍微复杂了一些，不然可以合并。\n\n滑动窗的设计思路和基本框架一致：1. 设置左右指针；2. 更新右指针引起的状态变化；3. 检查是否还满足条件，不满足条件的话左指针右移；4. 右指针右移\n\n参考：[找到字符串中所有字母异位词，滑动窗口 + 数组/双指针](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/438-zhao-dao-zi-fu-chuan-zhong-suo-you-z-nx6b/)\n\n题解下最赞评论：滑动窗方法能从暴力解法出发进行优化。\n\n（PS. 我发现其实很多方法都可以通过暴力解法来出发思考）\n\n## [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)\n\n和438类似。\n\n需要注意的是子串是连续的！\n\n（所以用字符串排列然后找是不是包含子串的方法行不通/doge）\n\n## [904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)\n\n翻译一下题目：找到一个连续序列，这个序列中出现的数字最多为两种，求这个连续序列的最大长度。\n\n这样一来就是滑动窗的基础用法了~\n\n# 困难\n\n## [480. 滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)\n\n见数据结构篇\n\n## [992. K 个不同整数的子数组](https://leetcode-cn.com/problems/subarrays-with-k-different-integers/)\n\n如果理解了做法，就比较好做了。\n\n重点：**K个不同整数的子数组=最多K个整数的子数组-最多K-1个整数的子数组**\n\n然后只要写出**求最多K个整数的子数组**的函数即可。\n\n滑动窗的基本操作。要注意的是求子数组的时候，每次固定右端点计算能得到的子数组，是right-left+1个。\n","slug":"Leetcode刷题之滑动窗口","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggu001538t4b1ze9yan","content":"<p>双指针类型题目，持续更新</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p> 邓宁-克鲁格效应是指的是能力欠缺的人在自己欠考虑的决定的基础上得出错误结论，但是无法正确认识到自身的不足，辨别错误行为，是一种认知偏差现象。这些能力欠缺者们沉浸在自我营造的虚幻的优势之中，常常高估自己的能力水平，却无法客观评价他人的能力。</p>\n</blockquote>\n<p><a href=\"https://www.zhihu.com/question/314669016\">什么是「滑动窗口算法」（sliding window algorithm），有哪些应用场景？ - 知乎</a></p>\n<p>最高赞的回答不错。滑动窗口在处理数组和字符串上很适用。</p>\n<p>窗口大小分为固定的和可变的两种。</p>\n<p>固定的滑动窗口：后面加进来一个，前面推出去一个。</p>\n<p>可变的滑动窗口：窗口加到到满足条件或不满足条件为止，前面的元素推出去。</p>\n<p><a href=\"https://leetcode-cn.com/problems/shortest-supersequence-lcci/solution/xiang-xi-tu-jie-hua-dong-chuang-kou-chao-qi7g/\">【详细图解】滑动窗口（超99） - 最短超串 - 力扣（LeetCode）</a></p>\n<p>可用于查找满足某些条件的<strong>连续区间</strong>的性质（如长度）。由于区间连续，当区间变化时，可以通过之前的计算结果来对搜索空间进行剪枝。</p>\n<h1 id=\"简单\"><a href=\"#简单\" class=\"headerlink\" title=\"简单\"></a>简单</h1><h2 id=\"219-存在重复元素-II\"><a href=\"#219-存在重复元素-II\" class=\"headerlink\" title=\"219. 存在重复元素 II\"></a><a href=\"https://leetcode-cn.com/problems/contains-duplicate-ii/\">219. 存在重复元素 II</a></h2><p>维护一个可变的滑动窗（用Set）</p>\n<h2 id=\"643-子数组最大平均数-I\"><a href=\"#643-子数组最大平均数-I\" class=\"headerlink\" title=\"643. 子数组最大平均数 I\"></a><a href=\"https://leetcode-cn.com/problems/maximum-average-subarray-i/\">643. 子数组最大平均数 I</a></h2><p>两种方法。1. presum，前缀和。2. 滑动窗</p>\n<p>presum：创建一个数组，长度为N。第i个元素存放前i个元素之和（注意自己的代码写的是否包括了第i个元素）。</p>\n<p>滑动窗：先取得前k个元素和，形成一个长度为k的窗口。然后开始移动，每向后移动一个元素，加上当前元素，减去第一个元素。</p>\n<h1 id=\"中等\"><a href=\"#中等\" class=\"headerlink\" title=\"中等\"></a>中等</h1><h2 id=\"187-重复的DNA序列\"><a href=\"#187-重复的DNA序列\" class=\"headerlink\" title=\"187. 重复的DNA序列\"></a><a href=\"https://leetcode-cn.com/problems/repeated-dna-sequences/\">187. 重复的DNA序列</a></h2><p>一般的滑动窗感觉占用空间太大了，即用哈希表，子串映射到出现次数。但是对于最大长度为$10^5$的字符串，我觉得太大。（但是还是可以用的，面试的时候想不出更好的就用这个！做出来比做好可能更重要！）</p>\n<p>这里第一次学习到了<strong>字符串哈希</strong>。</p>\n<p><a href=\"https://oi-wiki.org/string/hash/\">字符串哈希 - OI Wiki</a></p>\n<p>记录一下为什么用131313：字符串哈希本身存在哈希冲突的可能，一般会在尝试 131之后尝试使用 13131，然后再尝试使用比 13131 更大的质数。（参考<a href=\"https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/\">三叶的答案</a>）</p>\n<h2 id=\"209-长度最小的子数组-☆\"><a href=\"#209-长度最小的子数组-☆\" class=\"headerlink\" title=\"209. 长度最小的子数组 ☆\"></a><a href=\"https://leetcode-cn.com/problems/minimum-size-subarray-sum/\">209. 长度最小的子数组</a> ☆</h2><p><del>没有理清楚，记录一下自己的代码。</del></p>\n<p>滑动窗口的经典题目。</p>\n<p>还有其他方法，比如前缀和。</p>\n<h2 id=\"220-存在重复元素-III\"><a href=\"#220-存在重复元素-III\" class=\"headerlink\" title=\"220. 存在重复元素 III\"></a><a href=\"https://leetcode-cn.com/problems/contains-duplicate-iii/\">220. 存在重复元素 III</a></h2><p>暴力解法即遍历元素，对第i个元素向后检查k个元素，但是这样做会超时。</p>\n<p>三叶姐的题解展示了两种方法：</p>\n<p><strong>滑动窗&amp;红黑树</strong></p>\n<p>对暴力解法进行优化，可以对检查k个元素的过程进行优化。k个元素用一个<strong>有序集合</strong>来维护，而这个集合需要实现高效的<strong>查询</strong>和<strong>插入删除</strong>操作。由此可以想到使用<strong>树</strong>。</p>\n<p>再利用TreeMap中的ceiling和flooring函数，得到最接近当前元素的值。</p>\n<blockquote>\n<p>AVL：一种<strong>平衡二叉搜索树</strong>。具有两个性质：左边大于右边；任意节点的孩子节点之间高度差最大为1。因为第二个性质，在插入或删除元素时可能需要进行重平衡，可以通过旋转的方法实现。一次平衡操作伴随着多次旋转。</p>\n<p>RBT：<strong>红黑树</strong>。是一种二叉树，但每一个节点多了一个属性：颜色。是一种弱平衡二叉搜索树，它不像AVL要求左右高度差不大于1，但对路径长度要求“任何一条路径的长度不能大于其他路径长度的两倍”。这样使得RBT比AVL在插删操作上，运行速度更快，因为旋转次数变少。</p>\n<p>BST：<strong>二叉搜索树</strong>（binary search tree）</p>\n</blockquote>\n<p><strong>桶</strong></p>\n<blockquote>\n<p><strong>桶排序</strong></p>\n<p>令需要排序的序列一共有n个元素，将这n个元素分到m个桶中，这些桶满足：当前桶中的元素都小于后面桶的元素。然后对每个桶分别进行排序，最后合并每个桶的结果。当m接近于n时，时间复杂度趋近于<code>O(n)</code>。桶排序是一种空间换时间的方法，它要求序列分布尽可能均匀，否则会出现空间上的浪费。</p>\n<p>顺便再介绍一下计数排序和基数排序，他们和桶排序都是线性时间复杂度的排序算法。他们是非基于比较的排序方法，基于比较的排序方法难以突破<code>O(nlogn)</code>的时间复杂度。</p>\n<p><strong>计数排序</strong></p>\n<p>一种特殊的桶排序。令序列的最小值为min，最大值为max，创建一个大小为max-min+1的数组。这个数组用来记录每一个数出现的次数。他是一种稳定的排序算法。</p>\n<p><strong>基数排序</strong></p>\n<p>基于<strong>多个关键字</strong>的排序。网络上对基数排序的例子以<strong>数位</strong>为主。</p>\n<p>从首要关键字开始的排序成为<strong>MSD（Most Significant Dight）</strong>，先根据首要关键字分成一些堆（如百位数），再对每个堆分别进行排序，然后串联这些堆。</p>\n<p>从最低有效关键字开始排序，称为**LSD(Least Significant Dight)**。先按照次要关键字来排序，然后按按照首要关键字排序，不需要对每一个堆进行排序，比MSD的开销小。</p>\n<p>注意：排序需要稳定的算法，可以用计数排序实现。稳定的排序才可以保留上一次排序的结果。</p>\n<p><strong>Tips：</strong></p>\n<ul>\n<li>以上三种方法虽然灵活性不如快排等方法，但在某些情况下，可以充分利用序列的一些性质，从而取得较好的算法性能。</li>\n</ul>\n<p>可参考：<a href=\"https://byvoid.com/zhs/blog/sort-radix/\">三种线性排序算法 计数排序、桶排序与基数排序</a></p>\n<p> <a href=\"https://blog.csdn.net/qq_19446965/article/details/81517552\">基数排序、桶排序和计数排序的区别</a></p>\n</blockquote>\n<h2 id=\"424-替换后的最长重复字符-☆\"><a href=\"#424-替换后的最长重复字符-☆\" class=\"headerlink\" title=\"424. 替换后的最长重复字符 ☆\"></a><a href=\"https://leetcode-cn.com/problems/longest-repeating-character-replacement/\">424. 替换后的最长重复字符</a> ☆</h2><p>滑动窗口的经典题</p>\n<p>找到一个序列，使得这个序列的长度小于等于出现次数最多的字符数+k。于是问题来到了怎么确定序列中出现最多的字符数：每次右指针向右移动时，当前字符的出现次数+1，比较当前字符数与最多字符数即可。</p>\n<p>注意在当前字符数减小时，不需要改变出现最多的字符数，它确定了滑动窗的大小，更新的滑动窗大小不应该变小。只需要在变大的时候更新。</p>\n<h2 id=\"438-找到字符串中所有字母异位词\"><a href=\"#438-找到字符串中所有字母异位词\" class=\"headerlink\" title=\"438. 找到字符串中所有字母异位词\"></a><a href=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/\">438. 找到字符串中所有字母异位词</a></h2><p>一个滑动窗，窗口内的元素要满足：1. 窗口内的元素出现在p中；2. 窗口内出现元素的次数要小于等于s中出现的次数。从而，当窗口大小与p长度相等时，将索引加入结果中。将这两个条件可以进行合并：窗口内元素的出现次数小于等于s中出现的次数（p中没有的字符出现次数就是0）。</p>\n<p>这样的条件合并就需要统计所有26个字母出现的次数。我一开始的做法用map只统计p中出现了的元素，这样在还原的时候，稍微复杂了一些，不然可以合并。</p>\n<p>滑动窗的设计思路和基本框架一致：1. 设置左右指针；2. 更新右指针引起的状态变化；3. 检查是否还满足条件，不满足条件的话左指针右移；4. 右指针右移</p>\n<p>参考：<a href=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/438-zhao-dao-zi-fu-chuan-zhong-suo-you-z-nx6b/\">找到字符串中所有字母异位词，滑动窗口 + 数组/双指针</a></p>\n<p>题解下最赞评论：滑动窗方法能从暴力解法出发进行优化。</p>\n<p>（PS. 我发现其实很多方法都可以通过暴力解法来出发思考）</p>\n<h2 id=\"567-字符串的排列\"><a href=\"#567-字符串的排列\" class=\"headerlink\" title=\"567. 字符串的排列\"></a><a href=\"https://leetcode-cn.com/problems/permutation-in-string/\">567. 字符串的排列</a></h2><p>和438类似。</p>\n<p>需要注意的是子串是连续的！</p>\n<p>（所以用字符串排列然后找是不是包含子串的方法行不通/doge）</p>\n<h2 id=\"904-水果成篮\"><a href=\"#904-水果成篮\" class=\"headerlink\" title=\"904. 水果成篮\"></a><a href=\"https://leetcode-cn.com/problems/fruit-into-baskets/\">904. 水果成篮</a></h2><p>翻译一下题目：找到一个连续序列，这个序列中出现的数字最多为两种，求这个连续序列的最大长度。</p>\n<p>这样一来就是滑动窗的基础用法了~</p>\n<h1 id=\"困难\"><a href=\"#困难\" class=\"headerlink\" title=\"困难\"></a>困难</h1><h2 id=\"480-滑动窗口中位数\"><a href=\"#480-滑动窗口中位数\" class=\"headerlink\" title=\"480. 滑动窗口中位数\"></a><a href=\"https://leetcode-cn.com/problems/sliding-window-median/\">480. 滑动窗口中位数</a></h2><p>见数据结构篇</p>\n<h2 id=\"992-K-个不同整数的子数组\"><a href=\"#992-K-个不同整数的子数组\" class=\"headerlink\" title=\"992. K 个不同整数的子数组\"></a><a href=\"https://leetcode-cn.com/problems/subarrays-with-k-different-integers/\">992. K 个不同整数的子数组</a></h2><p>如果理解了做法，就比较好做了。</p>\n<p>重点：<strong>K个不同整数的子数组=最多K个整数的子数组-最多K-1个整数的子数组</strong></p>\n<p>然后只要写出<strong>求最多K个整数的子数组</strong>的函数即可。</p>\n<p>滑动窗的基本操作。要注意的是求子数组的时候，每次固定右端点计算能得到的子数组，是right-left+1个。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>双指针类型题目，持续更新</p>","more":"<blockquote>\n<p> 邓宁-克鲁格效应是指的是能力欠缺的人在自己欠考虑的决定的基础上得出错误结论，但是无法正确认识到自身的不足，辨别错误行为，是一种认知偏差现象。这些能力欠缺者们沉浸在自我营造的虚幻的优势之中，常常高估自己的能力水平，却无法客观评价他人的能力。</p>\n</blockquote>\n<p><a href=\"https://www.zhihu.com/question/314669016\">什么是「滑动窗口算法」（sliding window algorithm），有哪些应用场景？ - 知乎</a></p>\n<p>最高赞的回答不错。滑动窗口在处理数组和字符串上很适用。</p>\n<p>窗口大小分为固定的和可变的两种。</p>\n<p>固定的滑动窗口：后面加进来一个，前面推出去一个。</p>\n<p>可变的滑动窗口：窗口加到到满足条件或不满足条件为止，前面的元素推出去。</p>\n<p><a href=\"https://leetcode-cn.com/problems/shortest-supersequence-lcci/solution/xiang-xi-tu-jie-hua-dong-chuang-kou-chao-qi7g/\">【详细图解】滑动窗口（超99） - 最短超串 - 力扣（LeetCode）</a></p>\n<p>可用于查找满足某些条件的<strong>连续区间</strong>的性质（如长度）。由于区间连续，当区间变化时，可以通过之前的计算结果来对搜索空间进行剪枝。</p>\n<h1 id=\"简单\"><a href=\"#简单\" class=\"headerlink\" title=\"简单\"></a>简单</h1><h2 id=\"219-存在重复元素-II\"><a href=\"#219-存在重复元素-II\" class=\"headerlink\" title=\"219. 存在重复元素 II\"></a><a href=\"https://leetcode-cn.com/problems/contains-duplicate-ii/\">219. 存在重复元素 II</a></h2><p>维护一个可变的滑动窗（用Set）</p>\n<h2 id=\"643-子数组最大平均数-I\"><a href=\"#643-子数组最大平均数-I\" class=\"headerlink\" title=\"643. 子数组最大平均数 I\"></a><a href=\"https://leetcode-cn.com/problems/maximum-average-subarray-i/\">643. 子数组最大平均数 I</a></h2><p>两种方法。1. presum，前缀和。2. 滑动窗</p>\n<p>presum：创建一个数组，长度为N。第i个元素存放前i个元素之和（注意自己的代码写的是否包括了第i个元素）。</p>\n<p>滑动窗：先取得前k个元素和，形成一个长度为k的窗口。然后开始移动，每向后移动一个元素，加上当前元素，减去第一个元素。</p>\n<h1 id=\"中等\"><a href=\"#中等\" class=\"headerlink\" title=\"中等\"></a>中等</h1><h2 id=\"187-重复的DNA序列\"><a href=\"#187-重复的DNA序列\" class=\"headerlink\" title=\"187. 重复的DNA序列\"></a><a href=\"https://leetcode-cn.com/problems/repeated-dna-sequences/\">187. 重复的DNA序列</a></h2><p>一般的滑动窗感觉占用空间太大了，即用哈希表，子串映射到出现次数。但是对于最大长度为$10^5$的字符串，我觉得太大。（但是还是可以用的，面试的时候想不出更好的就用这个！做出来比做好可能更重要！）</p>\n<p>这里第一次学习到了<strong>字符串哈希</strong>。</p>\n<p><a href=\"https://oi-wiki.org/string/hash/\">字符串哈希 - OI Wiki</a></p>\n<p>记录一下为什么用131313：字符串哈希本身存在哈希冲突的可能，一般会在尝试 131之后尝试使用 13131，然后再尝试使用比 13131 更大的质数。（参考<a href=\"https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/\">三叶的答案</a>）</p>\n<h2 id=\"209-长度最小的子数组-☆\"><a href=\"#209-长度最小的子数组-☆\" class=\"headerlink\" title=\"209. 长度最小的子数组 ☆\"></a><a href=\"https://leetcode-cn.com/problems/minimum-size-subarray-sum/\">209. 长度最小的子数组</a> ☆</h2><p><del>没有理清楚，记录一下自己的代码。</del></p>\n<p>滑动窗口的经典题目。</p>\n<p>还有其他方法，比如前缀和。</p>\n<h2 id=\"220-存在重复元素-III\"><a href=\"#220-存在重复元素-III\" class=\"headerlink\" title=\"220. 存在重复元素 III\"></a><a href=\"https://leetcode-cn.com/problems/contains-duplicate-iii/\">220. 存在重复元素 III</a></h2><p>暴力解法即遍历元素，对第i个元素向后检查k个元素，但是这样做会超时。</p>\n<p>三叶姐的题解展示了两种方法：</p>\n<p><strong>滑动窗&amp;红黑树</strong></p>\n<p>对暴力解法进行优化，可以对检查k个元素的过程进行优化。k个元素用一个<strong>有序集合</strong>来维护，而这个集合需要实现高效的<strong>查询</strong>和<strong>插入删除</strong>操作。由此可以想到使用<strong>树</strong>。</p>\n<p>再利用TreeMap中的ceiling和flooring函数，得到最接近当前元素的值。</p>\n<blockquote>\n<p>AVL：一种<strong>平衡二叉搜索树</strong>。具有两个性质：左边大于右边；任意节点的孩子节点之间高度差最大为1。因为第二个性质，在插入或删除元素时可能需要进行重平衡，可以通过旋转的方法实现。一次平衡操作伴随着多次旋转。</p>\n<p>RBT：<strong>红黑树</strong>。是一种二叉树，但每一个节点多了一个属性：颜色。是一种弱平衡二叉搜索树，它不像AVL要求左右高度差不大于1，但对路径长度要求“任何一条路径的长度不能大于其他路径长度的两倍”。这样使得RBT比AVL在插删操作上，运行速度更快，因为旋转次数变少。</p>\n<p>BST：<strong>二叉搜索树</strong>（binary search tree）</p>\n</blockquote>\n<p><strong>桶</strong></p>\n<blockquote>\n<p><strong>桶排序</strong></p>\n<p>令需要排序的序列一共有n个元素，将这n个元素分到m个桶中，这些桶满足：当前桶中的元素都小于后面桶的元素。然后对每个桶分别进行排序，最后合并每个桶的结果。当m接近于n时，时间复杂度趋近于<code>O(n)</code>。桶排序是一种空间换时间的方法，它要求序列分布尽可能均匀，否则会出现空间上的浪费。</p>\n<p>顺便再介绍一下计数排序和基数排序，他们和桶排序都是线性时间复杂度的排序算法。他们是非基于比较的排序方法，基于比较的排序方法难以突破<code>O(nlogn)</code>的时间复杂度。</p>\n<p><strong>计数排序</strong></p>\n<p>一种特殊的桶排序。令序列的最小值为min，最大值为max，创建一个大小为max-min+1的数组。这个数组用来记录每一个数出现的次数。他是一种稳定的排序算法。</p>\n<p><strong>基数排序</strong></p>\n<p>基于<strong>多个关键字</strong>的排序。网络上对基数排序的例子以<strong>数位</strong>为主。</p>\n<p>从首要关键字开始的排序成为<strong>MSD（Most Significant Dight）</strong>，先根据首要关键字分成一些堆（如百位数），再对每个堆分别进行排序，然后串联这些堆。</p>\n<p>从最低有效关键字开始排序，称为**LSD(Least Significant Dight)**。先按照次要关键字来排序，然后按按照首要关键字排序，不需要对每一个堆进行排序，比MSD的开销小。</p>\n<p>注意：排序需要稳定的算法，可以用计数排序实现。稳定的排序才可以保留上一次排序的结果。</p>\n<p><strong>Tips：</strong></p>\n<ul>\n<li>以上三种方法虽然灵活性不如快排等方法，但在某些情况下，可以充分利用序列的一些性质，从而取得较好的算法性能。</li>\n</ul>\n<p>可参考：<a href=\"https://byvoid.com/zhs/blog/sort-radix/\">三种线性排序算法 计数排序、桶排序与基数排序</a></p>\n<p> <a href=\"https://blog.csdn.net/qq_19446965/article/details/81517552\">基数排序、桶排序和计数排序的区别</a></p>\n</blockquote>\n<h2 id=\"424-替换后的最长重复字符-☆\"><a href=\"#424-替换后的最长重复字符-☆\" class=\"headerlink\" title=\"424. 替换后的最长重复字符 ☆\"></a><a href=\"https://leetcode-cn.com/problems/longest-repeating-character-replacement/\">424. 替换后的最长重复字符</a> ☆</h2><p>滑动窗口的经典题</p>\n<p>找到一个序列，使得这个序列的长度小于等于出现次数最多的字符数+k。于是问题来到了怎么确定序列中出现最多的字符数：每次右指针向右移动时，当前字符的出现次数+1，比较当前字符数与最多字符数即可。</p>\n<p>注意在当前字符数减小时，不需要改变出现最多的字符数，它确定了滑动窗的大小，更新的滑动窗大小不应该变小。只需要在变大的时候更新。</p>\n<h2 id=\"438-找到字符串中所有字母异位词\"><a href=\"#438-找到字符串中所有字母异位词\" class=\"headerlink\" title=\"438. 找到字符串中所有字母异位词\"></a><a href=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/\">438. 找到字符串中所有字母异位词</a></h2><p>一个滑动窗，窗口内的元素要满足：1. 窗口内的元素出现在p中；2. 窗口内出现元素的次数要小于等于s中出现的次数。从而，当窗口大小与p长度相等时，将索引加入结果中。将这两个条件可以进行合并：窗口内元素的出现次数小于等于s中出现的次数（p中没有的字符出现次数就是0）。</p>\n<p>这样的条件合并就需要统计所有26个字母出现的次数。我一开始的做法用map只统计p中出现了的元素，这样在还原的时候，稍微复杂了一些，不然可以合并。</p>\n<p>滑动窗的设计思路和基本框架一致：1. 设置左右指针；2. 更新右指针引起的状态变化；3. 检查是否还满足条件，不满足条件的话左指针右移；4. 右指针右移</p>\n<p>参考：<a href=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/438-zhao-dao-zi-fu-chuan-zhong-suo-you-z-nx6b/\">找到字符串中所有字母异位词，滑动窗口 + 数组/双指针</a></p>\n<p>题解下最赞评论：滑动窗方法能从暴力解法出发进行优化。</p>\n<p>（PS. 我发现其实很多方法都可以通过暴力解法来出发思考）</p>\n<h2 id=\"567-字符串的排列\"><a href=\"#567-字符串的排列\" class=\"headerlink\" title=\"567. 字符串的排列\"></a><a href=\"https://leetcode-cn.com/problems/permutation-in-string/\">567. 字符串的排列</a></h2><p>和438类似。</p>\n<p>需要注意的是子串是连续的！</p>\n<p>（所以用字符串排列然后找是不是包含子串的方法行不通/doge）</p>\n<h2 id=\"904-水果成篮\"><a href=\"#904-水果成篮\" class=\"headerlink\" title=\"904. 水果成篮\"></a><a href=\"https://leetcode-cn.com/problems/fruit-into-baskets/\">904. 水果成篮</a></h2><p>翻译一下题目：找到一个连续序列，这个序列中出现的数字最多为两种，求这个连续序列的最大长度。</p>\n<p>这样一来就是滑动窗的基础用法了~</p>\n<h1 id=\"困难\"><a href=\"#困难\" class=\"headerlink\" title=\"困难\"></a>困难</h1><h2 id=\"480-滑动窗口中位数\"><a href=\"#480-滑动窗口中位数\" class=\"headerlink\" title=\"480. 滑动窗口中位数\"></a><a href=\"https://leetcode-cn.com/problems/sliding-window-median/\">480. 滑动窗口中位数</a></h2><p>见数据结构篇</p>\n<h2 id=\"992-K-个不同整数的子数组\"><a href=\"#992-K-个不同整数的子数组\" class=\"headerlink\" title=\"992. K 个不同整数的子数组\"></a><a href=\"https://leetcode-cn.com/problems/subarrays-with-k-different-integers/\">992. K 个不同整数的子数组</a></h2><p>如果理解了做法，就比较好做了。</p>\n<p>重点：<strong>K个不同整数的子数组=最多K个整数的子数组-最多K-1个整数的子数组</strong></p>\n<p>然后只要写出<strong>求最多K个整数的子数组</strong>的函数即可。</p>\n<p>滑动窗的基本操作。要注意的是求子数组的时候，每次固定右端点计算能得到的子数组，是right-left+1个。</p>"},{"title":"Leetcode刷题之链表","date":"2021-12-29T11:30:31.000Z","updated":"2021-12-29T11:30:31.000Z","_content":"\n链表类型，持续更新\n\n<!--more-->\n\n一些学习和总结的文章：\n\n[算法面试题 | 链表问题总结 - 掘金](https://juejin.cn/post/6882370280946302983)\n\n[链表算法面试问题？看我就够了！_吴师兄学编程](https://www.cxyxiaowu.com/1400.html)\n\n\n\nTips\n\n- **双指针（快慢指针）**在链表中是一个比较重要的方法。\n\n- 可以设置一个没有意义的头节点（**虚拟头节点**）。没有意义的头节点可以避免一些特殊情况。\n\n- 在next之前，注意一下当前有没有可能为null，要判断一下是否为null才可以next。\n\n- 链表方法基本都能用**递归**。推荐阅读：https://lyl0724.github.io/2020/01/25/1/\n\n反转链表的递归解法，要多理解几遍\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        ListNode new_head = reverseList(head.next);\n        head.next.next = head;\n        head.next = null;\n        return new_head;\n    }\n}\n```\n\n\n\n# 简单\n\n## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)\n\n\n\n## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n用双指针，想到了但是不知道怎么用。\n\n[题解](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/)的评论太惊艳：\n\n走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。——@sylin\n\n## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)\n\n迭代方法很简单\n\n还有递归方法：（1）先设置递归结束条件（head为null）；（2）再设置递归（相当于压栈），直到最后一个节点；（3）设置返回值（相当于出栈）\n\nTips：\n\n- 迭代方法设置虚拟头结点\n- 递归方法的时间和空间复杂度都为O(n)\n\n## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n企业面试的高频题！要掌握递归写法和迭代写法。\n\n迭代的思路：\n\n第一种，我想到的。设置一个指向head的指针pre，每次将head.next插入pre和pre.next之间，然后移动head。这里要注意换next的时候不要出错。\n\n第二种，在题解中看到的。双指针，cur指向head，pre指向cur.next，每次将pre.next换成cur，然后pre和cur都向后移动一位。\n\n**递归**的思路：\n\n首先一直递归到最后一个节点进行返回，让他变成头节点。然后对于每一个节点node，使node.next.next=node.next，从而从后往前进行反向。\n\n## [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)\n\n## [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)\n\n删除链表这里记一笔关于Java的语法：Java中除了基本数据类型以外都是引用数据类型（包括自己定义的类）。引用类型和C里面的指针也不一样。这题里直接`ListNode node=node.next`是不行的，node这个名字指向了node.next，但是存储空间没有变，也就是原来node的地方，还是node，而不会替换成node.next。如果用C++的指针，定义为`ListNode *node`，可以写成：`*node=node->next;`\n\n## [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\n\n这里记一笔关于快慢指针之间差多少。我想到一个走1步，另一个走2步，但是没法确定是否快指针走到底，慢指针就在中间，这里我想错了，想成x+1和x+2的关系，事实上是x\\*1和x\\*2的关系，所以最后慢指针会停在中间。\n\n# 中等\n\n## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)\n\nTips：\n\n- 两个链表**长度可以不同**\n- **移动l1和l2指针**的时候，也要记得判断是否为null\n- 别忘了最后可能进位！（按位相加一定要记得进位，**特别是会多出来一位**）\n\n## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\nTips：\n\n- 经典递归\n\n## [61. 旋转链表2](https://leetcode-cn.com/problems/rotate-list/)\n\nTips：\n\n- 先计算长度，求出真正需要移动的k会比较省时，这样可以同时得到链表长度和真正需要移动的k次。（我一直在移动emm..）\n\n## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n做过一次环形链表但这次遇到还是不懂，我来推导一遍过程！\n\n\n\n# 困难\n\n## [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n\nTips：\n\n- **归并**（数组内归并）加递归\n- 优先堆（这个还不是很懂，还要看看）\n\n","source":"_posts/Leetcode刷题之链表.md","raw":"---\ntitle: Leetcode刷题之链表\ndate: 2021-12-29 19:30:31\nupdated: 2021-12-29 19:30:31\ncategories: 刷题\n---\n\n链表类型，持续更新\n\n<!--more-->\n\n一些学习和总结的文章：\n\n[算法面试题 | 链表问题总结 - 掘金](https://juejin.cn/post/6882370280946302983)\n\n[链表算法面试问题？看我就够了！_吴师兄学编程](https://www.cxyxiaowu.com/1400.html)\n\n\n\nTips\n\n- **双指针（快慢指针）**在链表中是一个比较重要的方法。\n\n- 可以设置一个没有意义的头节点（**虚拟头节点**）。没有意义的头节点可以避免一些特殊情况。\n\n- 在next之前，注意一下当前有没有可能为null，要判断一下是否为null才可以next。\n\n- 链表方法基本都能用**递归**。推荐阅读：https://lyl0724.github.io/2020/01/25/1/\n\n反转链表的递归解法，要多理解几遍\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        ListNode new_head = reverseList(head.next);\n        head.next.next = head;\n        head.next = null;\n        return new_head;\n    }\n}\n```\n\n\n\n# 简单\n\n## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)\n\n\n\n## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n用双指针，想到了但是不知道怎么用。\n\n[题解](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/)的评论太惊艳：\n\n走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。——@sylin\n\n## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)\n\n迭代方法很简单\n\n还有递归方法：（1）先设置递归结束条件（head为null）；（2）再设置递归（相当于压栈），直到最后一个节点；（3）设置返回值（相当于出栈）\n\nTips：\n\n- 迭代方法设置虚拟头结点\n- 递归方法的时间和空间复杂度都为O(n)\n\n## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n企业面试的高频题！要掌握递归写法和迭代写法。\n\n迭代的思路：\n\n第一种，我想到的。设置一个指向head的指针pre，每次将head.next插入pre和pre.next之间，然后移动head。这里要注意换next的时候不要出错。\n\n第二种，在题解中看到的。双指针，cur指向head，pre指向cur.next，每次将pre.next换成cur，然后pre和cur都向后移动一位。\n\n**递归**的思路：\n\n首先一直递归到最后一个节点进行返回，让他变成头节点。然后对于每一个节点node，使node.next.next=node.next，从而从后往前进行反向。\n\n## [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)\n\n## [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)\n\n删除链表这里记一笔关于Java的语法：Java中除了基本数据类型以外都是引用数据类型（包括自己定义的类）。引用类型和C里面的指针也不一样。这题里直接`ListNode node=node.next`是不行的，node这个名字指向了node.next，但是存储空间没有变，也就是原来node的地方，还是node，而不会替换成node.next。如果用C++的指针，定义为`ListNode *node`，可以写成：`*node=node->next;`\n\n## [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\n\n这里记一笔关于快慢指针之间差多少。我想到一个走1步，另一个走2步，但是没法确定是否快指针走到底，慢指针就在中间，这里我想错了，想成x+1和x+2的关系，事实上是x\\*1和x\\*2的关系，所以最后慢指针会停在中间。\n\n# 中等\n\n## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)\n\nTips：\n\n- 两个链表**长度可以不同**\n- **移动l1和l2指针**的时候，也要记得判断是否为null\n- 别忘了最后可能进位！（按位相加一定要记得进位，**特别是会多出来一位**）\n\n## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\nTips：\n\n- 经典递归\n\n## [61. 旋转链表2](https://leetcode-cn.com/problems/rotate-list/)\n\nTips：\n\n- 先计算长度，求出真正需要移动的k会比较省时，这样可以同时得到链表长度和真正需要移动的k次。（我一直在移动emm..）\n\n## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n做过一次环形链表但这次遇到还是不懂，我来推导一遍过程！\n\n\n\n# 困难\n\n## [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n\nTips：\n\n- **归并**（数组内归并）加递归\n- 优先堆（这个还不是很懂，还要看看）\n\n","slug":"Leetcode刷题之链表","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggv001838t4bqwsdy97","content":"<p>链表类型，持续更新</p>\n<span id=\"more\"></span>\n\n<p>一些学习和总结的文章：</p>\n<p><a href=\"https://juejin.cn/post/6882370280946302983\">算法面试题 | 链表问题总结 - 掘金</a></p>\n<p><a href=\"https://www.cxyxiaowu.com/1400.html\">链表算法面试问题？看我就够了！_吴师兄学编程</a></p>\n<p>Tips</p>\n<ul>\n<li><p><strong>双指针（快慢指针）</strong>在链表中是一个比较重要的方法。</p>\n</li>\n<li><p>可以设置一个没有意义的头节点（<strong>虚拟头节点</strong>）。没有意义的头节点可以避免一些特殊情况。</p>\n</li>\n<li><p>在next之前，注意一下当前有没有可能为null，要判断一下是否为null才可以next。</p>\n</li>\n<li><p>链表方法基本都能用<strong>递归</strong>。推荐阅读：<a href=\"https://lyl0724.github.io/2020/01/25/1/\">https://lyl0724.github.io/2020/01/25/1/</a></p>\n</li>\n</ul>\n<p>反转链表的递归解法，要多理解几遍</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode new_head = reverseList(head.next);</span><br><span class=\"line\">        head.next.next = head;</span><br><span class=\"line\">        head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"简单\"><a href=\"#简单\" class=\"headerlink\" title=\"简单\"></a>简单</h1><h2 id=\"141-环形链表\"><a href=\"#141-环形链表\" class=\"headerlink\" title=\"141. 环形链表\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\">141. 环形链表</a></h2><h2 id=\"160-相交链表\"><a href=\"#160-相交链表\" class=\"headerlink\" title=\"160. 相交链表\"></a><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">160. 相交链表</a></h2><p>用双指针，想到了但是不知道怎么用。</p>\n<p><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/\">题解</a>的评论太惊艳：</p>\n<p>走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。——@sylin</p>\n<h2 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203. 移除链表元素\"></a><a href=\"https://leetcode-cn.com/problems/remove-linked-list-elements/\">203. 移除链表元素</a></h2><p>迭代方法很简单</p>\n<p>还有递归方法：（1）先设置递归结束条件（head为null）；（2）再设置递归（相当于压栈），直到最后一个节点；（3）设置返回值（相当于出栈）</p>\n<p>Tips：</p>\n<ul>\n<li>迭代方法设置虚拟头结点</li>\n<li>递归方法的时间和空间复杂度都为O(n)</li>\n</ul>\n<h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206. 反转链表\"></a><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">206. 反转链表</a></h2><p>企业面试的高频题！要掌握递归写法和迭代写法。</p>\n<p>迭代的思路：</p>\n<p>第一种，我想到的。设置一个指向head的指针pre，每次将head.next插入pre和pre.next之间，然后移动head。这里要注意换next的时候不要出错。</p>\n<p>第二种，在题解中看到的。双指针，cur指向head，pre指向cur.next，每次将pre.next换成cur，然后pre和cur都向后移动一位。</p>\n<p><strong>递归</strong>的思路：</p>\n<p>首先一直递归到最后一个节点进行返回，让他变成头节点。然后对于每一个节点node，使node.next.next=node.next，从而从后往前进行反向。</p>\n<h2 id=\"234-回文链表\"><a href=\"#234-回文链表\" class=\"headerlink\" title=\"234. 回文链表\"></a><a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">234. 回文链表</a></h2><h2 id=\"237-删除链表中的节点\"><a href=\"#237-删除链表中的节点\" class=\"headerlink\" title=\"237. 删除链表中的节点\"></a><a href=\"https://leetcode-cn.com/problems/delete-node-in-a-linked-list/\">237. 删除链表中的节点</a></h2><p>删除链表这里记一笔关于Java的语法：Java中除了基本数据类型以外都是引用数据类型（包括自己定义的类）。引用类型和C里面的指针也不一样。这题里直接<code>ListNode node=node.next</code>是不行的，node这个名字指向了node.next，但是存储空间没有变，也就是原来node的地方，还是node，而不会替换成node.next。如果用C++的指针，定义为<code>ListNode *node</code>，可以写成：<code>*node=node-&gt;next;</code></p>\n<h2 id=\"876-链表的中间结点\"><a href=\"#876-链表的中间结点\" class=\"headerlink\" title=\"876. 链表的中间结点\"></a><a href=\"https://leetcode-cn.com/problems/middle-of-the-linked-list/\">876. 链表的中间结点</a></h2><p>这里记一笔关于快慢指针之间差多少。我想到一个走1步，另一个走2步，但是没法确定是否快指针走到底，慢指针就在中间，这里我想错了，想成x+1和x+2的关系，事实上是x*1和x*2的关系，所以最后慢指针会停在中间。</p>\n<h1 id=\"中等\"><a href=\"#中等\" class=\"headerlink\" title=\"中等\"></a>中等</h1><h2 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2. 两数相加\"></a><a href=\"https://leetcode-cn.com/problems/add-two-numbers/\">2. 两数相加</a></h2><p>Tips：</p>\n<ul>\n<li>两个链表<strong>长度可以不同</strong></li>\n<li><strong>移动l1和l2指针</strong>的时候，也要记得判断是否为null</li>\n<li>别忘了最后可能进位！（按位相加一定要记得进位，<strong>特别是会多出来一位</strong>）</li>\n</ul>\n<h2 id=\"24-两两交换链表中的节点\"><a href=\"#24-两两交换链表中的节点\" class=\"headerlink\" title=\"24. 两两交换链表中的节点\"></a><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/\">24. 两两交换链表中的节点</a></h2><p>Tips：</p>\n<ul>\n<li>经典递归</li>\n</ul>\n<h2 id=\"61-旋转链表2\"><a href=\"#61-旋转链表2\" class=\"headerlink\" title=\"61. 旋转链表2\"></a><a href=\"https://leetcode-cn.com/problems/rotate-list/\">61. 旋转链表2</a></h2><p>Tips：</p>\n<ul>\n<li>先计算长度，求出真正需要移动的k会比较省时，这样可以同时得到链表长度和真正需要移动的k次。（我一直在移动emm..）</li>\n</ul>\n<h2 id=\"142-环形链表-II\"><a href=\"#142-环形链表-II\" class=\"headerlink\" title=\"142. 环形链表 II\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">142. 环形链表 II</a></h2><p>做过一次环形链表但这次遇到还是不懂，我来推导一遍过程！</p>\n<h1 id=\"困难\"><a href=\"#困难\" class=\"headerlink\" title=\"困难\"></a>困难</h1><h2 id=\"23-合并K个升序链表\"><a href=\"#23-合并K个升序链表\" class=\"headerlink\" title=\"23. 合并K个升序链表\"></a><a href=\"https://leetcode-cn.com/problems/merge-k-sorted-lists/\">23. 合并K个升序链表</a></h2><p>Tips：</p>\n<ul>\n<li><strong>归并</strong>（数组内归并）加递归</li>\n<li>优先堆（这个还不是很懂，还要看看）</li>\n</ul>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>链表类型，持续更新</p>","more":"<p>一些学习和总结的文章：</p>\n<p><a href=\"https://juejin.cn/post/6882370280946302983\">算法面试题 | 链表问题总结 - 掘金</a></p>\n<p><a href=\"https://www.cxyxiaowu.com/1400.html\">链表算法面试问题？看我就够了！_吴师兄学编程</a></p>\n<p>Tips</p>\n<ul>\n<li><p><strong>双指针（快慢指针）</strong>在链表中是一个比较重要的方法。</p>\n</li>\n<li><p>可以设置一个没有意义的头节点（<strong>虚拟头节点</strong>）。没有意义的头节点可以避免一些特殊情况。</p>\n</li>\n<li><p>在next之前，注意一下当前有没有可能为null，要判断一下是否为null才可以next。</p>\n</li>\n<li><p>链表方法基本都能用<strong>递归</strong>。推荐阅读：<a href=\"https://lyl0724.github.io/2020/01/25/1/\">https://lyl0724.github.io/2020/01/25/1/</a></p>\n</li>\n</ul>\n<p>反转链表的递归解法，要多理解几遍</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode new_head = reverseList(head.next);</span><br><span class=\"line\">        head.next.next = head;</span><br><span class=\"line\">        head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"简单\"><a href=\"#简单\" class=\"headerlink\" title=\"简单\"></a>简单</h1><h2 id=\"141-环形链表\"><a href=\"#141-环形链表\" class=\"headerlink\" title=\"141. 环形链表\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\">141. 环形链表</a></h2><h2 id=\"160-相交链表\"><a href=\"#160-相交链表\" class=\"headerlink\" title=\"160. 相交链表\"></a><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">160. 相交链表</a></h2><p>用双指针，想到了但是不知道怎么用。</p>\n<p><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/\">题解</a>的评论太惊艳：</p>\n<p>走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。——@sylin</p>\n<h2 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203. 移除链表元素\"></a><a href=\"https://leetcode-cn.com/problems/remove-linked-list-elements/\">203. 移除链表元素</a></h2><p>迭代方法很简单</p>\n<p>还有递归方法：（1）先设置递归结束条件（head为null）；（2）再设置递归（相当于压栈），直到最后一个节点；（3）设置返回值（相当于出栈）</p>\n<p>Tips：</p>\n<ul>\n<li>迭代方法设置虚拟头结点</li>\n<li>递归方法的时间和空间复杂度都为O(n)</li>\n</ul>\n<h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206. 反转链表\"></a><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">206. 反转链表</a></h2><p>企业面试的高频题！要掌握递归写法和迭代写法。</p>\n<p>迭代的思路：</p>\n<p>第一种，我想到的。设置一个指向head的指针pre，每次将head.next插入pre和pre.next之间，然后移动head。这里要注意换next的时候不要出错。</p>\n<p>第二种，在题解中看到的。双指针，cur指向head，pre指向cur.next，每次将pre.next换成cur，然后pre和cur都向后移动一位。</p>\n<p><strong>递归</strong>的思路：</p>\n<p>首先一直递归到最后一个节点进行返回，让他变成头节点。然后对于每一个节点node，使node.next.next=node.next，从而从后往前进行反向。</p>\n<h2 id=\"234-回文链表\"><a href=\"#234-回文链表\" class=\"headerlink\" title=\"234. 回文链表\"></a><a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">234. 回文链表</a></h2><h2 id=\"237-删除链表中的节点\"><a href=\"#237-删除链表中的节点\" class=\"headerlink\" title=\"237. 删除链表中的节点\"></a><a href=\"https://leetcode-cn.com/problems/delete-node-in-a-linked-list/\">237. 删除链表中的节点</a></h2><p>删除链表这里记一笔关于Java的语法：Java中除了基本数据类型以外都是引用数据类型（包括自己定义的类）。引用类型和C里面的指针也不一样。这题里直接<code>ListNode node=node.next</code>是不行的，node这个名字指向了node.next，但是存储空间没有变，也就是原来node的地方，还是node，而不会替换成node.next。如果用C++的指针，定义为<code>ListNode *node</code>，可以写成：<code>*node=node-&gt;next;</code></p>\n<h2 id=\"876-链表的中间结点\"><a href=\"#876-链表的中间结点\" class=\"headerlink\" title=\"876. 链表的中间结点\"></a><a href=\"https://leetcode-cn.com/problems/middle-of-the-linked-list/\">876. 链表的中间结点</a></h2><p>这里记一笔关于快慢指针之间差多少。我想到一个走1步，另一个走2步，但是没法确定是否快指针走到底，慢指针就在中间，这里我想错了，想成x+1和x+2的关系，事实上是x*1和x*2的关系，所以最后慢指针会停在中间。</p>\n<h1 id=\"中等\"><a href=\"#中等\" class=\"headerlink\" title=\"中等\"></a>中等</h1><h2 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2. 两数相加\"></a><a href=\"https://leetcode-cn.com/problems/add-two-numbers/\">2. 两数相加</a></h2><p>Tips：</p>\n<ul>\n<li>两个链表<strong>长度可以不同</strong></li>\n<li><strong>移动l1和l2指针</strong>的时候，也要记得判断是否为null</li>\n<li>别忘了最后可能进位！（按位相加一定要记得进位，<strong>特别是会多出来一位</strong>）</li>\n</ul>\n<h2 id=\"24-两两交换链表中的节点\"><a href=\"#24-两两交换链表中的节点\" class=\"headerlink\" title=\"24. 两两交换链表中的节点\"></a><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/\">24. 两两交换链表中的节点</a></h2><p>Tips：</p>\n<ul>\n<li>经典递归</li>\n</ul>\n<h2 id=\"61-旋转链表2\"><a href=\"#61-旋转链表2\" class=\"headerlink\" title=\"61. 旋转链表2\"></a><a href=\"https://leetcode-cn.com/problems/rotate-list/\">61. 旋转链表2</a></h2><p>Tips：</p>\n<ul>\n<li>先计算长度，求出真正需要移动的k会比较省时，这样可以同时得到链表长度和真正需要移动的k次。（我一直在移动emm..）</li>\n</ul>\n<h2 id=\"142-环形链表-II\"><a href=\"#142-环形链表-II\" class=\"headerlink\" title=\"142. 环形链表 II\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">142. 环形链表 II</a></h2><p>做过一次环形链表但这次遇到还是不懂，我来推导一遍过程！</p>\n<h1 id=\"困难\"><a href=\"#困难\" class=\"headerlink\" title=\"困难\"></a>困难</h1><h2 id=\"23-合并K个升序链表\"><a href=\"#23-合并K个升序链表\" class=\"headerlink\" title=\"23. 合并K个升序链表\"></a><a href=\"https://leetcode-cn.com/problems/merge-k-sorted-lists/\">23. 合并K个升序链表</a></h2><p>Tips：</p>\n<ul>\n<li><strong>归并</strong>（数组内归并）加递归</li>\n<li>优先堆（这个还不是很懂，还要看看）</li>\n</ul>"},{"title":"Pycharm中打不开Python Console|DLL load failed","date":"2020-03-18T12:26:35.000Z","_content":"\n解决方法在这：[StackOverflow][1]\n\n<!--more-->\n\n另，最近在做知识图谱的毕设，要安装Neo4j.\nneo4j官网下载太慢了！ 国内下载地址在这：[Neo4j图数据库中文社区][2]\n\n\n\n[1]: https://stackoverflow.com/questions/54175042/python-3-7-anaconda-environment-import-ssl-dll-load-fail-error?answertab=votes#tab-top\n[2]: http://neo4j.com.cn/topic/5b003eae9662eee704f31cee","source":"_posts/Pycharm中打不开Python-Console-le.md","raw":"---\ntitle: Pycharm中打不开Python Console|DLL load failed\ndate: 2020-03-18 20:26:35\ncategories: 问题解决SolvedProblems\n---\n\n解决方法在这：[StackOverflow][1]\n\n<!--more-->\n\n另，最近在做知识图谱的毕设，要安装Neo4j.\nneo4j官网下载太慢了！ 国内下载地址在这：[Neo4j图数据库中文社区][2]\n\n\n\n[1]: https://stackoverflow.com/questions/54175042/python-3-7-anaconda-environment-import-ssl-dll-load-fail-error?answertab=votes#tab-top\n[2]: http://neo4j.com.cn/topic/5b003eae9662eee704f31cee","slug":"Pycharm中打不开Python-Console-le","published":1,"updated":"2020-03-18T12:26:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggv001b38t47t8v348q","content":"<p>解决方法在这：<a href=\"https://stackoverflow.com/questions/54175042/python-3-7-anaconda-environment-import-ssl-dll-load-fail-error?answertab=votes#tab-top\">StackOverflow</a></p>\n<span id=\"more\"></span>\n\n<p>另，最近在做知识图谱的毕设，要安装Neo4j.<br>neo4j官网下载太慢了！ 国内下载地址在这：<a href=\"http://neo4j.com.cn/topic/5b003eae9662eee704f31cee\">Neo4j图数据库中文社区</a></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>解决方法在这：<a href=\"https://stackoverflow.com/questions/54175042/python-3-7-anaconda-environment-import-ssl-dll-load-fail-error?answertab=votes#tab-top\">StackOverflow</a></p>","more":"<p>另，最近在做知识图谱的毕设，要安装Neo4j.<br>neo4j官网下载太慢了！ 国内下载地址在这：<a href=\"http://neo4j.com.cn/topic/5b003eae9662eee704f31cee\">Neo4j图数据库中文社区</a></p>"},{"title":"Python学习-Day1","date":"2020-02-06T04:45:28.000Z","_content":"---\n\n只会些毛，现在学些皮，目标是会些皮毛。\n\n<!--more-->\n\n---\n\n## 写在前面\n> \n1. Make English as your working language.\n2. Practice makes perfect.\n3. All experience comes from mistakes.\n4. Don't be one of the leeches.\nEither stand out or kicked out.\n(from [GitHub/Python-100-Days][1])\n\n那些Python能做的事情：\n基本任务，网站，后台\n那些Python不能做的事情：\n操作系统（C），手机应用（Swift/Objective-C或Java），3D游戏（C/C++）\n一些Python特性：\n1. 一种高级语言，代码少但运行慢。\n2. 优雅，简单，明确\nPython之父：\nGuido van Rossum（吉多·范罗苏姆），荷兰人\n\nPython解释器\nCPython，官网安装后自动下载的解释器。\n\nPython是解释型语言（解释器对程序逐行进行解释然后直接运行）（编译型语言）\n\n## 输入与输出\n\n输出\nprint('Hello', 'World!')\n输入\nx = input('please input x:')\n\n## 数据类型和变量\n\nPython能直接处理的数据类型有：整数，浮点数，字符串，布尔值，空值（None）等\n\n十六进制表示整数：前面加```0x```\n科学记数法：```1.23e9```，```2e-5```\n当字符串中要有```'```的时候，字符串用双引号```\"\"```括起来。如果字符串中要有```\"```，就用转义符```\\```。\n```r''``` 表示 ```''``` 内的字符不转义\n\nPython是**动态语言**，即变量本身类型不固定。\n变量赋值的过程：在内存中创建变量，并令变量指向相应的数据。\n常量通常使用**全部大写**的变量名表示。\n\n## 字符编码\n\n**Unicode编码**：把所有语言都统一到一个编码中去。通常是2个字节。\n**ASCII编码**：美国人发明，只给大小写字母、数字和一些符号编了码。1个字节。\n**UTF-8编码**：可变长编码。把Unicode字符根据数字不同且使用频率的不同编码得到1-6个字节的UTF-8编码。从而节省空间。\n\n现在计算机系统通用的字符编码工作方式：在内存中通过Unicode编码，当需要存储到硬盘或者传输的时候就转为UTF-8编码。\n\nPython3中，字符串采用的是**Unicode编码**。\n```ord()``` 取字符对应的编码。 ```chr()``` 取编码对应的字符。\n字符串还可以用十六进制表示：\n```'\\u6587'``` 即表示'文'\n```bytes``` 类型:字符串在传输或者硬盘存储时用字节。\nencode('ascii') 函数可以将字符串转换为对应的bytes。decode('ascii')函数可以将网络或者硬盘上读到的bytes转换为对应的字符串\ndecode加上参数```errors='ignore'```就可以忽略字节流中无法识别的字节。\nlen()函数统计str中包含多少个**字符**，bytes中包含多少个**字节**\n\n格式化：\n\n%：\n```python\n>>>print('Hello%s %s %%' % (',', 'World'))\nHello, World%\n```\n\nformat():\n```python\n>>>print('Hello,{0}{1:.1f}'.format('World', 3.14))\nHello,World3.1\n```\n\n\n* 在记事本**编辑**时，是**Unicode**编码。文件保存到磁盘时，是**UTF-8编码**。\n* 字符串用utf-8编码转为字节流会这样表示：\n\n```python\n>>> '中文'.encode('utf-8')\nb'\\xe4\\xb8\\xad\\xe6\\x96\\x87'\n```\n\n* 在python源码中经常能看到：\n```python\n# !/usr/bin/env python3\n# -*- coding: utf-8 -*-\n```\n其中，第一句告诉Linux/OS X系统这是一个python可执行程序，Windows系统会自动忽略；第二句是说明要用UTF-8读取源代码\n\n\n## 小结一下~\n\n今天主要有点复杂的部分就是编码了。另外就是Python的一些特性：解释性，动态性\n\n关于字符与编码：\n1. Unicode，ASCII，UTF-8\n2. bytes类型\n3. encode()和decode()\n4. 格式化方法\n\n  [1]: https://github.com/jackfrued/Python-100-Days","source":"_posts/Python学习-Day1.md","raw":"---\ntitle: Python学习-Day1\ndate: 2020-02-06 12:45:28\ncategories: 学习Learning\n---\n---\n\n只会些毛，现在学些皮，目标是会些皮毛。\n\n<!--more-->\n\n---\n\n## 写在前面\n> \n1. Make English as your working language.\n2. Practice makes perfect.\n3. All experience comes from mistakes.\n4. Don't be one of the leeches.\nEither stand out or kicked out.\n(from [GitHub/Python-100-Days][1])\n\n那些Python能做的事情：\n基本任务，网站，后台\n那些Python不能做的事情：\n操作系统（C），手机应用（Swift/Objective-C或Java），3D游戏（C/C++）\n一些Python特性：\n1. 一种高级语言，代码少但运行慢。\n2. 优雅，简单，明确\nPython之父：\nGuido van Rossum（吉多·范罗苏姆），荷兰人\n\nPython解释器\nCPython，官网安装后自动下载的解释器。\n\nPython是解释型语言（解释器对程序逐行进行解释然后直接运行）（编译型语言）\n\n## 输入与输出\n\n输出\nprint('Hello', 'World!')\n输入\nx = input('please input x:')\n\n## 数据类型和变量\n\nPython能直接处理的数据类型有：整数，浮点数，字符串，布尔值，空值（None）等\n\n十六进制表示整数：前面加```0x```\n科学记数法：```1.23e9```，```2e-5```\n当字符串中要有```'```的时候，字符串用双引号```\"\"```括起来。如果字符串中要有```\"```，就用转义符```\\```。\n```r''``` 表示 ```''``` 内的字符不转义\n\nPython是**动态语言**，即变量本身类型不固定。\n变量赋值的过程：在内存中创建变量，并令变量指向相应的数据。\n常量通常使用**全部大写**的变量名表示。\n\n## 字符编码\n\n**Unicode编码**：把所有语言都统一到一个编码中去。通常是2个字节。\n**ASCII编码**：美国人发明，只给大小写字母、数字和一些符号编了码。1个字节。\n**UTF-8编码**：可变长编码。把Unicode字符根据数字不同且使用频率的不同编码得到1-6个字节的UTF-8编码。从而节省空间。\n\n现在计算机系统通用的字符编码工作方式：在内存中通过Unicode编码，当需要存储到硬盘或者传输的时候就转为UTF-8编码。\n\nPython3中，字符串采用的是**Unicode编码**。\n```ord()``` 取字符对应的编码。 ```chr()``` 取编码对应的字符。\n字符串还可以用十六进制表示：\n```'\\u6587'``` 即表示'文'\n```bytes``` 类型:字符串在传输或者硬盘存储时用字节。\nencode('ascii') 函数可以将字符串转换为对应的bytes。decode('ascii')函数可以将网络或者硬盘上读到的bytes转换为对应的字符串\ndecode加上参数```errors='ignore'```就可以忽略字节流中无法识别的字节。\nlen()函数统计str中包含多少个**字符**，bytes中包含多少个**字节**\n\n格式化：\n\n%：\n```python\n>>>print('Hello%s %s %%' % (',', 'World'))\nHello, World%\n```\n\nformat():\n```python\n>>>print('Hello,{0}{1:.1f}'.format('World', 3.14))\nHello,World3.1\n```\n\n\n* 在记事本**编辑**时，是**Unicode**编码。文件保存到磁盘时，是**UTF-8编码**。\n* 字符串用utf-8编码转为字节流会这样表示：\n\n```python\n>>> '中文'.encode('utf-8')\nb'\\xe4\\xb8\\xad\\xe6\\x96\\x87'\n```\n\n* 在python源码中经常能看到：\n```python\n# !/usr/bin/env python3\n# -*- coding: utf-8 -*-\n```\n其中，第一句告诉Linux/OS X系统这是一个python可执行程序，Windows系统会自动忽略；第二句是说明要用UTF-8读取源代码\n\n\n## 小结一下~\n\n今天主要有点复杂的部分就是编码了。另外就是Python的一些特性：解释性，动态性\n\n关于字符与编码：\n1. Unicode，ASCII，UTF-8\n2. bytes类型\n3. encode()和decode()\n4. 格式化方法\n\n  [1]: https://github.com/jackfrued/Python-100-Days","slug":"Python学习-Day1","published":1,"updated":"2020-02-06T04:45:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggw001f38t4bqw56nhz","content":"<hr>\n<p>只会些毛，现在学些皮，目标是会些皮毛。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><blockquote>\n</blockquote>\n<ol>\n<li>Make English as your working language.</li>\n<li>Practice makes perfect.</li>\n<li>All experience comes from mistakes.</li>\n<li>Don’t be one of the leeches.<br>Either stand out or kicked out.<br>(from <a href=\"https://github.com/jackfrued/Python-100-Days\">GitHub/Python-100-Days</a>)</li>\n</ol>\n<p>那些Python能做的事情：<br>基本任务，网站，后台<br>那些Python不能做的事情：<br>操作系统（C），手机应用（Swift/Objective-C或Java），3D游戏（C/C++）<br>一些Python特性：</p>\n<ol>\n<li>一种高级语言，代码少但运行慢。</li>\n<li>优雅，简单，明确<br>Python之父：<br>Guido van Rossum（吉多·范罗苏姆），荷兰人</li>\n</ol>\n<p>Python解释器<br>CPython，官网安装后自动下载的解释器。</p>\n<p>Python是解释型语言（解释器对程序逐行进行解释然后直接运行）（编译型语言）</p>\n<h2 id=\"输入与输出\"><a href=\"#输入与输出\" class=\"headerlink\" title=\"输入与输出\"></a>输入与输出</h2><p>输出<br>print(‘Hello’, ‘World!’)<br>输入<br>x = input(‘please input x:’)</p>\n<h2 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h2><p>Python能直接处理的数据类型有：整数，浮点数，字符串，布尔值，空值（None）等</p>\n<p>十六进制表示整数：前面加<code>0x</code><br>科学记数法：<code>1.23e9</code>，<code>2e-5</code><br>当字符串中要有<code>&#39;</code>的时候，字符串用双引号<code>&quot;&quot;</code>括起来。如果字符串中要有<code>&quot;</code>，就用转义符<code>\\</code>。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>表示 ```''``` 内的字符不转义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Python是**动态语言**，即变量本身类型不固定。</span><br><span class=\"line\">变量赋值的过程：在内存中创建变量，并令变量指向相应的数据。</span><br><span class=\"line\">常量通常使用**全部大写**的变量名表示。</span><br><span class=\"line\"></span><br><span class=\"line\">## 字符编码</span><br><span class=\"line\"></span><br><span class=\"line\">**Unicode编码**：把所有语言都统一到一个编码中去。通常是2个字节。</span><br><span class=\"line\">**ASCII编码**：美国人发明，只给大小写字母、数字和一些符号编了码。1个字节。</span><br><span class=\"line\">**UTF-8编码**：可变长编码。把Unicode字符根据数字不同且使用频率的不同编码得到1-6个字节的UTF-8编码。从而节省空间。</span><br><span class=\"line\"></span><br><span class=\"line\">现在计算机系统通用的字符编码工作方式：在内存中通过Unicode编码，当需要存储到硬盘或者传输的时候就转为UTF-8编码。</span><br><span class=\"line\"></span><br><span class=\"line\">Python3中，字符串采用的是**Unicode编码**。</span><br><span class=\"line\">```ord()``` 取字符对应的编码。 ```chr()``` 取编码对应的字符。</span><br><span class=\"line\">字符串还可以用十六进制表示：</span><br><span class=\"line\">```&#x27;\\u6587&#x27;``` 即表示&#x27;文&#x27;</span><br><span class=\"line\">```bytes``` 类型:字符串在传输或者硬盘存储时用字节。</span><br><span class=\"line\">encode(&#x27;ascii&#x27;) 函数可以将字符串转换为对应的bytes。decode(&#x27;ascii&#x27;)函数可以将网络或者硬盘上读到的bytes转换为对应的字符串</span><br><span class=\"line\">decode加上参数```errors=&#x27;ignore&#x27;```就可以忽略字节流中无法识别的字节。</span><br><span class=\"line\">len()函数统计str中包含多少个**字符**，bytes中包含多少个**字节**</span><br><span class=\"line\"></span><br><span class=\"line\">格式化：</span><br><span class=\"line\"></span><br><span class=\"line\">%：</span><br><span class=\"line\">```python</span><br><span class=\"line\">&gt;&gt;&gt;print(&#x27;Hello%s %s %%&#x27; % (&#x27;,&#x27;, &#x27;World&#x27;))</span><br><span class=\"line\">Hello, World%</span><br></pre></td></tr></table></figure>\n\n<p>format():</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Hello,&#123;0&#125;&#123;1:.1f&#125;&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&#x27;World&#x27;</span>, <span class=\"number\">3.14</span>))</span><br><span class=\"line\">Hello,World3<span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>在记事本<strong>编辑</strong>时，是<strong>Unicode</strong>编码。文件保存到磁盘时，是<strong>UTF-8编码</strong>。</li>\n<li>字符串用utf-8编码转为字节流会这样表示：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">&#x27;中文&#x27;</span>.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\"><span class=\"string\">b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在python源码中经常能看到：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># !/usr/bin/env python3</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>\n其中，第一句告诉Linux/OS X系统这是一个python可执行程序，Windows系统会自动忽略；第二句是说明要用UTF-8读取源代码</li>\n</ul>\n<h2 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下~\"></a>小结一下~</h2><p>今天主要有点复杂的部分就是编码了。另外就是Python的一些特性：解释性，动态性</p>\n<p>关于字符与编码：</p>\n<ol>\n<li>Unicode，ASCII，UTF-8</li>\n<li>bytes类型</li>\n<li>encode()和decode()</li>\n<li>格式化方法</li>\n</ol>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<hr>\n<p>只会些毛，现在学些皮，目标是会些皮毛。</p>","more":"<hr>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><blockquote>\n</blockquote>\n<ol>\n<li>Make English as your working language.</li>\n<li>Practice makes perfect.</li>\n<li>All experience comes from mistakes.</li>\n<li>Don’t be one of the leeches.<br>Either stand out or kicked out.<br>(from <a href=\"https://github.com/jackfrued/Python-100-Days\">GitHub/Python-100-Days</a>)</li>\n</ol>\n<p>那些Python能做的事情：<br>基本任务，网站，后台<br>那些Python不能做的事情：<br>操作系统（C），手机应用（Swift/Objective-C或Java），3D游戏（C/C++）<br>一些Python特性：</p>\n<ol>\n<li>一种高级语言，代码少但运行慢。</li>\n<li>优雅，简单，明确<br>Python之父：<br>Guido van Rossum（吉多·范罗苏姆），荷兰人</li>\n</ol>\n<p>Python解释器<br>CPython，官网安装后自动下载的解释器。</p>\n<p>Python是解释型语言（解释器对程序逐行进行解释然后直接运行）（编译型语言）</p>\n<h2 id=\"输入与输出\"><a href=\"#输入与输出\" class=\"headerlink\" title=\"输入与输出\"></a>输入与输出</h2><p>输出<br>print(‘Hello’, ‘World!’)<br>输入<br>x = input(‘please input x:’)</p>\n<h2 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h2><p>Python能直接处理的数据类型有：整数，浮点数，字符串，布尔值，空值（None）等</p>\n<p>十六进制表示整数：前面加<code>0x</code><br>科学记数法：<code>1.23e9</code>，<code>2e-5</code><br>当字符串中要有<code>&#39;</code>的时候，字符串用双引号<code>&quot;&quot;</code>括起来。如果字符串中要有<code>&quot;</code>，就用转义符<code>\\</code>。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>表示 ```''``` 内的字符不转义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Python是**动态语言**，即变量本身类型不固定。</span><br><span class=\"line\">变量赋值的过程：在内存中创建变量，并令变量指向相应的数据。</span><br><span class=\"line\">常量通常使用**全部大写**的变量名表示。</span><br><span class=\"line\"></span><br><span class=\"line\">## 字符编码</span><br><span class=\"line\"></span><br><span class=\"line\">**Unicode编码**：把所有语言都统一到一个编码中去。通常是2个字节。</span><br><span class=\"line\">**ASCII编码**：美国人发明，只给大小写字母、数字和一些符号编了码。1个字节。</span><br><span class=\"line\">**UTF-8编码**：可变长编码。把Unicode字符根据数字不同且使用频率的不同编码得到1-6个字节的UTF-8编码。从而节省空间。</span><br><span class=\"line\"></span><br><span class=\"line\">现在计算机系统通用的字符编码工作方式：在内存中通过Unicode编码，当需要存储到硬盘或者传输的时候就转为UTF-8编码。</span><br><span class=\"line\"></span><br><span class=\"line\">Python3中，字符串采用的是**Unicode编码**。</span><br><span class=\"line\">```ord()``` 取字符对应的编码。 ```chr()``` 取编码对应的字符。</span><br><span class=\"line\">字符串还可以用十六进制表示：</span><br><span class=\"line\">```&#x27;\\u6587&#x27;``` 即表示&#x27;文&#x27;</span><br><span class=\"line\">```bytes``` 类型:字符串在传输或者硬盘存储时用字节。</span><br><span class=\"line\">encode(&#x27;ascii&#x27;) 函数可以将字符串转换为对应的bytes。decode(&#x27;ascii&#x27;)函数可以将网络或者硬盘上读到的bytes转换为对应的字符串</span><br><span class=\"line\">decode加上参数```errors=&#x27;ignore&#x27;```就可以忽略字节流中无法识别的字节。</span><br><span class=\"line\">len()函数统计str中包含多少个**字符**，bytes中包含多少个**字节**</span><br><span class=\"line\"></span><br><span class=\"line\">格式化：</span><br><span class=\"line\"></span><br><span class=\"line\">%：</span><br><span class=\"line\">```python</span><br><span class=\"line\">&gt;&gt;&gt;print(&#x27;Hello%s %s %%&#x27; % (&#x27;,&#x27;, &#x27;World&#x27;))</span><br><span class=\"line\">Hello, World%</span><br></pre></td></tr></table></figure>\n\n<p>format():</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Hello,&#123;0&#125;&#123;1:.1f&#125;&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&#x27;World&#x27;</span>, <span class=\"number\">3.14</span>))</span><br><span class=\"line\">Hello,World3<span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>在记事本<strong>编辑</strong>时，是<strong>Unicode</strong>编码。文件保存到磁盘时，是<strong>UTF-8编码</strong>。</li>\n<li>字符串用utf-8编码转为字节流会这样表示：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">&#x27;中文&#x27;</span>.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\"><span class=\"string\">b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在python源码中经常能看到：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># !/usr/bin/env python3</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>\n其中，第一句告诉Linux/OS X系统这是一个python可执行程序，Windows系统会自动忽略；第二句是说明要用UTF-8读取源代码</li>\n</ul>\n<h2 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下~\"></a>小结一下~</h2><p>今天主要有点复杂的部分就是编码了。另外就是Python的一些特性：解释性，动态性</p>\n<p>关于字符与编码：</p>\n<ol>\n<li>Unicode，ASCII，UTF-8</li>\n<li>bytes类型</li>\n<li>encode()和decode()</li>\n<li>格式化方法</li>\n</ol>"},{"title":"Python学习-Day3","date":"2020-02-08T13:09:05.000Z","_content":"\n函数与高级特性\n\n<!--more-->\n\n---\n\n## 函数\n\n函数是最基本的一种代码抽象的方法。\n\n### 一些内置函数\n\nabs(): 绝对值\nmax(): 最大值\nmin(): 最小值\nint(),float()等: 数据类型转换\nhex() : 将整数转为对应十六进制的字符串\n\n### 定义函数\n\n一个例子：\n```python\ndef my_abs(x):\n    if x > 0:\n        return x\n    else:\n        return -x\n```\n在别的代码文件中引用函数：\nfrom file\\_name import function\\_name\n\n**pass**: 作为占位符。还不知道怎么写，为了让代码运行起来，pass！\n\n多个返回值时，返回的是一个**tuple**\n\n\n### 函数的参数\n\n**参数检查**：在函数定义中增加检查参数的环节，合理地提示错误。比如数据类型检查：\n```python\nif not isinstance(x, (int, float)):\n    raise TypeError('bad operand type')\n```\n\n**位置参数**：按顺序传入的参数。如```my_func(x, y)```中的x，y是位置参数\n\n**默认参数**：在定义的时候给个默认值。注意：1. 定义时，必要参数在前，默认参数在后。2. **默认参数必须指向不变对象（str,None等）**\n\n> 对于第二点的解释：**函数定义时，默认参数被创建即它的值被计算出来了，指向某一个对象。**如果默认参数指向可变对象（如list），在调用函数时如果改变默认参数，那么可变对象的内容就发生改变，在下一次调用的时候不再是最开始定义的那个值。\n（也就是说，默认参数的值在函数定义时就创建了。）\n\n**可变参数**：在调用时，可输入任意个参数，在调用的时候会自动组装为一个tuple。用法如下：\n```python\ndef my_func(*nums):\n    s = 0\n    for i in nums:\n        s += i\n    return s\n\n>>> n = [1,2,3]\n>>> my_func(*n)\n6\n```\n\n**关键字参数**：在调用时，可输入任意个包含参数名的参数。用法如下：\n```python\ndef my_func(name, **kw):\n    print(name, kw)\n\n>>> my_func('Amy', age=10, country='China')\nAmy {'age': 10, 'country': 'China'}\n\n>>> d = {'age':10, 'country':'China'}\n>>> my_func('Amy', **d)\nAmy {'age': 10, 'country': 'China'}\n```\n\n**命名关键字参数**：调用时必须带上参数名传参，用法(定义时用*隔开)：\n```python\ndef my_func(name, *, age, city):\n    print(name, age, city)\n    \n>>> my_func('Amy', age=10, city='Shanghai')\n```\n\n* 以上参数的**组合顺序**必须是：必选参数，默认参数，可变参数，命名关键字参数，关键字参数。\n* 对于任意函数，都可以通过类似```func(*args, **kw)```的形式调用它\n\n### 函数递归\n\n为了避免递归产生的溢出，使用**尾递归**（即在函数返回的时候，调用函数本身）。\n\n## 高级特性\n\n### 切片\n\n对于list,tuple,string等，可以通过切片来获得部分数据。如下：\n```python\n>>>l = [1,2,3,4,5,6]\n>>>l[:3]\n[1, 2 , 3]\n>>>l[1:3]\n[2, 3]\n>>>l[2:-1]\n[3, 4, 5]\n>>>l[2:]\n[3, 4, 5, 6]\n>>>l[1:4:2]\n[2, 4]\n```\n\n### 迭代\n\n什么是**迭代**？\n如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。\n\n什么是**可迭代对象**？\n通过collections模块的Iterable类型判断：\n```python\n>>> from collections import Iterable\n>>> isinstance('abc', Iterable) # str是否可迭代\nTrue\n```\n\n**enumerate()函数**：将list变成“索引-元素”对：\n```python\nfor i, value in enumerate(['A', 'B', 'C']):\n     print(i, value)\n```\n\n### 列表生成式\n\n用法：\n```python\nIn [1]: [x * x for x in range(10)]\nOut[1]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nIn [2]: [x * x for x in range(10) if x % 2 == 0]\nOut[2]: [0, 4, 16, 36, 64]\nIn [3]: d = {'a':1,'b':2,'c':3}\n[k+str(v) for k, v in d.items()]\nOut[3]: ['a1', 'b2', 'c3']\n```\n\n### 生成器\n\n**什么是生成器（generator）？**\n当某一个列表的元素可以按照某个算法推算出来，那么就不必创建完整的list，而在要用到的时候再推算出来。在python中，这种一边循环一边计算的机制，称为生成器（generator）。\n\n**如何创建生成器？**\n**方法一（当算法比较简单时）：**\n将列表生成器替换为生成器（把```[]```改为```()```）：\n```python\ng = (x * x for x in range(6))\nfor i in g:\n    print(i)\n\ng2 = (x + x for x in range(6))\nprint(next(g2))\n```\n注意：next()函数计算出下一个数并返回，当取完了再调用next()会报错：```StopIteration```。\n\n**方法二（难以用类似列表生成式的循环实现）**：\n将函数写成生成器。在函数体中，加关键字**field**。如下：\n```python\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\n\nf = fib(6)\nnext(f)\n```\nPS: 每次调用next(f)时，函数执行到yield语句返回。下一次调用就从上次field语句的下一句继续执行，直到field。如果没有field语句了，就报```StopIteration```的错误。\n\n### 迭代器\n\n迭代器（Iterator）区别于可迭代对象（Iterable）：后者只要能用于for循环就是，前者可以用next()并产生对应的值。\n\n```list```，```dict```，```str```都是```Iterable```对象，但不是```Iterator```对象。\n而```generator```是```Iterator```对象，当然也是```Iterable```对象。\n\n## 小结\n\n1. 参数的类型和顺序\n2. 可迭代对象与迭代器\n3. 列表生成器\n4. 生成器是什么？怎么写？","source":"_posts/Python学习-Day3.md","raw":"---\ntitle: Python学习-Day3\ndate: 2020-02-08 21:09:05\ncategories: 学习Learning\n---\n\n函数与高级特性\n\n<!--more-->\n\n---\n\n## 函数\n\n函数是最基本的一种代码抽象的方法。\n\n### 一些内置函数\n\nabs(): 绝对值\nmax(): 最大值\nmin(): 最小值\nint(),float()等: 数据类型转换\nhex() : 将整数转为对应十六进制的字符串\n\n### 定义函数\n\n一个例子：\n```python\ndef my_abs(x):\n    if x > 0:\n        return x\n    else:\n        return -x\n```\n在别的代码文件中引用函数：\nfrom file\\_name import function\\_name\n\n**pass**: 作为占位符。还不知道怎么写，为了让代码运行起来，pass！\n\n多个返回值时，返回的是一个**tuple**\n\n\n### 函数的参数\n\n**参数检查**：在函数定义中增加检查参数的环节，合理地提示错误。比如数据类型检查：\n```python\nif not isinstance(x, (int, float)):\n    raise TypeError('bad operand type')\n```\n\n**位置参数**：按顺序传入的参数。如```my_func(x, y)```中的x，y是位置参数\n\n**默认参数**：在定义的时候给个默认值。注意：1. 定义时，必要参数在前，默认参数在后。2. **默认参数必须指向不变对象（str,None等）**\n\n> 对于第二点的解释：**函数定义时，默认参数被创建即它的值被计算出来了，指向某一个对象。**如果默认参数指向可变对象（如list），在调用函数时如果改变默认参数，那么可变对象的内容就发生改变，在下一次调用的时候不再是最开始定义的那个值。\n（也就是说，默认参数的值在函数定义时就创建了。）\n\n**可变参数**：在调用时，可输入任意个参数，在调用的时候会自动组装为一个tuple。用法如下：\n```python\ndef my_func(*nums):\n    s = 0\n    for i in nums:\n        s += i\n    return s\n\n>>> n = [1,2,3]\n>>> my_func(*n)\n6\n```\n\n**关键字参数**：在调用时，可输入任意个包含参数名的参数。用法如下：\n```python\ndef my_func(name, **kw):\n    print(name, kw)\n\n>>> my_func('Amy', age=10, country='China')\nAmy {'age': 10, 'country': 'China'}\n\n>>> d = {'age':10, 'country':'China'}\n>>> my_func('Amy', **d)\nAmy {'age': 10, 'country': 'China'}\n```\n\n**命名关键字参数**：调用时必须带上参数名传参，用法(定义时用*隔开)：\n```python\ndef my_func(name, *, age, city):\n    print(name, age, city)\n    \n>>> my_func('Amy', age=10, city='Shanghai')\n```\n\n* 以上参数的**组合顺序**必须是：必选参数，默认参数，可变参数，命名关键字参数，关键字参数。\n* 对于任意函数，都可以通过类似```func(*args, **kw)```的形式调用它\n\n### 函数递归\n\n为了避免递归产生的溢出，使用**尾递归**（即在函数返回的时候，调用函数本身）。\n\n## 高级特性\n\n### 切片\n\n对于list,tuple,string等，可以通过切片来获得部分数据。如下：\n```python\n>>>l = [1,2,3,4,5,6]\n>>>l[:3]\n[1, 2 , 3]\n>>>l[1:3]\n[2, 3]\n>>>l[2:-1]\n[3, 4, 5]\n>>>l[2:]\n[3, 4, 5, 6]\n>>>l[1:4:2]\n[2, 4]\n```\n\n### 迭代\n\n什么是**迭代**？\n如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。\n\n什么是**可迭代对象**？\n通过collections模块的Iterable类型判断：\n```python\n>>> from collections import Iterable\n>>> isinstance('abc', Iterable) # str是否可迭代\nTrue\n```\n\n**enumerate()函数**：将list变成“索引-元素”对：\n```python\nfor i, value in enumerate(['A', 'B', 'C']):\n     print(i, value)\n```\n\n### 列表生成式\n\n用法：\n```python\nIn [1]: [x * x for x in range(10)]\nOut[1]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nIn [2]: [x * x for x in range(10) if x % 2 == 0]\nOut[2]: [0, 4, 16, 36, 64]\nIn [3]: d = {'a':1,'b':2,'c':3}\n[k+str(v) for k, v in d.items()]\nOut[3]: ['a1', 'b2', 'c3']\n```\n\n### 生成器\n\n**什么是生成器（generator）？**\n当某一个列表的元素可以按照某个算法推算出来，那么就不必创建完整的list，而在要用到的时候再推算出来。在python中，这种一边循环一边计算的机制，称为生成器（generator）。\n\n**如何创建生成器？**\n**方法一（当算法比较简单时）：**\n将列表生成器替换为生成器（把```[]```改为```()```）：\n```python\ng = (x * x for x in range(6))\nfor i in g:\n    print(i)\n\ng2 = (x + x for x in range(6))\nprint(next(g2))\n```\n注意：next()函数计算出下一个数并返回，当取完了再调用next()会报错：```StopIteration```。\n\n**方法二（难以用类似列表生成式的循环实现）**：\n将函数写成生成器。在函数体中，加关键字**field**。如下：\n```python\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\n\nf = fib(6)\nnext(f)\n```\nPS: 每次调用next(f)时，函数执行到yield语句返回。下一次调用就从上次field语句的下一句继续执行，直到field。如果没有field语句了，就报```StopIteration```的错误。\n\n### 迭代器\n\n迭代器（Iterator）区别于可迭代对象（Iterable）：后者只要能用于for循环就是，前者可以用next()并产生对应的值。\n\n```list```，```dict```，```str```都是```Iterable```对象，但不是```Iterator```对象。\n而```generator```是```Iterator```对象，当然也是```Iterable```对象。\n\n## 小结\n\n1. 参数的类型和顺序\n2. 可迭代对象与迭代器\n3. 列表生成器\n4. 生成器是什么？怎么写？","slug":"Python学习-Day3","published":1,"updated":"2020-02-08T13:09:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggx001i38t4esl674mw","content":"<p>函数与高级特性</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数是最基本的一种代码抽象的方法。</p>\n<h3 id=\"一些内置函数\"><a href=\"#一些内置函数\" class=\"headerlink\" title=\"一些内置函数\"></a>一些内置函数</h3><p>abs(): 绝对值<br>max(): 最大值<br>min(): 最小值<br>int(),float()等: 数据类型转换<br>hex() : 将整数转为对应十六进制的字符串</p>\n<h3 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h3><p>一个例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_abs</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -x</span><br></pre></td></tr></table></figure>\n<p>在别的代码文件中引用函数：<br>from file_name import function_name</p>\n<p><strong>pass</strong>: 作为占位符。还不知道怎么写，为了让代码运行起来，pass！</p>\n<p>多个返回值时，返回的是一个<strong>tuple</strong></p>\n<h3 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h3><p><strong>参数检查</strong>：在函数定义中增加检查参数的环节，合理地提示错误。比如数据类型检查：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(x, (<span class=\"built_in\">int</span>, <span class=\"built_in\">float</span>)):</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">&#x27;bad operand type&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>位置参数</strong>：按顺序传入的参数。如<code>my_func(x, y)</code>中的x，y是位置参数</p>\n<p><strong>默认参数</strong>：在定义的时候给个默认值。注意：1. 定义时，必要参数在前，默认参数在后。2. <strong>默认参数必须指向不变对象（str,None等）</strong></p>\n<blockquote>\n<p>对于第二点的解释：<strong>函数定义时，默认参数被创建即它的值被计算出来了，指向某一个对象。</strong>如果默认参数指向可变对象（如list），在调用函数时如果改变默认参数，那么可变对象的内容就发生改变，在下一次调用的时候不再是最开始定义的那个值。<br>（也就是说，默认参数的值在函数定义时就创建了。）</p>\n</blockquote>\n<p><strong>可变参数</strong>：在调用时，可输入任意个参数，在调用的时候会自动组装为一个tuple。用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_func</span>(<span class=\"params\">*nums</span>):</span></span><br><span class=\"line\">    s = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        s += i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>n = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_func(*n)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>关键字参数</strong>：在调用时，可输入任意个包含参数名的参数。用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_func</span>(<span class=\"params\">name, **kw</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(name, kw)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_func(<span class=\"string\">&#x27;Amy&#x27;</span>, age=<span class=\"number\">10</span>, country=<span class=\"string\">&#x27;China&#x27;</span>)</span><br><span class=\"line\">Amy &#123;<span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">10</span>, <span class=\"string\">&#x27;country&#x27;</span>: <span class=\"string\">&#x27;China&#x27;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = &#123;<span class=\"string\">&#x27;age&#x27;</span>:<span class=\"number\">10</span>, <span class=\"string\">&#x27;country&#x27;</span>:<span class=\"string\">&#x27;China&#x27;</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_func(<span class=\"string\">&#x27;Amy&#x27;</span>, **d)</span><br><span class=\"line\">Amy &#123;<span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">10</span>, <span class=\"string\">&#x27;country&#x27;</span>: <span class=\"string\">&#x27;China&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>命名关键字参数</strong>：调用时必须带上参数名传参，用法(定义时用*隔开)：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_func</span>(<span class=\"params\">name, *, age, city</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(name, age, city)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_func(<span class=\"string\">&#x27;Amy&#x27;</span>, age=<span class=\"number\">10</span>, city=<span class=\"string\">&#x27;Shanghai&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以上参数的<strong>组合顺序</strong>必须是：必选参数，默认参数，可变参数，命名关键字参数，关键字参数。</li>\n<li>对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它</li>\n</ul>\n<h3 id=\"函数递归\"><a href=\"#函数递归\" class=\"headerlink\" title=\"函数递归\"></a>函数递归</h3><p>为了避免递归产生的溢出，使用<strong>尾递归</strong>（即在函数返回的时候，调用函数本身）。</p>\n<h2 id=\"高级特性\"><a href=\"#高级特性\" class=\"headerlink\" title=\"高级特性\"></a>高级特性</h2><h3 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h3><p>对于list,tuple,string等，可以通过切片来获得部分数据。如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;l = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\">&gt;&gt;&gt;l[:<span class=\"number\">3</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span> , <span class=\"number\">3</span>]</span><br><span class=\"line\">&gt;&gt;&gt;l[<span class=\"number\">1</span>:<span class=\"number\">3</span>]</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">&gt;&gt;&gt;l[<span class=\"number\">2</span>:-<span class=\"number\">1</span>]</span><br><span class=\"line\">[<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">&gt;&gt;&gt;l[<span class=\"number\">2</span>:]</span><br><span class=\"line\">[<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\">&gt;&gt;&gt;l[<span class=\"number\">1</span>:<span class=\"number\">4</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>什么是<strong>迭代</strong>？<br>如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p>\n<p>什么是<strong>可迭代对象</strong>？<br>通过collections模块的Iterable类型判断：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterable</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">isinstance</span>(<span class=\"string\">&#x27;abc&#x27;</span>, Iterable) <span class=\"comment\"># str是否可迭代</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>enumerate()函数</strong>：将list变成“索引-元素”对：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, value <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>([<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>]):</span><br><span class=\"line\">     <span class=\"built_in\">print</span>(i, value)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"列表生成式\"><a href=\"#列表生成式\" class=\"headerlink\" title=\"列表生成式\"></a>列表生成式</h3><p>用法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">1</span>]: [x * x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>)]</span><br><span class=\"line\">Out[<span class=\"number\">1</span>]: [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>, <span class=\"number\">49</span>, <span class=\"number\">64</span>, <span class=\"number\">81</span>]</span><br><span class=\"line\">In [<span class=\"number\">2</span>]: [x * x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>) <span class=\"keyword\">if</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>]</span><br><span class=\"line\">Out[<span class=\"number\">2</span>]: [<span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">16</span>, <span class=\"number\">36</span>, <span class=\"number\">64</span>]</span><br><span class=\"line\">In [<span class=\"number\">3</span>]: d = &#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">1</span>,<span class=\"string\">&#x27;b&#x27;</span>:<span class=\"number\">2</span>,<span class=\"string\">&#x27;c&#x27;</span>:<span class=\"number\">3</span>&#125;</span><br><span class=\"line\">[k+<span class=\"built_in\">str</span>(v) <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> d.items()]</span><br><span class=\"line\">Out[<span class=\"number\">3</span>]: [<span class=\"string\">&#x27;a1&#x27;</span>, <span class=\"string\">&#x27;b2&#x27;</span>, <span class=\"string\">&#x27;c3&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p><strong>什么是生成器（generator）？</strong><br>当某一个列表的元素可以按照某个算法推算出来，那么就不必创建完整的list，而在要用到的时候再推算出来。在python中，这种一边循环一边计算的机制，称为生成器（generator）。</p>\n<p><strong>如何创建生成器？</strong><br><strong>方法一（当算法比较简单时）：</strong><br>将列表生成器替换为生成器（把<code>[]</code>改为<code>()</code>）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g = (x * x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> g:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\"></span><br><span class=\"line\">g2 = (x + x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">next</span>(g2))</span><br></pre></td></tr></table></figure>\n<p>注意：next()函数计算出下一个数并返回，当取完了再调用next()会报错：<code>StopIteration</code>。</p>\n<p><strong>方法二（难以用类似列表生成式的循环实现）</strong>：<br>将函数写成生成器。在函数体中，加关键字<strong>field</strong>。如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span>(<span class=\"params\"><span class=\"built_in\">max</span></span>):</span></span><br><span class=\"line\">    n, a, b = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt; <span class=\"built_in\">max</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> b</span><br><span class=\"line\">        a, b = b, a + b</span><br><span class=\"line\">        n = n + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;done&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">f = fib(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"built_in\">next</span>(f)</span><br></pre></td></tr></table></figure>\n<p>PS: 每次调用next(f)时，函数执行到yield语句返回。下一次调用就从上次field语句的下一句继续执行，直到field。如果没有field语句了，就报<code>StopIteration</code>的错误。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>迭代器（Iterator）区别于可迭代对象（Iterable）：后者只要能用于for循环就是，前者可以用next()并产生对应的值。</p>\n<p><code>list</code>，<code>dict</code>，<code>str</code>都是<code>Iterable</code>对象，但不是<code>Iterator</code>对象。<br>而<code>generator</code>是<code>Iterator</code>对象，当然也是<code>Iterable</code>对象。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li>参数的类型和顺序</li>\n<li>可迭代对象与迭代器</li>\n<li>列表生成器</li>\n<li>生成器是什么？怎么写？</li>\n</ol>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>函数与高级特性</p>","more":"<hr>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数是最基本的一种代码抽象的方法。</p>\n<h3 id=\"一些内置函数\"><a href=\"#一些内置函数\" class=\"headerlink\" title=\"一些内置函数\"></a>一些内置函数</h3><p>abs(): 绝对值<br>max(): 最大值<br>min(): 最小值<br>int(),float()等: 数据类型转换<br>hex() : 将整数转为对应十六进制的字符串</p>\n<h3 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h3><p>一个例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_abs</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -x</span><br></pre></td></tr></table></figure>\n<p>在别的代码文件中引用函数：<br>from file_name import function_name</p>\n<p><strong>pass</strong>: 作为占位符。还不知道怎么写，为了让代码运行起来，pass！</p>\n<p>多个返回值时，返回的是一个<strong>tuple</strong></p>\n<h3 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h3><p><strong>参数检查</strong>：在函数定义中增加检查参数的环节，合理地提示错误。比如数据类型检查：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(x, (<span class=\"built_in\">int</span>, <span class=\"built_in\">float</span>)):</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">&#x27;bad operand type&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>位置参数</strong>：按顺序传入的参数。如<code>my_func(x, y)</code>中的x，y是位置参数</p>\n<p><strong>默认参数</strong>：在定义的时候给个默认值。注意：1. 定义时，必要参数在前，默认参数在后。2. <strong>默认参数必须指向不变对象（str,None等）</strong></p>\n<blockquote>\n<p>对于第二点的解释：<strong>函数定义时，默认参数被创建即它的值被计算出来了，指向某一个对象。</strong>如果默认参数指向可变对象（如list），在调用函数时如果改变默认参数，那么可变对象的内容就发生改变，在下一次调用的时候不再是最开始定义的那个值。<br>（也就是说，默认参数的值在函数定义时就创建了。）</p>\n</blockquote>\n<p><strong>可变参数</strong>：在调用时，可输入任意个参数，在调用的时候会自动组装为一个tuple。用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_func</span>(<span class=\"params\">*nums</span>):</span></span><br><span class=\"line\">    s = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        s += i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>n = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_func(*n)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>关键字参数</strong>：在调用时，可输入任意个包含参数名的参数。用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_func</span>(<span class=\"params\">name, **kw</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(name, kw)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_func(<span class=\"string\">&#x27;Amy&#x27;</span>, age=<span class=\"number\">10</span>, country=<span class=\"string\">&#x27;China&#x27;</span>)</span><br><span class=\"line\">Amy &#123;<span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">10</span>, <span class=\"string\">&#x27;country&#x27;</span>: <span class=\"string\">&#x27;China&#x27;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = &#123;<span class=\"string\">&#x27;age&#x27;</span>:<span class=\"number\">10</span>, <span class=\"string\">&#x27;country&#x27;</span>:<span class=\"string\">&#x27;China&#x27;</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_func(<span class=\"string\">&#x27;Amy&#x27;</span>, **d)</span><br><span class=\"line\">Amy &#123;<span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">10</span>, <span class=\"string\">&#x27;country&#x27;</span>: <span class=\"string\">&#x27;China&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>命名关键字参数</strong>：调用时必须带上参数名传参，用法(定义时用*隔开)：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_func</span>(<span class=\"params\">name, *, age, city</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(name, age, city)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_func(<span class=\"string\">&#x27;Amy&#x27;</span>, age=<span class=\"number\">10</span>, city=<span class=\"string\">&#x27;Shanghai&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以上参数的<strong>组合顺序</strong>必须是：必选参数，默认参数，可变参数，命名关键字参数，关键字参数。</li>\n<li>对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它</li>\n</ul>\n<h3 id=\"函数递归\"><a href=\"#函数递归\" class=\"headerlink\" title=\"函数递归\"></a>函数递归</h3><p>为了避免递归产生的溢出，使用<strong>尾递归</strong>（即在函数返回的时候，调用函数本身）。</p>\n<h2 id=\"高级特性\"><a href=\"#高级特性\" class=\"headerlink\" title=\"高级特性\"></a>高级特性</h2><h3 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h3><p>对于list,tuple,string等，可以通过切片来获得部分数据。如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;l = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\">&gt;&gt;&gt;l[:<span class=\"number\">3</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span> , <span class=\"number\">3</span>]</span><br><span class=\"line\">&gt;&gt;&gt;l[<span class=\"number\">1</span>:<span class=\"number\">3</span>]</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">&gt;&gt;&gt;l[<span class=\"number\">2</span>:-<span class=\"number\">1</span>]</span><br><span class=\"line\">[<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">&gt;&gt;&gt;l[<span class=\"number\">2</span>:]</span><br><span class=\"line\">[<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\">&gt;&gt;&gt;l[<span class=\"number\">1</span>:<span class=\"number\">4</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>什么是<strong>迭代</strong>？<br>如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p>\n<p>什么是<strong>可迭代对象</strong>？<br>通过collections模块的Iterable类型判断：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterable</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">isinstance</span>(<span class=\"string\">&#x27;abc&#x27;</span>, Iterable) <span class=\"comment\"># str是否可迭代</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>enumerate()函数</strong>：将list变成“索引-元素”对：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, value <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>([<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>]):</span><br><span class=\"line\">     <span class=\"built_in\">print</span>(i, value)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"列表生成式\"><a href=\"#列表生成式\" class=\"headerlink\" title=\"列表生成式\"></a>列表生成式</h3><p>用法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">1</span>]: [x * x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>)]</span><br><span class=\"line\">Out[<span class=\"number\">1</span>]: [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>, <span class=\"number\">49</span>, <span class=\"number\">64</span>, <span class=\"number\">81</span>]</span><br><span class=\"line\">In [<span class=\"number\">2</span>]: [x * x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>) <span class=\"keyword\">if</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>]</span><br><span class=\"line\">Out[<span class=\"number\">2</span>]: [<span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">16</span>, <span class=\"number\">36</span>, <span class=\"number\">64</span>]</span><br><span class=\"line\">In [<span class=\"number\">3</span>]: d = &#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">1</span>,<span class=\"string\">&#x27;b&#x27;</span>:<span class=\"number\">2</span>,<span class=\"string\">&#x27;c&#x27;</span>:<span class=\"number\">3</span>&#125;</span><br><span class=\"line\">[k+<span class=\"built_in\">str</span>(v) <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> d.items()]</span><br><span class=\"line\">Out[<span class=\"number\">3</span>]: [<span class=\"string\">&#x27;a1&#x27;</span>, <span class=\"string\">&#x27;b2&#x27;</span>, <span class=\"string\">&#x27;c3&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p><strong>什么是生成器（generator）？</strong><br>当某一个列表的元素可以按照某个算法推算出来，那么就不必创建完整的list，而在要用到的时候再推算出来。在python中，这种一边循环一边计算的机制，称为生成器（generator）。</p>\n<p><strong>如何创建生成器？</strong><br><strong>方法一（当算法比较简单时）：</strong><br>将列表生成器替换为生成器（把<code>[]</code>改为<code>()</code>）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g = (x * x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> g:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\"></span><br><span class=\"line\">g2 = (x + x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">next</span>(g2))</span><br></pre></td></tr></table></figure>\n<p>注意：next()函数计算出下一个数并返回，当取完了再调用next()会报错：<code>StopIteration</code>。</p>\n<p><strong>方法二（难以用类似列表生成式的循环实现）</strong>：<br>将函数写成生成器。在函数体中，加关键字<strong>field</strong>。如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span>(<span class=\"params\"><span class=\"built_in\">max</span></span>):</span></span><br><span class=\"line\">    n, a, b = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt; <span class=\"built_in\">max</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> b</span><br><span class=\"line\">        a, b = b, a + b</span><br><span class=\"line\">        n = n + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;done&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">f = fib(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"built_in\">next</span>(f)</span><br></pre></td></tr></table></figure>\n<p>PS: 每次调用next(f)时，函数执行到yield语句返回。下一次调用就从上次field语句的下一句继续执行，直到field。如果没有field语句了，就报<code>StopIteration</code>的错误。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>迭代器（Iterator）区别于可迭代对象（Iterable）：后者只要能用于for循环就是，前者可以用next()并产生对应的值。</p>\n<p><code>list</code>，<code>dict</code>，<code>str</code>都是<code>Iterable</code>对象，但不是<code>Iterator</code>对象。<br>而<code>generator</code>是<code>Iterator</code>对象，当然也是<code>Iterable</code>对象。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li>参数的类型和顺序</li>\n<li>可迭代对象与迭代器</li>\n<li>列表生成器</li>\n<li>生成器是什么？怎么写？</li>\n</ol>"},{"title":"Python学习-Day2","date":"2020-02-07T03:36:11.000Z","_content":"\n列表、字典等。条件判断和循环基础内容跟其他语言很相似\n\n<!--more-->\n\n---\n\n## list与tuple\n\nlist是可变的有序集合，list中的元素类型可以不一样。常见用法有：\n```python\nl = [1,2,'a']\ni = 2\nl[-1] # 获取末尾元素\nl[-2] # 获取倒数第二个元素\nl.pop(i) # 删除指定索引处的元素\nl.pop() # 删除末尾元素\nl.insert(i, 'b') # 替换指定索引处的元素\nl.append('c') # 追加元素到列表末尾\n```\n\ntuple是不可变的有序列表，在定义的时候就确定了它长什么样。\ntuple要注意这几点：\n1.tuple不可变，指的是它的每一个元素指向永远不变。如果tuple中有一个元素是列表，列表本身又是可变的\n```python\na = (1,2,[1,2,3])\na[2][2]=1\nprint(a)\na[2].append(2)\nprint(a)\n\n结果：\n(1, 2, [1, 2, 1])\n(1, 2, [1, 2, 1, 2])\n```\n\n2.要创建只有一个元素的tuple：\n```a = (1,)```区别于```a=(1)```,为了消除小括号的歧义。\n\n## 条件判断\n\n用法：\n```python\nif xxx:\n    ...\nelif xxx:\n    ...\nelse:\n    ...\n```\nif后面的条件可以简写为x，当x为非零数值/非空字符串/非空list等情况时为True。\n\n## 循环\n\nfor和while\nrange(i):生成0~i-1的整数序列\n善用和慎用continue和break\n\n## dict与set\n\ndict是Python内置的字典类型，使用key-value存储。dict的查找插入速度都很快，是用空间换时间的方法。\ndict查找的实现原理：给定key，可以直接计算出对应value的内存地址。\n通过key计算位置的算法称为**哈希算法**。\ndict的常用函数：\n```python\nd = {'a':1, 'b':2, 'c':3}\nk = 'a'\nd.get(k) # keys中有k就返回对应value，反之返回None\nd.get(k, -1) # 没有k会返回-1\nd.pop(k) # 删除k对应的键值对\n```\n\nset可以看作数学意义上的集合（**无序无重复**），set也可以看作是dict的key集合。\nset的常用函数：\n```python\ns = set(['a','b','c'])\nk = 'a'\ns.remove(k)\ns.add('d')\n```\n\n对于不变对象（如字符串），调用对象自身的任意方法是不会改变对象自身的内容。\n\n## 小结\n\n1. dict的原理与特点\n2. set的特点\n3. list的插入、删除\n4. tuple的特点","source":"_posts/Python学习-Day2.md","raw":"---\ntitle: Python学习-Day2\ndate: 2020-02-07 11:36:11\ncategories: 学习Learning\n---\n\n列表、字典等。条件判断和循环基础内容跟其他语言很相似\n\n<!--more-->\n\n---\n\n## list与tuple\n\nlist是可变的有序集合，list中的元素类型可以不一样。常见用法有：\n```python\nl = [1,2,'a']\ni = 2\nl[-1] # 获取末尾元素\nl[-2] # 获取倒数第二个元素\nl.pop(i) # 删除指定索引处的元素\nl.pop() # 删除末尾元素\nl.insert(i, 'b') # 替换指定索引处的元素\nl.append('c') # 追加元素到列表末尾\n```\n\ntuple是不可变的有序列表，在定义的时候就确定了它长什么样。\ntuple要注意这几点：\n1.tuple不可变，指的是它的每一个元素指向永远不变。如果tuple中有一个元素是列表，列表本身又是可变的\n```python\na = (1,2,[1,2,3])\na[2][2]=1\nprint(a)\na[2].append(2)\nprint(a)\n\n结果：\n(1, 2, [1, 2, 1])\n(1, 2, [1, 2, 1, 2])\n```\n\n2.要创建只有一个元素的tuple：\n```a = (1,)```区别于```a=(1)```,为了消除小括号的歧义。\n\n## 条件判断\n\n用法：\n```python\nif xxx:\n    ...\nelif xxx:\n    ...\nelse:\n    ...\n```\nif后面的条件可以简写为x，当x为非零数值/非空字符串/非空list等情况时为True。\n\n## 循环\n\nfor和while\nrange(i):生成0~i-1的整数序列\n善用和慎用continue和break\n\n## dict与set\n\ndict是Python内置的字典类型，使用key-value存储。dict的查找插入速度都很快，是用空间换时间的方法。\ndict查找的实现原理：给定key，可以直接计算出对应value的内存地址。\n通过key计算位置的算法称为**哈希算法**。\ndict的常用函数：\n```python\nd = {'a':1, 'b':2, 'c':3}\nk = 'a'\nd.get(k) # keys中有k就返回对应value，反之返回None\nd.get(k, -1) # 没有k会返回-1\nd.pop(k) # 删除k对应的键值对\n```\n\nset可以看作数学意义上的集合（**无序无重复**），set也可以看作是dict的key集合。\nset的常用函数：\n```python\ns = set(['a','b','c'])\nk = 'a'\ns.remove(k)\ns.add('d')\n```\n\n对于不变对象（如字符串），调用对象自身的任意方法是不会改变对象自身的内容。\n\n## 小结\n\n1. dict的原理与特点\n2. set的特点\n3. list的插入、删除\n4. tuple的特点","slug":"Python学习-Day2","published":1,"updated":"2020-02-07T03:36:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggx001l38t4fw1l86zl","content":"<p>列表、字典等。条件判断和循环基础内容跟其他语言很相似</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"list与tuple\"><a href=\"#list与tuple\" class=\"headerlink\" title=\"list与tuple\"></a>list与tuple</h2><p>list是可变的有序集合，list中的元素类型可以不一样。常见用法有：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">&#x27;a&#x27;</span>]</span><br><span class=\"line\">i = <span class=\"number\">2</span></span><br><span class=\"line\">l[-<span class=\"number\">1</span>] <span class=\"comment\"># 获取末尾元素</span></span><br><span class=\"line\">l[-<span class=\"number\">2</span>] <span class=\"comment\"># 获取倒数第二个元素</span></span><br><span class=\"line\">l.pop(i) <span class=\"comment\"># 删除指定索引处的元素</span></span><br><span class=\"line\">l.pop() <span class=\"comment\"># 删除末尾元素</span></span><br><span class=\"line\">l.insert(i, <span class=\"string\">&#x27;b&#x27;</span>) <span class=\"comment\"># 替换指定索引处的元素</span></span><br><span class=\"line\">l.append(<span class=\"string\">&#x27;c&#x27;</span>) <span class=\"comment\"># 追加元素到列表末尾</span></span><br></pre></td></tr></table></figure>\n\n<p>tuple是不可变的有序列表，在定义的时候就确定了它长什么样。<br>tuple要注意这几点：<br>1.tuple不可变，指的是它的每一个元素指向永远不变。如果tuple中有一个元素是列表，列表本身又是可变的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = (<span class=\"number\">1</span>,<span class=\"number\">2</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</span><br><span class=\"line\">a[<span class=\"number\">2</span>][<span class=\"number\">2</span>]=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">a[<span class=\"number\">2</span>].append(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>\n\n<p>2.要创建只有一个元素的tuple：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 条件判断</span><br><span class=\"line\"></span><br><span class=\"line\">用法：</span><br><span class=\"line\">```python</span><br><span class=\"line\">if xxx:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">elif xxx:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">else:</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>if后面的条件可以简写为x，当x为非零数值/非空字符串/非空list等情况时为True。</p>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>for和while<br>range(i):生成0~i-1的整数序列<br>善用和慎用continue和break</p>\n<h2 id=\"dict与set\"><a href=\"#dict与set\" class=\"headerlink\" title=\"dict与set\"></a>dict与set</h2><p>dict是Python内置的字典类型，使用key-value存储。dict的查找插入速度都很快，是用空间换时间的方法。<br>dict查找的实现原理：给定key，可以直接计算出对应value的内存地址。<br>通过key计算位置的算法称为<strong>哈希算法</strong>。<br>dict的常用函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">1</span>, <span class=\"string\">&#x27;b&#x27;</span>:<span class=\"number\">2</span>, <span class=\"string\">&#x27;c&#x27;</span>:<span class=\"number\">3</span>&#125;</span><br><span class=\"line\">k = <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">d.get(k) <span class=\"comment\"># keys中有k就返回对应value，反之返回None</span></span><br><span class=\"line\">d.get(k, -<span class=\"number\">1</span>) <span class=\"comment\"># 没有k会返回-1</span></span><br><span class=\"line\">d.pop(k) <span class=\"comment\"># 删除k对应的键值对</span></span><br></pre></td></tr></table></figure>\n\n<p>set可以看作数学意义上的集合（<strong>无序无重复</strong>），set也可以看作是dict的key集合。<br>set的常用函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"built_in\">set</span>([<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>])</span><br><span class=\"line\">k = <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">s.remove(k)</span><br><span class=\"line\">s.add(<span class=\"string\">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>对于不变对象（如字符串），调用对象自身的任意方法是不会改变对象自身的内容。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li>dict的原理与特点</li>\n<li>set的特点</li>\n<li>list的插入、删除</li>\n<li>tuple的特点</li>\n</ol>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>列表、字典等。条件判断和循环基础内容跟其他语言很相似</p>","more":"<hr>\n<h2 id=\"list与tuple\"><a href=\"#list与tuple\" class=\"headerlink\" title=\"list与tuple\"></a>list与tuple</h2><p>list是可变的有序集合，list中的元素类型可以不一样。常见用法有：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">&#x27;a&#x27;</span>]</span><br><span class=\"line\">i = <span class=\"number\">2</span></span><br><span class=\"line\">l[-<span class=\"number\">1</span>] <span class=\"comment\"># 获取末尾元素</span></span><br><span class=\"line\">l[-<span class=\"number\">2</span>] <span class=\"comment\"># 获取倒数第二个元素</span></span><br><span class=\"line\">l.pop(i) <span class=\"comment\"># 删除指定索引处的元素</span></span><br><span class=\"line\">l.pop() <span class=\"comment\"># 删除末尾元素</span></span><br><span class=\"line\">l.insert(i, <span class=\"string\">&#x27;b&#x27;</span>) <span class=\"comment\"># 替换指定索引处的元素</span></span><br><span class=\"line\">l.append(<span class=\"string\">&#x27;c&#x27;</span>) <span class=\"comment\"># 追加元素到列表末尾</span></span><br></pre></td></tr></table></figure>\n\n<p>tuple是不可变的有序列表，在定义的时候就确定了它长什么样。<br>tuple要注意这几点：<br>1.tuple不可变，指的是它的每一个元素指向永远不变。如果tuple中有一个元素是列表，列表本身又是可变的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = (<span class=\"number\">1</span>,<span class=\"number\">2</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</span><br><span class=\"line\">a[<span class=\"number\">2</span>][<span class=\"number\">2</span>]=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">a[<span class=\"number\">2</span>].append(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>\n\n<p>2.要创建只有一个元素的tuple：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 条件判断</span><br><span class=\"line\"></span><br><span class=\"line\">用法：</span><br><span class=\"line\">```python</span><br><span class=\"line\">if xxx:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">elif xxx:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">else:</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>if后面的条件可以简写为x，当x为非零数值/非空字符串/非空list等情况时为True。</p>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>for和while<br>range(i):生成0~i-1的整数序列<br>善用和慎用continue和break</p>\n<h2 id=\"dict与set\"><a href=\"#dict与set\" class=\"headerlink\" title=\"dict与set\"></a>dict与set</h2><p>dict是Python内置的字典类型，使用key-value存储。dict的查找插入速度都很快，是用空间换时间的方法。<br>dict查找的实现原理：给定key，可以直接计算出对应value的内存地址。<br>通过key计算位置的算法称为<strong>哈希算法</strong>。<br>dict的常用函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">1</span>, <span class=\"string\">&#x27;b&#x27;</span>:<span class=\"number\">2</span>, <span class=\"string\">&#x27;c&#x27;</span>:<span class=\"number\">3</span>&#125;</span><br><span class=\"line\">k = <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">d.get(k) <span class=\"comment\"># keys中有k就返回对应value，反之返回None</span></span><br><span class=\"line\">d.get(k, -<span class=\"number\">1</span>) <span class=\"comment\"># 没有k会返回-1</span></span><br><span class=\"line\">d.pop(k) <span class=\"comment\"># 删除k对应的键值对</span></span><br></pre></td></tr></table></figure>\n\n<p>set可以看作数学意义上的集合（<strong>无序无重复</strong>），set也可以看作是dict的key集合。<br>set的常用函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"built_in\">set</span>([<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>])</span><br><span class=\"line\">k = <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">s.remove(k)</span><br><span class=\"line\">s.add(<span class=\"string\">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>对于不变对象（如字符串），调用对象自身的任意方法是不会改变对象自身的内容。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li>dict的原理与特点</li>\n<li>set的特点</li>\n<li>list的插入、删除</li>\n<li>tuple的特点</li>\n</ol>"},{"title":"Python学习-Day4","date":"2020-02-12T14:08:45.000Z","_content":"\n函数式编程\n\n<!--more-->\n\n---\n\n什么是**函数式编程（Functional Programming）**？\n是一种抽象程度很高的编程范式。纯粹的函数式编程语言编写的函数没有变量，一个函数的输入就对应了一个固定的输出。\n\n## 高阶函数（Higher-order Function）\n\n函数名就是一个变量，只是它恰好指向了一个函数。\n\n* abs函数定义在builtins模块中，要修改```abs```变量的指向在其他模块中也生效，需要```builtins.abs = xxx```才可以\n\n什么是**高阶函数**？\n一个函数接收另一个函数作为参数，折中函数就称为高阶函数。\n\n### map/reduce\n\n**map函数：**\n接收两个参数，第一个是函数f，第二个```Iterable```对象i。map函数就是将f作用于i的每一个元素上，并返回一个迭代器。\n用法如下：\n\n```python\n>>> list(map(int, '123456'))\n[1, 2, 3, 4, 5, 6]\n```\n\n**reduce函数**（需要从**functools**模块中导入）：\n接收两个参数，第一个是函数f，第二个是Iterable对象i，返回iterator对象。reduce函数结果继续和序列的下一个元素做累积计算，即：\n\n```\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n```\n\n练习题解答：\n\n> 1.利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']：\n\n```python\ndef trans(ch):\n    if 'a'<= ch <= 'z':\n        return ch\n    else:\n        return chr(ord(ch)+32)\n        \ndef normalize(name):\n    s = name[0]\n    if 'a' <= name[0] <= 'z':\n        s = chr(ord(s) - 32)\n    return s + ''.join(list(map(trans, name[1:])))\n\n# 测试:\nL1 = ['adam', 'LISA', 'barT']\nL2 = list(map(normalize, L1))\nprint(L2)\n```\n\n注：不用map函数的话，字符串有一个capitalize()函数，一句到位。见下：\n\n```python\ndef normalize(name):\n    return name.capitalize()\n\n# 测试:\nL1 = ['adam', 'LISA', 'barT']\nL2 = list(map(normalize, L1))\nprint(L2)\n```\n\n> 2.请编写一个prod()函数，可以接受一个list并利用reduce()求积：\n\n```python\nfrom functools import reduce\ndef multi(a, b):\n    return a * b\n\ndef prod(L):\n    return reduce(multi, L)\n```\n\n### filter\n\n过滤序列。函数接受一个函数和一个序列。函数作用于每一个元素，若函数返回结果为True则保留元素，反之删除。\n\n教程中举例子用[埃式筛法][1]求素数，算法很简洁，值得学习。\n\n### sorted\n\n排序。接收一个**key函数**来实现自定义的排序。key函数作用于每一个元素，返回的结果再进行排序。\n另一个参数**reverse**，设置为True时，进行反向排序（从大到小）。\n\n## 返回函数\n\n函数作为返回值在函数中return。~~（套娃）~~\n\n这样的函数会在调用它的时候才执行。\n\n当函数被返回的时候，相关参数和变量都保存在这个函数中。这种程序结构被称为**闭包（closure）**。\n\n由于函数在返回的时候才保存相关的参数和变量。因此，如果保存循环变量，可能无法获得想要的效果。\n如下例：\n\n```python\nIn [1]:\ndef count():\n    fs = []\n    for i in range(3):\n        def f():\n            return i * i\n        fs.append(f)\n    return fs\nIn [2]:\nf1, f2, f3 = count()\nIn [5]:\nprint(f1(), f2(), f3())\n4 4 4\n```\n\n在编写代码中，应尽量避免返回循环变量，你非要返回就这样写。要返回的函数中再定义一个函数，把循环变量和这个函数绑定起来。\n\n```python\nIn [10]:\ndef count2():\n    fs = []\n    def f(j):\n        def g():\n            return j * j\n        return g\n    for i in range(3):\n        fs.append(f(i))\n    return fs\nIn [11]:\nf1, f2, f3 = count2()\nIn [12]:\nprint(f1(), f2(), f3())\n0 1 4\n```\n\n练习题：\n\n> 利用闭包返回一个计数器函数，每次调用它返回递增整数：\n\n```python\ndef createCounter():\n    s = [0]\n    def counter():\n        s[0] = s[0] + 1\n        return s[0]\n    return counter\n```\n\n自己居然没有解决...参考了[这里][2]\n\n\n## 小结\n\n1. 什么是“函数式编程”\n1. 高阶函数的含义\n2. map和reduce函数的用法\n3. filter函数的用法\n4. sorted函数的用法（参数含义）\n5. “闭包”结构？\n\n  [1]: https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E9%80%89%E6%B3%95\n  [2]: https://www.cnblogs.com/cccmon/p/7930550.html","source":"_posts/Python学习-Day4.md","raw":"---\ntitle: Python学习-Day4\ndate: 2020-02-12 22:08:45\ncategories: 学习Learning\n---\n\n函数式编程\n\n<!--more-->\n\n---\n\n什么是**函数式编程（Functional Programming）**？\n是一种抽象程度很高的编程范式。纯粹的函数式编程语言编写的函数没有变量，一个函数的输入就对应了一个固定的输出。\n\n## 高阶函数（Higher-order Function）\n\n函数名就是一个变量，只是它恰好指向了一个函数。\n\n* abs函数定义在builtins模块中，要修改```abs```变量的指向在其他模块中也生效，需要```builtins.abs = xxx```才可以\n\n什么是**高阶函数**？\n一个函数接收另一个函数作为参数，折中函数就称为高阶函数。\n\n### map/reduce\n\n**map函数：**\n接收两个参数，第一个是函数f，第二个```Iterable```对象i。map函数就是将f作用于i的每一个元素上，并返回一个迭代器。\n用法如下：\n\n```python\n>>> list(map(int, '123456'))\n[1, 2, 3, 4, 5, 6]\n```\n\n**reduce函数**（需要从**functools**模块中导入）：\n接收两个参数，第一个是函数f，第二个是Iterable对象i，返回iterator对象。reduce函数结果继续和序列的下一个元素做累积计算，即：\n\n```\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n```\n\n练习题解答：\n\n> 1.利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']：\n\n```python\ndef trans(ch):\n    if 'a'<= ch <= 'z':\n        return ch\n    else:\n        return chr(ord(ch)+32)\n        \ndef normalize(name):\n    s = name[0]\n    if 'a' <= name[0] <= 'z':\n        s = chr(ord(s) - 32)\n    return s + ''.join(list(map(trans, name[1:])))\n\n# 测试:\nL1 = ['adam', 'LISA', 'barT']\nL2 = list(map(normalize, L1))\nprint(L2)\n```\n\n注：不用map函数的话，字符串有一个capitalize()函数，一句到位。见下：\n\n```python\ndef normalize(name):\n    return name.capitalize()\n\n# 测试:\nL1 = ['adam', 'LISA', 'barT']\nL2 = list(map(normalize, L1))\nprint(L2)\n```\n\n> 2.请编写一个prod()函数，可以接受一个list并利用reduce()求积：\n\n```python\nfrom functools import reduce\ndef multi(a, b):\n    return a * b\n\ndef prod(L):\n    return reduce(multi, L)\n```\n\n### filter\n\n过滤序列。函数接受一个函数和一个序列。函数作用于每一个元素，若函数返回结果为True则保留元素，反之删除。\n\n教程中举例子用[埃式筛法][1]求素数，算法很简洁，值得学习。\n\n### sorted\n\n排序。接收一个**key函数**来实现自定义的排序。key函数作用于每一个元素，返回的结果再进行排序。\n另一个参数**reverse**，设置为True时，进行反向排序（从大到小）。\n\n## 返回函数\n\n函数作为返回值在函数中return。~~（套娃）~~\n\n这样的函数会在调用它的时候才执行。\n\n当函数被返回的时候，相关参数和变量都保存在这个函数中。这种程序结构被称为**闭包（closure）**。\n\n由于函数在返回的时候才保存相关的参数和变量。因此，如果保存循环变量，可能无法获得想要的效果。\n如下例：\n\n```python\nIn [1]:\ndef count():\n    fs = []\n    for i in range(3):\n        def f():\n            return i * i\n        fs.append(f)\n    return fs\nIn [2]:\nf1, f2, f3 = count()\nIn [5]:\nprint(f1(), f2(), f3())\n4 4 4\n```\n\n在编写代码中，应尽量避免返回循环变量，你非要返回就这样写。要返回的函数中再定义一个函数，把循环变量和这个函数绑定起来。\n\n```python\nIn [10]:\ndef count2():\n    fs = []\n    def f(j):\n        def g():\n            return j * j\n        return g\n    for i in range(3):\n        fs.append(f(i))\n    return fs\nIn [11]:\nf1, f2, f3 = count2()\nIn [12]:\nprint(f1(), f2(), f3())\n0 1 4\n```\n\n练习题：\n\n> 利用闭包返回一个计数器函数，每次调用它返回递增整数：\n\n```python\ndef createCounter():\n    s = [0]\n    def counter():\n        s[0] = s[0] + 1\n        return s[0]\n    return counter\n```\n\n自己居然没有解决...参考了[这里][2]\n\n\n## 小结\n\n1. 什么是“函数式编程”\n1. 高阶函数的含义\n2. map和reduce函数的用法\n3. filter函数的用法\n4. sorted函数的用法（参数含义）\n5. “闭包”结构？\n\n  [1]: https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E9%80%89%E6%B3%95\n  [2]: https://www.cnblogs.com/cccmon/p/7930550.html","slug":"Python学习-Day4","published":1,"updated":"2020-02-12T14:08:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggy001o38t4043hczxk","content":"<p>函数式编程</p>\n<span id=\"more\"></span>\n\n<hr>\n<p>什么是<strong>函数式编程（Functional Programming）</strong>？<br>是一种抽象程度很高的编程范式。纯粹的函数式编程语言编写的函数没有变量，一个函数的输入就对应了一个固定的输出。</p>\n<h2 id=\"高阶函数（Higher-order-Function）\"><a href=\"#高阶函数（Higher-order-Function）\" class=\"headerlink\" title=\"高阶函数（Higher-order Function）\"></a>高阶函数（Higher-order Function）</h2><p>函数名就是一个变量，只是它恰好指向了一个函数。</p>\n<ul>\n<li>abs函数定义在builtins模块中，要修改<code>abs</code>变量的指向在其他模块中也生效，需要<code>builtins.abs = xxx</code>才可以</li>\n</ul>\n<p>什么是<strong>高阶函数</strong>？<br>一个函数接收另一个函数作为参数，折中函数就称为高阶函数。</p>\n<h3 id=\"map-reduce\"><a href=\"#map-reduce\" class=\"headerlink\" title=\"map/reduce\"></a>map/reduce</h3><p><strong>map函数：</strong><br>接收两个参数，第一个是函数f，第二个<code>Iterable</code>对象i。map函数就是将f作用于i的每一个元素上，并返回一个迭代器。<br>用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>, <span class=\"string\">&#x27;123456&#x27;</span>))</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>reduce函数</strong>（需要从<strong>functools</strong>模块中导入）：<br>接收两个参数，第一个是函数f，第二个是Iterable对象i，返回iterator对象。reduce函数结果继续和序列的下一个元素做累积计算，即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>\n\n<p>练习题解答：</p>\n<blockquote>\n<p>1.利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]：</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trans</span>(<span class=\"params\">ch</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;a&#x27;</span>&lt;= ch &lt;= <span class=\"string\">&#x27;z&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">chr</span>(<span class=\"built_in\">ord</span>(ch)+<span class=\"number\">32</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">normalize</span>(<span class=\"params\">name</span>):</span></span><br><span class=\"line\">    s = name[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;a&#x27;</span> &lt;= name[<span class=\"number\">0</span>] &lt;= <span class=\"string\">&#x27;z&#x27;</span>:</span><br><span class=\"line\">        s = <span class=\"built_in\">chr</span>(<span class=\"built_in\">ord</span>(s) - <span class=\"number\">32</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s + <span class=\"string\">&#x27;&#x27;</span>.join(<span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(trans, name[<span class=\"number\">1</span>:])))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试:</span></span><br><span class=\"line\">L1 = [<span class=\"string\">&#x27;adam&#x27;</span>, <span class=\"string\">&#x27;LISA&#x27;</span>, <span class=\"string\">&#x27;barT&#x27;</span>]</span><br><span class=\"line\">L2 = <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(normalize, L1))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(L2)</span><br></pre></td></tr></table></figure>\n\n<p>注：不用map函数的话，字符串有一个capitalize()函数，一句到位。见下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">normalize</span>(<span class=\"params\">name</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> name.capitalize()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试:</span></span><br><span class=\"line\">L1 = [<span class=\"string\">&#x27;adam&#x27;</span>, <span class=\"string\">&#x27;LISA&#x27;</span>, <span class=\"string\">&#x27;barT&#x27;</span>]</span><br><span class=\"line\">L2 = <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(normalize, L1))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(L2)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>2.请编写一个prod()函数，可以接受一个list并利用reduce()求积：</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> reduce</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multi</span>(<span class=\"params\">a, b</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">prod</span>(<span class=\"params\">L</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(multi, L)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p>过滤序列。函数接受一个函数和一个序列。函数作用于每一个元素，若函数返回结果为True则保留元素，反之删除。</p>\n<p>教程中举例子用<a href=\"https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E9%80%89%E6%B3%95\">埃式筛法</a>求素数，算法很简洁，值得学习。</p>\n<h3 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted\"></a>sorted</h3><p>排序。接收一个<strong>key函数</strong>来实现自定义的排序。key函数作用于每一个元素，返回的结果再进行排序。<br>另一个参数<strong>reverse</strong>，设置为True时，进行反向排序（从大到小）。</p>\n<h2 id=\"返回函数\"><a href=\"#返回函数\" class=\"headerlink\" title=\"返回函数\"></a>返回函数</h2><p>函数作为返回值在函数中return。<del>（套娃）</del></p>\n<p>这样的函数会在调用它的时候才执行。</p>\n<p>当函数被返回的时候，相关参数和变量都保存在这个函数中。这种程序结构被称为<strong>闭包（closure）</strong>。</p>\n<p>由于函数在返回的时候才保存相关的参数和变量。因此，如果保存循环变量，可能无法获得想要的效果。<br>如下例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">1</span>]:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span>():</span></span><br><span class=\"line\">    fs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span>():</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> i * i</span><br><span class=\"line\">        fs.append(f)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs</span><br><span class=\"line\">In [<span class=\"number\">2</span>]:</span><br><span class=\"line\">f1, f2, f3 = count()</span><br><span class=\"line\">In [<span class=\"number\">5</span>]:</span><br><span class=\"line\"><span class=\"built_in\">print</span>(f1(), f2(), f3())</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">4</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>在编写代码中，应尽量避免返回循环变量，你非要返回就这样写。要返回的函数中再定义一个函数，把循环变量和这个函数绑定起来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">10</span>]:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count2</span>():</span></span><br><span class=\"line\">    fs = []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span>(<span class=\"params\">j</span>):</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">g</span>():</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> j * j</span><br><span class=\"line\">        <span class=\"keyword\">return</span> g</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">        fs.append(f(i))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs</span><br><span class=\"line\">In [<span class=\"number\">11</span>]:</span><br><span class=\"line\">f1, f2, f3 = count2()</span><br><span class=\"line\">In [<span class=\"number\">12</span>]:</span><br><span class=\"line\"><span class=\"built_in\">print</span>(f1(), f2(), f3())</span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>练习题：</p>\n<blockquote>\n<p>利用闭包返回一个计数器函数，每次调用它返回递增整数：</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">createCounter</span>():</span></span><br><span class=\"line\">    s = [<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">counter</span>():</span></span><br><span class=\"line\">        s[<span class=\"number\">0</span>] = s[<span class=\"number\">0</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> counter</span><br></pre></td></tr></table></figure>\n\n<p>自己居然没有解决…参考了<a href=\"https://www.cnblogs.com/cccmon/p/7930550.html\">这里</a></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li>什么是“函数式编程”</li>\n<li>高阶函数的含义</li>\n<li>map和reduce函数的用法</li>\n<li>filter函数的用法</li>\n<li>sorted函数的用法（参数含义）</li>\n<li>“闭包”结构？</li>\n</ol>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>函数式编程</p>","more":"<hr>\n<p>什么是<strong>函数式编程（Functional Programming）</strong>？<br>是一种抽象程度很高的编程范式。纯粹的函数式编程语言编写的函数没有变量，一个函数的输入就对应了一个固定的输出。</p>\n<h2 id=\"高阶函数（Higher-order-Function）\"><a href=\"#高阶函数（Higher-order-Function）\" class=\"headerlink\" title=\"高阶函数（Higher-order Function）\"></a>高阶函数（Higher-order Function）</h2><p>函数名就是一个变量，只是它恰好指向了一个函数。</p>\n<ul>\n<li>abs函数定义在builtins模块中，要修改<code>abs</code>变量的指向在其他模块中也生效，需要<code>builtins.abs = xxx</code>才可以</li>\n</ul>\n<p>什么是<strong>高阶函数</strong>？<br>一个函数接收另一个函数作为参数，折中函数就称为高阶函数。</p>\n<h3 id=\"map-reduce\"><a href=\"#map-reduce\" class=\"headerlink\" title=\"map/reduce\"></a>map/reduce</h3><p><strong>map函数：</strong><br>接收两个参数，第一个是函数f，第二个<code>Iterable</code>对象i。map函数就是将f作用于i的每一个元素上，并返回一个迭代器。<br>用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>, <span class=\"string\">&#x27;123456&#x27;</span>))</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>reduce函数</strong>（需要从<strong>functools</strong>模块中导入）：<br>接收两个参数，第一个是函数f，第二个是Iterable对象i，返回iterator对象。reduce函数结果继续和序列的下一个元素做累积计算，即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>\n\n<p>练习题解答：</p>\n<blockquote>\n<p>1.利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]：</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trans</span>(<span class=\"params\">ch</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;a&#x27;</span>&lt;= ch &lt;= <span class=\"string\">&#x27;z&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">chr</span>(<span class=\"built_in\">ord</span>(ch)+<span class=\"number\">32</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">normalize</span>(<span class=\"params\">name</span>):</span></span><br><span class=\"line\">    s = name[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;a&#x27;</span> &lt;= name[<span class=\"number\">0</span>] &lt;= <span class=\"string\">&#x27;z&#x27;</span>:</span><br><span class=\"line\">        s = <span class=\"built_in\">chr</span>(<span class=\"built_in\">ord</span>(s) - <span class=\"number\">32</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s + <span class=\"string\">&#x27;&#x27;</span>.join(<span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(trans, name[<span class=\"number\">1</span>:])))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试:</span></span><br><span class=\"line\">L1 = [<span class=\"string\">&#x27;adam&#x27;</span>, <span class=\"string\">&#x27;LISA&#x27;</span>, <span class=\"string\">&#x27;barT&#x27;</span>]</span><br><span class=\"line\">L2 = <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(normalize, L1))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(L2)</span><br></pre></td></tr></table></figure>\n\n<p>注：不用map函数的话，字符串有一个capitalize()函数，一句到位。见下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">normalize</span>(<span class=\"params\">name</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> name.capitalize()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试:</span></span><br><span class=\"line\">L1 = [<span class=\"string\">&#x27;adam&#x27;</span>, <span class=\"string\">&#x27;LISA&#x27;</span>, <span class=\"string\">&#x27;barT&#x27;</span>]</span><br><span class=\"line\">L2 = <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(normalize, L1))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(L2)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>2.请编写一个prod()函数，可以接受一个list并利用reduce()求积：</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> reduce</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multi</span>(<span class=\"params\">a, b</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">prod</span>(<span class=\"params\">L</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(multi, L)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p>过滤序列。函数接受一个函数和一个序列。函数作用于每一个元素，若函数返回结果为True则保留元素，反之删除。</p>\n<p>教程中举例子用<a href=\"https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E9%80%89%E6%B3%95\">埃式筛法</a>求素数，算法很简洁，值得学习。</p>\n<h3 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted\"></a>sorted</h3><p>排序。接收一个<strong>key函数</strong>来实现自定义的排序。key函数作用于每一个元素，返回的结果再进行排序。<br>另一个参数<strong>reverse</strong>，设置为True时，进行反向排序（从大到小）。</p>\n<h2 id=\"返回函数\"><a href=\"#返回函数\" class=\"headerlink\" title=\"返回函数\"></a>返回函数</h2><p>函数作为返回值在函数中return。<del>（套娃）</del></p>\n<p>这样的函数会在调用它的时候才执行。</p>\n<p>当函数被返回的时候，相关参数和变量都保存在这个函数中。这种程序结构被称为<strong>闭包（closure）</strong>。</p>\n<p>由于函数在返回的时候才保存相关的参数和变量。因此，如果保存循环变量，可能无法获得想要的效果。<br>如下例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">1</span>]:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span>():</span></span><br><span class=\"line\">    fs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span>():</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> i * i</span><br><span class=\"line\">        fs.append(f)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs</span><br><span class=\"line\">In [<span class=\"number\">2</span>]:</span><br><span class=\"line\">f1, f2, f3 = count()</span><br><span class=\"line\">In [<span class=\"number\">5</span>]:</span><br><span class=\"line\"><span class=\"built_in\">print</span>(f1(), f2(), f3())</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">4</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>在编写代码中，应尽量避免返回循环变量，你非要返回就这样写。要返回的函数中再定义一个函数，把循环变量和这个函数绑定起来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">10</span>]:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count2</span>():</span></span><br><span class=\"line\">    fs = []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span>(<span class=\"params\">j</span>):</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">g</span>():</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> j * j</span><br><span class=\"line\">        <span class=\"keyword\">return</span> g</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">        fs.append(f(i))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs</span><br><span class=\"line\">In [<span class=\"number\">11</span>]:</span><br><span class=\"line\">f1, f2, f3 = count2()</span><br><span class=\"line\">In [<span class=\"number\">12</span>]:</span><br><span class=\"line\"><span class=\"built_in\">print</span>(f1(), f2(), f3())</span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>练习题：</p>\n<blockquote>\n<p>利用闭包返回一个计数器函数，每次调用它返回递增整数：</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">createCounter</span>():</span></span><br><span class=\"line\">    s = [<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">counter</span>():</span></span><br><span class=\"line\">        s[<span class=\"number\">0</span>] = s[<span class=\"number\">0</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> counter</span><br></pre></td></tr></table></figure>\n\n<p>自己居然没有解决…参考了<a href=\"https://www.cnblogs.com/cccmon/p/7930550.html\">这里</a></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li>什么是“函数式编程”</li>\n<li>高阶函数的含义</li>\n<li>map和reduce函数的用法</li>\n<li>filter函数的用法</li>\n<li>sorted函数的用法（参数含义）</li>\n<li>“闭包”结构？</li>\n</ol>"},{"title":"Reflect on 2019|2019复盘|2020计划","date":"2020-01-10T08:46:33.000Z","_content":"\n\"If you spend your entire life with the mentality of \"my trauma fucked me up and that's why I am the way I am\" instead oof learning how to heal and grow from your trauma,**YOU** are your own problem.\"\n\n<!--more-->\n\n---\n\n> DO NOT make any excuses.\nBe HONEST.It's fine to feel bad if you make no progress.\n\n看到一个喜欢的博主说了复盘2019，我也照着她提到的几点做了一遍。\n希望我们的2020都是丰富精彩的一年:-D\n\n## Progress and Rating\n\n先说一下今年都完成了些什么事。排名不分前后~\n1. 拿到驾照\n2. 第一次组织聚会\n3. 第一次组织校级活动\n4. 完成21天减肥计划\n5. 成功保研北交大\n6. 拿到“十佳社长”和“标兵社团”称号\n7. 游泳学会了换气（虽然动作不够熟练）\n8. 去葫芦岛参加了2019年的毽球全国赛\n9. 学会了做简单的饭\n10. 第一次一个人去看五月天\n11. 第一次去夜店蹦迪\n12. 和高中好朋友去合肥看莫文蔚演唱会\n13. 和朋友们在杭州玩\n14. 和妈妈还有弟弟去南京玩\n15. 和朋友在北京玩\n16. 暑假全家人去上海玩\n\n寒假的时候在读书与工作之间最后选择了读书。如果这辈子都在工作，那也不差这三年去不同的环境认识更多更优秀的人。\n去年也没有做什么年度规划，匆匆地开始了这一年。所幸没有匆匆地结束这一年，让明年这个时候有一些可以比对的东西。\n为自己打个分，实实在在的，75分吧。\n这么多年来的考试，看到8字打头的分数会觉得自己还可以，但看到7字打头的分数会心有不甘，想找借口。平心而论我还是想给自己打75分。\n我还是觉得自己浪费了很多时间，虚度时光，一眨眼天都黑了，很多时间浪费在完全没有意义的事情上。也有很多机会被自己放走。还是不愿十分努力，还是喜欢给自己找借口。认识到自己的不足，却不愿去改变。依然没有一个明确的目标，更多时候在得过且过，更多时候在跟着周围人走。\n尽管有想做的事情，却不愿真正地投入时间去尝试。\n当然也不是什么都没有做，相反的，做了不少值得纪念的事情。而且在保研后的这一个学期里思考了很多，有了很多新的认识。\n给自己75分，是想告诉自己，你还可以更好。\nAnd you deserve better.\n\n## What I've learned\n\n在参加华为软挑的时候，认识到了自己编程能力确实不强，也认识到了周围确实大有比我厉害的人存在。然而这一年里，我在这方面基本没有下功夫。每次都说要重新做人，但也只是说说而已。编程能力只在退步没有进步，甚至不如大一的自己，早就被比下去了。**这一点要承认。**\n\n我是很怕被别人看不起的，明明实力确实不行，却又不肯承认，装作无所谓的样子，把那个儒弱玻璃心的自己包裹起来。内心自卑却又表现得很自负，一点都不甘示弱。不想告诉自己就是比别人差。用“我只是不愿努力罢了”来麻痹自己，却又不肯真的去努力。\n**不努力是因为自己给自己找了一个借口：“这样我就有理由解释我为什么差劲了：只是因为我不肯花功夫努力哦。而不是我努力了因为我别的什么的原因才失败了哦。”**\n为什么对“努力而失败”那么敏感？“努力了却失败”是一件很正常的事，无关智商，没什么好笑的。你也不该对“努力了却失败了”的人感觉什么异样，你应该尊重他们。\n不畏惧失败就是这个意思，是不畏惧努力之后的失败。你总是把目光放在结果，没关注过过程。\n从今以后，做一件事，不管结果如何，都付出所有精力吧。你才有资格说“失败”。“失败”也不是人人都有资格说的。**这一点更要承认。**\n\n在很多方面毫无进步，实话实说。没有明确目标，依然是这样。这一个学期虽然很闲，但是几乎没做什么。\n\n还学会了一件事：要做就马上去做，减少一些所谓的仪式感。倒不是说就丢掉仪式感不要了。有一句话能更好地概括：**静止的趋向于静止，运动的趋向于运动。**\n\n## Plan for 2020\n\n2019年最成功的事情之一，是坚持了21天减肥。在这期间，没有摄入任何含糖饮料，高糖甜点、面包。也没有摄入任何零食，每天或多或少地保持运动。这一件事，倒是能给我其他方面的习惯养成等等都带来一定的帮助。能坚持下来，其实我没有消耗太大的意志力，有种“自然而然就这样了”的感觉。\n总结一下经验的话，第一，我没有给自己太大的压力。没有节食，没有过度运动，没有太高的要求。第二，没有想太多，开始了就不想别的了。\n\n**下面是年度目标：**\n\n### 学习\n\n\n1. 大四下完成毕设，要申优。研一上完成专业课程，目标暂时没标准后来补。\n2. 大四下完成高数、概率论、线代的学习\n3. 研一上保持每周文献精读\n4. 保持英语学习（形式不定）\n5. 保持算法学习和代码时间\n6. 养成每天阅读的习惯，平均每周1本书。书籍类型不限，笔记字数不要求，但一定要记录读后感。\n\n### 健康\n\n1. 每天运动，时间长短不限，运动强度不限。\n2. 拒绝高糖高热量食物，拒绝油炸垃圾食品。倒不只是为了减肥，更多是为了健康。\n3. 早睡早睡早睡！不要熬夜不要熬夜不要熬夜！\n\n### 生活\n\n1. 记录每天的时间开销，主要目的是要改掉虚度时间的坏习惯\n2. 坚持写作，类型不限，长度不限，但要每周一篇（可以是书评影评，也可以是生活中的一些思考，也可以是技术博客）\n3. 保持生活空间的整洁（包括房间、桌面、电脑文件）\n\n### Tips\n\n1.  关于辅助工具，有一些需要打卡，我目前倾向于纸质的，更有记录感和成就感。21天计划的话，每次只有一个习惯养成。目前是少玩手机的21天，难度有点大，我觉得我有一点手机依赖症。另外还有一本本子，记录目标细化的完成情况。另外，会在这个博客记录季度和月度规划，微博可能发布一些惩罚要请大家监督...\n\n## The End\n\n（小标题是我瞎取的...）\n以上是一些反思和2020的展望~\n转眼2020也开始了一个多礼拜了， 加油噢(ง •_•)ง","source":"_posts/Reflect-on-2019-2019复盘-2020计划.md","raw":"---\ntitle: Reflect on 2019|2019复盘|2020计划\ndate: 2020-01-10 16:46:33\ncategories: 生活Life\n---\n\n\"If you spend your entire life with the mentality of \"my trauma fucked me up and that's why I am the way I am\" instead oof learning how to heal and grow from your trauma,**YOU** are your own problem.\"\n\n<!--more-->\n\n---\n\n> DO NOT make any excuses.\nBe HONEST.It's fine to feel bad if you make no progress.\n\n看到一个喜欢的博主说了复盘2019，我也照着她提到的几点做了一遍。\n希望我们的2020都是丰富精彩的一年:-D\n\n## Progress and Rating\n\n先说一下今年都完成了些什么事。排名不分前后~\n1. 拿到驾照\n2. 第一次组织聚会\n3. 第一次组织校级活动\n4. 完成21天减肥计划\n5. 成功保研北交大\n6. 拿到“十佳社长”和“标兵社团”称号\n7. 游泳学会了换气（虽然动作不够熟练）\n8. 去葫芦岛参加了2019年的毽球全国赛\n9. 学会了做简单的饭\n10. 第一次一个人去看五月天\n11. 第一次去夜店蹦迪\n12. 和高中好朋友去合肥看莫文蔚演唱会\n13. 和朋友们在杭州玩\n14. 和妈妈还有弟弟去南京玩\n15. 和朋友在北京玩\n16. 暑假全家人去上海玩\n\n寒假的时候在读书与工作之间最后选择了读书。如果这辈子都在工作，那也不差这三年去不同的环境认识更多更优秀的人。\n去年也没有做什么年度规划，匆匆地开始了这一年。所幸没有匆匆地结束这一年，让明年这个时候有一些可以比对的东西。\n为自己打个分，实实在在的，75分吧。\n这么多年来的考试，看到8字打头的分数会觉得自己还可以，但看到7字打头的分数会心有不甘，想找借口。平心而论我还是想给自己打75分。\n我还是觉得自己浪费了很多时间，虚度时光，一眨眼天都黑了，很多时间浪费在完全没有意义的事情上。也有很多机会被自己放走。还是不愿十分努力，还是喜欢给自己找借口。认识到自己的不足，却不愿去改变。依然没有一个明确的目标，更多时候在得过且过，更多时候在跟着周围人走。\n尽管有想做的事情，却不愿真正地投入时间去尝试。\n当然也不是什么都没有做，相反的，做了不少值得纪念的事情。而且在保研后的这一个学期里思考了很多，有了很多新的认识。\n给自己75分，是想告诉自己，你还可以更好。\nAnd you deserve better.\n\n## What I've learned\n\n在参加华为软挑的时候，认识到了自己编程能力确实不强，也认识到了周围确实大有比我厉害的人存在。然而这一年里，我在这方面基本没有下功夫。每次都说要重新做人，但也只是说说而已。编程能力只在退步没有进步，甚至不如大一的自己，早就被比下去了。**这一点要承认。**\n\n我是很怕被别人看不起的，明明实力确实不行，却又不肯承认，装作无所谓的样子，把那个儒弱玻璃心的自己包裹起来。内心自卑却又表现得很自负，一点都不甘示弱。不想告诉自己就是比别人差。用“我只是不愿努力罢了”来麻痹自己，却又不肯真的去努力。\n**不努力是因为自己给自己找了一个借口：“这样我就有理由解释我为什么差劲了：只是因为我不肯花功夫努力哦。而不是我努力了因为我别的什么的原因才失败了哦。”**\n为什么对“努力而失败”那么敏感？“努力了却失败”是一件很正常的事，无关智商，没什么好笑的。你也不该对“努力了却失败了”的人感觉什么异样，你应该尊重他们。\n不畏惧失败就是这个意思，是不畏惧努力之后的失败。你总是把目光放在结果，没关注过过程。\n从今以后，做一件事，不管结果如何，都付出所有精力吧。你才有资格说“失败”。“失败”也不是人人都有资格说的。**这一点更要承认。**\n\n在很多方面毫无进步，实话实说。没有明确目标，依然是这样。这一个学期虽然很闲，但是几乎没做什么。\n\n还学会了一件事：要做就马上去做，减少一些所谓的仪式感。倒不是说就丢掉仪式感不要了。有一句话能更好地概括：**静止的趋向于静止，运动的趋向于运动。**\n\n## Plan for 2020\n\n2019年最成功的事情之一，是坚持了21天减肥。在这期间，没有摄入任何含糖饮料，高糖甜点、面包。也没有摄入任何零食，每天或多或少地保持运动。这一件事，倒是能给我其他方面的习惯养成等等都带来一定的帮助。能坚持下来，其实我没有消耗太大的意志力，有种“自然而然就这样了”的感觉。\n总结一下经验的话，第一，我没有给自己太大的压力。没有节食，没有过度运动，没有太高的要求。第二，没有想太多，开始了就不想别的了。\n\n**下面是年度目标：**\n\n### 学习\n\n\n1. 大四下完成毕设，要申优。研一上完成专业课程，目标暂时没标准后来补。\n2. 大四下完成高数、概率论、线代的学习\n3. 研一上保持每周文献精读\n4. 保持英语学习（形式不定）\n5. 保持算法学习和代码时间\n6. 养成每天阅读的习惯，平均每周1本书。书籍类型不限，笔记字数不要求，但一定要记录读后感。\n\n### 健康\n\n1. 每天运动，时间长短不限，运动强度不限。\n2. 拒绝高糖高热量食物，拒绝油炸垃圾食品。倒不只是为了减肥，更多是为了健康。\n3. 早睡早睡早睡！不要熬夜不要熬夜不要熬夜！\n\n### 生活\n\n1. 记录每天的时间开销，主要目的是要改掉虚度时间的坏习惯\n2. 坚持写作，类型不限，长度不限，但要每周一篇（可以是书评影评，也可以是生活中的一些思考，也可以是技术博客）\n3. 保持生活空间的整洁（包括房间、桌面、电脑文件）\n\n### Tips\n\n1.  关于辅助工具，有一些需要打卡，我目前倾向于纸质的，更有记录感和成就感。21天计划的话，每次只有一个习惯养成。目前是少玩手机的21天，难度有点大，我觉得我有一点手机依赖症。另外还有一本本子，记录目标细化的完成情况。另外，会在这个博客记录季度和月度规划，微博可能发布一些惩罚要请大家监督...\n\n## The End\n\n（小标题是我瞎取的...）\n以上是一些反思和2020的展望~\n转眼2020也开始了一个多礼拜了， 加油噢(ง •_•)ง","slug":"Reflect-on-2019-2019复盘-2020计划","published":1,"updated":"2020-01-10T08:46:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggz001r38t46jcq2ma7","content":"<p>“If you spend your entire life with the mentality of “my trauma fucked me up and that’s why I am the way I am” instead oof learning how to heal and grow from your trauma,<strong>YOU</strong> are your own problem.”</p>\n<span id=\"more\"></span>\n\n<hr>\n<blockquote>\n<p>DO NOT make any excuses.<br>Be HONEST.It’s fine to feel bad if you make no progress.</p>\n</blockquote>\n<p>看到一个喜欢的博主说了复盘2019，我也照着她提到的几点做了一遍。<br>希望我们的2020都是丰富精彩的一年:-D</p>\n<h2 id=\"Progress-and-Rating\"><a href=\"#Progress-and-Rating\" class=\"headerlink\" title=\"Progress and Rating\"></a>Progress and Rating</h2><p>先说一下今年都完成了些什么事。排名不分前后~</p>\n<ol>\n<li>拿到驾照</li>\n<li>第一次组织聚会</li>\n<li>第一次组织校级活动</li>\n<li>完成21天减肥计划</li>\n<li>成功保研北交大</li>\n<li>拿到“十佳社长”和“标兵社团”称号</li>\n<li>游泳学会了换气（虽然动作不够熟练）</li>\n<li>去葫芦岛参加了2019年的毽球全国赛</li>\n<li>学会了做简单的饭</li>\n<li>第一次一个人去看五月天</li>\n<li>第一次去夜店蹦迪</li>\n<li>和高中好朋友去合肥看莫文蔚演唱会</li>\n<li>和朋友们在杭州玩</li>\n<li>和妈妈还有弟弟去南京玩</li>\n<li>和朋友在北京玩</li>\n<li>暑假全家人去上海玩</li>\n</ol>\n<p>寒假的时候在读书与工作之间最后选择了读书。如果这辈子都在工作，那也不差这三年去不同的环境认识更多更优秀的人。<br>去年也没有做什么年度规划，匆匆地开始了这一年。所幸没有匆匆地结束这一年，让明年这个时候有一些可以比对的东西。<br>为自己打个分，实实在在的，75分吧。<br>这么多年来的考试，看到8字打头的分数会觉得自己还可以，但看到7字打头的分数会心有不甘，想找借口。平心而论我还是想给自己打75分。<br>我还是觉得自己浪费了很多时间，虚度时光，一眨眼天都黑了，很多时间浪费在完全没有意义的事情上。也有很多机会被自己放走。还是不愿十分努力，还是喜欢给自己找借口。认识到自己的不足，却不愿去改变。依然没有一个明确的目标，更多时候在得过且过，更多时候在跟着周围人走。<br>尽管有想做的事情，却不愿真正地投入时间去尝试。<br>当然也不是什么都没有做，相反的，做了不少值得纪念的事情。而且在保研后的这一个学期里思考了很多，有了很多新的认识。<br>给自己75分，是想告诉自己，你还可以更好。<br>And you deserve better.</p>\n<h2 id=\"What-I’ve-learned\"><a href=\"#What-I’ve-learned\" class=\"headerlink\" title=\"What I’ve learned\"></a>What I’ve learned</h2><p>在参加华为软挑的时候，认识到了自己编程能力确实不强，也认识到了周围确实大有比我厉害的人存在。然而这一年里，我在这方面基本没有下功夫。每次都说要重新做人，但也只是说说而已。编程能力只在退步没有进步，甚至不如大一的自己，早就被比下去了。<strong>这一点要承认。</strong></p>\n<p>我是很怕被别人看不起的，明明实力确实不行，却又不肯承认，装作无所谓的样子，把那个儒弱玻璃心的自己包裹起来。内心自卑却又表现得很自负，一点都不甘示弱。不想告诉自己就是比别人差。用“我只是不愿努力罢了”来麻痹自己，却又不肯真的去努力。<br><strong>不努力是因为自己给自己找了一个借口：“这样我就有理由解释我为什么差劲了：只是因为我不肯花功夫努力哦。而不是我努力了因为我别的什么的原因才失败了哦。”</strong><br>为什么对“努力而失败”那么敏感？“努力了却失败”是一件很正常的事，无关智商，没什么好笑的。你也不该对“努力了却失败了”的人感觉什么异样，你应该尊重他们。<br>不畏惧失败就是这个意思，是不畏惧努力之后的失败。你总是把目光放在结果，没关注过过程。<br>从今以后，做一件事，不管结果如何，都付出所有精力吧。你才有资格说“失败”。“失败”也不是人人都有资格说的。<strong>这一点更要承认。</strong></p>\n<p>在很多方面毫无进步，实话实说。没有明确目标，依然是这样。这一个学期虽然很闲，但是几乎没做什么。</p>\n<p>还学会了一件事：要做就马上去做，减少一些所谓的仪式感。倒不是说就丢掉仪式感不要了。有一句话能更好地概括：<strong>静止的趋向于静止，运动的趋向于运动。</strong></p>\n<h2 id=\"Plan-for-2020\"><a href=\"#Plan-for-2020\" class=\"headerlink\" title=\"Plan for 2020\"></a>Plan for 2020</h2><p>2019年最成功的事情之一，是坚持了21天减肥。在这期间，没有摄入任何含糖饮料，高糖甜点、面包。也没有摄入任何零食，每天或多或少地保持运动。这一件事，倒是能给我其他方面的习惯养成等等都带来一定的帮助。能坚持下来，其实我没有消耗太大的意志力，有种“自然而然就这样了”的感觉。<br>总结一下经验的话，第一，我没有给自己太大的压力。没有节食，没有过度运动，没有太高的要求。第二，没有想太多，开始了就不想别的了。</p>\n<p><strong>下面是年度目标：</strong></p>\n<h3 id=\"学习\"><a href=\"#学习\" class=\"headerlink\" title=\"学习\"></a>学习</h3><ol>\n<li>大四下完成毕设，要申优。研一上完成专业课程，目标暂时没标准后来补。</li>\n<li>大四下完成高数、概率论、线代的学习</li>\n<li>研一上保持每周文献精读</li>\n<li>保持英语学习（形式不定）</li>\n<li>保持算法学习和代码时间</li>\n<li>养成每天阅读的习惯，平均每周1本书。书籍类型不限，笔记字数不要求，但一定要记录读后感。</li>\n</ol>\n<h3 id=\"健康\"><a href=\"#健康\" class=\"headerlink\" title=\"健康\"></a>健康</h3><ol>\n<li>每天运动，时间长短不限，运动强度不限。</li>\n<li>拒绝高糖高热量食物，拒绝油炸垃圾食品。倒不只是为了减肥，更多是为了健康。</li>\n<li>早睡早睡早睡！不要熬夜不要熬夜不要熬夜！</li>\n</ol>\n<h3 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h3><ol>\n<li>记录每天的时间开销，主要目的是要改掉虚度时间的坏习惯</li>\n<li>坚持写作，类型不限，长度不限，但要每周一篇（可以是书评影评，也可以是生活中的一些思考，也可以是技术博客）</li>\n<li>保持生活空间的整洁（包括房间、桌面、电脑文件）</li>\n</ol>\n<h3 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h3><ol>\n<li> 关于辅助工具，有一些需要打卡，我目前倾向于纸质的，更有记录感和成就感。21天计划的话，每次只有一个习惯养成。目前是少玩手机的21天，难度有点大，我觉得我有一点手机依赖症。另外还有一本本子，记录目标细化的完成情况。另外，会在这个博客记录季度和月度规划，微博可能发布一些惩罚要请大家监督…</li>\n</ol>\n<h2 id=\"The-End\"><a href=\"#The-End\" class=\"headerlink\" title=\"The End\"></a>The End</h2><p>（小标题是我瞎取的…）<br>以上是一些反思和2020的展望~<br>转眼2020也开始了一个多礼拜了， 加油噢(ง •_•)ง</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>“If you spend your entire life with the mentality of “my trauma fucked me up and that’s why I am the way I am” instead oof learning how to heal and grow from your trauma,<strong>YOU</strong> are your own problem.”</p>","more":"<hr>\n<blockquote>\n<p>DO NOT make any excuses.<br>Be HONEST.It’s fine to feel bad if you make no progress.</p>\n</blockquote>\n<p>看到一个喜欢的博主说了复盘2019，我也照着她提到的几点做了一遍。<br>希望我们的2020都是丰富精彩的一年:-D</p>\n<h2 id=\"Progress-and-Rating\"><a href=\"#Progress-and-Rating\" class=\"headerlink\" title=\"Progress and Rating\"></a>Progress and Rating</h2><p>先说一下今年都完成了些什么事。排名不分前后~</p>\n<ol>\n<li>拿到驾照</li>\n<li>第一次组织聚会</li>\n<li>第一次组织校级活动</li>\n<li>完成21天减肥计划</li>\n<li>成功保研北交大</li>\n<li>拿到“十佳社长”和“标兵社团”称号</li>\n<li>游泳学会了换气（虽然动作不够熟练）</li>\n<li>去葫芦岛参加了2019年的毽球全国赛</li>\n<li>学会了做简单的饭</li>\n<li>第一次一个人去看五月天</li>\n<li>第一次去夜店蹦迪</li>\n<li>和高中好朋友去合肥看莫文蔚演唱会</li>\n<li>和朋友们在杭州玩</li>\n<li>和妈妈还有弟弟去南京玩</li>\n<li>和朋友在北京玩</li>\n<li>暑假全家人去上海玩</li>\n</ol>\n<p>寒假的时候在读书与工作之间最后选择了读书。如果这辈子都在工作，那也不差这三年去不同的环境认识更多更优秀的人。<br>去年也没有做什么年度规划，匆匆地开始了这一年。所幸没有匆匆地结束这一年，让明年这个时候有一些可以比对的东西。<br>为自己打个分，实实在在的，75分吧。<br>这么多年来的考试，看到8字打头的分数会觉得自己还可以，但看到7字打头的分数会心有不甘，想找借口。平心而论我还是想给自己打75分。<br>我还是觉得自己浪费了很多时间，虚度时光，一眨眼天都黑了，很多时间浪费在完全没有意义的事情上。也有很多机会被自己放走。还是不愿十分努力，还是喜欢给自己找借口。认识到自己的不足，却不愿去改变。依然没有一个明确的目标，更多时候在得过且过，更多时候在跟着周围人走。<br>尽管有想做的事情，却不愿真正地投入时间去尝试。<br>当然也不是什么都没有做，相反的，做了不少值得纪念的事情。而且在保研后的这一个学期里思考了很多，有了很多新的认识。<br>给自己75分，是想告诉自己，你还可以更好。<br>And you deserve better.</p>\n<h2 id=\"What-I’ve-learned\"><a href=\"#What-I’ve-learned\" class=\"headerlink\" title=\"What I’ve learned\"></a>What I’ve learned</h2><p>在参加华为软挑的时候，认识到了自己编程能力确实不强，也认识到了周围确实大有比我厉害的人存在。然而这一年里，我在这方面基本没有下功夫。每次都说要重新做人，但也只是说说而已。编程能力只在退步没有进步，甚至不如大一的自己，早就被比下去了。<strong>这一点要承认。</strong></p>\n<p>我是很怕被别人看不起的，明明实力确实不行，却又不肯承认，装作无所谓的样子，把那个儒弱玻璃心的自己包裹起来。内心自卑却又表现得很自负，一点都不甘示弱。不想告诉自己就是比别人差。用“我只是不愿努力罢了”来麻痹自己，却又不肯真的去努力。<br><strong>不努力是因为自己给自己找了一个借口：“这样我就有理由解释我为什么差劲了：只是因为我不肯花功夫努力哦。而不是我努力了因为我别的什么的原因才失败了哦。”</strong><br>为什么对“努力而失败”那么敏感？“努力了却失败”是一件很正常的事，无关智商，没什么好笑的。你也不该对“努力了却失败了”的人感觉什么异样，你应该尊重他们。<br>不畏惧失败就是这个意思，是不畏惧努力之后的失败。你总是把目光放在结果，没关注过过程。<br>从今以后，做一件事，不管结果如何，都付出所有精力吧。你才有资格说“失败”。“失败”也不是人人都有资格说的。<strong>这一点更要承认。</strong></p>\n<p>在很多方面毫无进步，实话实说。没有明确目标，依然是这样。这一个学期虽然很闲，但是几乎没做什么。</p>\n<p>还学会了一件事：要做就马上去做，减少一些所谓的仪式感。倒不是说就丢掉仪式感不要了。有一句话能更好地概括：<strong>静止的趋向于静止，运动的趋向于运动。</strong></p>\n<h2 id=\"Plan-for-2020\"><a href=\"#Plan-for-2020\" class=\"headerlink\" title=\"Plan for 2020\"></a>Plan for 2020</h2><p>2019年最成功的事情之一，是坚持了21天减肥。在这期间，没有摄入任何含糖饮料，高糖甜点、面包。也没有摄入任何零食，每天或多或少地保持运动。这一件事，倒是能给我其他方面的习惯养成等等都带来一定的帮助。能坚持下来，其实我没有消耗太大的意志力，有种“自然而然就这样了”的感觉。<br>总结一下经验的话，第一，我没有给自己太大的压力。没有节食，没有过度运动，没有太高的要求。第二，没有想太多，开始了就不想别的了。</p>\n<p><strong>下面是年度目标：</strong></p>\n<h3 id=\"学习\"><a href=\"#学习\" class=\"headerlink\" title=\"学习\"></a>学习</h3><ol>\n<li>大四下完成毕设，要申优。研一上完成专业课程，目标暂时没标准后来补。</li>\n<li>大四下完成高数、概率论、线代的学习</li>\n<li>研一上保持每周文献精读</li>\n<li>保持英语学习（形式不定）</li>\n<li>保持算法学习和代码时间</li>\n<li>养成每天阅读的习惯，平均每周1本书。书籍类型不限，笔记字数不要求，但一定要记录读后感。</li>\n</ol>\n<h3 id=\"健康\"><a href=\"#健康\" class=\"headerlink\" title=\"健康\"></a>健康</h3><ol>\n<li>每天运动，时间长短不限，运动强度不限。</li>\n<li>拒绝高糖高热量食物，拒绝油炸垃圾食品。倒不只是为了减肥，更多是为了健康。</li>\n<li>早睡早睡早睡！不要熬夜不要熬夜不要熬夜！</li>\n</ol>\n<h3 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h3><ol>\n<li>记录每天的时间开销，主要目的是要改掉虚度时间的坏习惯</li>\n<li>坚持写作，类型不限，长度不限，但要每周一篇（可以是书评影评，也可以是生活中的一些思考，也可以是技术博客）</li>\n<li>保持生活空间的整洁（包括房间、桌面、电脑文件）</li>\n</ol>\n<h3 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h3><ol>\n<li> 关于辅助工具，有一些需要打卡，我目前倾向于纸质的，更有记录感和成就感。21天计划的话，每次只有一个习惯养成。目前是少玩手机的21天，难度有点大，我觉得我有一点手机依赖症。另外还有一本本子，记录目标细化的完成情况。另外，会在这个博客记录季度和月度规划，微博可能发布一些惩罚要请大家监督…</li>\n</ol>\n<h2 id=\"The-End\"><a href=\"#The-End\" class=\"headerlink\" title=\"The End\"></a>The End</h2><p>（小标题是我瞎取的…）<br>以上是一些反思和2020的展望~<br>转眼2020也开始了一个多礼拜了， 加油噢(ง •_•)ง</p>"},{"title":"《数学之美》读书笔记-1","date":"2019-09-13T15:52:57.000Z","_content":"\n不知道说什么好，数学牛逼！\n\n<!--more-->\n\n---\n\n## 第9章 图论和网络爬虫\n\n图论的起源：欧拉的哥尼斯堡七座桥问题。\n图的遍历：深度优先和广度优先\n图与网络爬虫：互联网中的网络之间由超链接相互链接，爬虫相当于对这一张大表进行遍历。如何记录网站是否已经被下载过了呢？用散列表（即哈希表）来记录。关于这部分详见下面的网络爬虫工程的构造。\n\n**（有个问题：哈希到底是个什么神奇的东西？？）**\n\n### 欧拉七桥问题\n\n为什么走不通？如果能不重复地走遍的话，每一个点的度数都得是偶数，这样才能走出去了还能回来。哥尼斯堡的陆地有好几个都是单数座桥连通的。\n\n### 网络爬虫的构建问题\n\n三个方面，**URL的获取和记录，遍历方法**。（以及我认为还要注意的问题：网络通信瓶颈，分布式结构通信的锁等）\n**Case1.如何遍历网页？**\n前面说了图论主要有两种遍历方法：DFS和BFS。在网络爬虫中，由于一个页面相同级别的链接更为重要（如打开首页后，和首页直接链接的网页会更重要）。这有点儿像BFS。\n而DFS也有用武之地，由于打开网站有一个和服务器的握手时间成本，以及大型网络爬虫的分布式结构。很多台电脑一起去下载同一个网站的信息，这样就会减少握手次数。在下载一个网站的时候，这个时候用到的又是BFS。（我理解的意思就是对于整体网络，先下完一个再下第二个，这是DFS思想；对于单个网站，下载的信息全部下完，这是BFS）\n综上所述，不是简单的BFS或者DFS。需要有一个**调度系统**，为网页下载的**优先级排序**，随后按照这个URL队列来进行下载。\n\n**Case2.页面分析和URL提取**\n现在的网页超链接URL信息，由JS脚本语言自动生成，URL不易直接获取，需要有**解析程序**。\n\n**Case3.如何记录已经下载的URL**\n一个超大散列表也需要分布式存储。避免**访问遇到瓶颈**，需要一次多条以及明确下载服务器的分工。\n\n**“很多数学方法就是这样，看上去没有什么实际用途，但是随者时间的推移会突然派上大用场。”**\n\n## 第10章与第11章 搜索引擎的部分设计\n\n在搜索中，网站的排名取决于网页本身的信息质量和与这个查询和网页之间的相关性。\n\n### 网页信息质量\n\n别的网站越多地链接到这个网站，这个网站的质量就越高。每一个网站对这个网站的表决权也不同，排名越高的网站，权重越大。这个权重（即排名）的计算，通过矩阵相乘和迭代的方法得到的。\n思想：将互联网看作一个整体，并找到数学的方法和模型(图和矩阵)来表示它。\n\n### 搜索与网页的相关性\n\nTF-IDF：\nTF指的是term frequency，一个单词在一篇文章中的频率。IDF指的是Inverse Document Frequency，逆文本频率指数，也就是评价单词在文章中的分布情况。（这个单词是多次出现在一篇文章中还是出现在多篇文章中，但是每篇文章中的出现次数都很少。显然，前一种情况下这个单词更重要。eg.“原子能”和“的”）\n\n\\*信息论的解释方法（用熵的角度）\n\n## 第12章 地图与本地搜索\n\n本章不讨论卫星定位的问题。讨论两个问题：1.如何解析用户给出的地址 2.路径规划\n\n### 分析地址\n\n有限状态机。当然实际情况更复杂（用户的错别字等），这时需要模糊匹配，基于概率的有限状态机。\n\n\\*最成功的是AT&T的三位科学家写出了有限状态机C语言工具库。\n\n\\*有限状态传感器是有限状态机的一种特殊情况。它加权形式的模型较多地运用于语音识别和自然语言理解上。与一般的有限状态机不同的是，它的每一个状态都由输入输出来定义。\n\n### 路径规划\n\n运用到的是图论中的动态规划。动态规划的主要思想就是局部最优再找到全局最优。基于的一条理论是，如果a->b存在一条最短路径，那么它的子路径(a->c)也是所有a->c中最短的。\n\n## 第13章 阿米特·辛格博士\n\n他推崇**简单**工程思想，以及他要求（特别是针对机器学习方法）所有的优化方法都要给出原理和解释。\n简单的工程思想，他发明了如搜索防作弊、搜索排序等算法。\n\n## 第14章 文本分类——余弦定理\n\n说是余弦定理的应用，其实更准确的应该是向量的应用。\n主要思想（以文本分类为例）：1.提取文本的关键词，由关键词的TF-IDF，将文本转换为由数字表示的向量。2.计算向量（文本）之间的夹角，角度越小则越相似。\n具体分类方法又有两种（有点像有监督学习和无监督学习）：\n1.根据已知类别的特征向量进行分类。 \n2.迭代，自动分类（相似文本并成小类，小类之间再计算角度，再并成大类）。\n\n（基于的理论：文本中的主题词能表示一篇文章，主题相近的文章中主题词也相近）\n\n## 第15章 文本分类——奇异值分解\n\n“一次把所有的新闻相关性计算出来。”\n奇异值分解，是将一个大型矩阵$A_{MN}$（一行为一个文本）分解为三个小矩阵。三个小矩阵分别是：\n1.酉矩阵$X_{MM}$，每一行代表一个词，每一列代表一个语义类\n2.酉矩阵的共轭矩阵$Y_{NN}$，每一列代表一篇文章，每一行代表一个文章类\n3.对角阵$B_{MN}$，反映语义词和文章类的相关性（*行代表语义词对文章类的相关性，列代表文章类对语义词的相关性。）\n\n## 第16章 信息指纹\n\n简单来说，就是**“为了把一长串字符转换乘一小串二进制数字”**的方法。（用作者的话说，是把一段信息通过一个随机函数映射到多维二进制空间的一个点）\n具体应用可以在数据库搜索、信息加密等等。更进一步，还可以用在集合相似度判断、检测文章抄袭和视频反盗版等等。\n而且信息指纹有一种特性，就是**根据信息可以得到指纹，但是根据指纹很难得到信息**。\n产生信息指纹的关键算法叫**伪随机数生成（PRNG）**。PRNG中用的算法又是**梅森旋转算法**。另外在互联网中经常用到的是基于加密的伪随机数生成器（CSPRGN），有MD5和SHA-1等标准。\n\n\\*数学拥有**简洁**之美！数学可以作为信息的另一种表示手段！\n\\* **相似哈希**：在判断网页相似度的一种信息指纹的算法。思想不复杂，很牛逼。\n1.提取k个关键词，每一个词都有自己的n位指纹$t_k$。\n2.设置网页的信息指纹$T$也为n位。\n3.将T扩展为n个初始值为0的实数。\n4.扫描关键词，指纹位上为0，则对应的T的实数减去权重；反之，加上权重。全部扫描完后，得到的n个实数，压缩为二进制（大于零为1，反之为0）。\n\n## 后记\n\n先写到这里，也已经有两千多字了。后面的笔记将整理到新的一篇中去，我也打算找另外的笔记形式，这样好像有点复杂。\n\n保研成功啦，这个学期会比较空，会认真审视一下自我也好好计划一下大四这一年。\n\n今天是中秋佳节，祝福大家平安团圆，吃月饼也也不会胖。","source":"_posts/《数学之美》读书笔记-1.md","raw":"---\ntitle: 《数学之美》读书笔记-1\ndate: 2019-09-13 23:52:57\ncategories: 读书笔记ReadingNotes\n---\n\n不知道说什么好，数学牛逼！\n\n<!--more-->\n\n---\n\n## 第9章 图论和网络爬虫\n\n图论的起源：欧拉的哥尼斯堡七座桥问题。\n图的遍历：深度优先和广度优先\n图与网络爬虫：互联网中的网络之间由超链接相互链接，爬虫相当于对这一张大表进行遍历。如何记录网站是否已经被下载过了呢？用散列表（即哈希表）来记录。关于这部分详见下面的网络爬虫工程的构造。\n\n**（有个问题：哈希到底是个什么神奇的东西？？）**\n\n### 欧拉七桥问题\n\n为什么走不通？如果能不重复地走遍的话，每一个点的度数都得是偶数，这样才能走出去了还能回来。哥尼斯堡的陆地有好几个都是单数座桥连通的。\n\n### 网络爬虫的构建问题\n\n三个方面，**URL的获取和记录，遍历方法**。（以及我认为还要注意的问题：网络通信瓶颈，分布式结构通信的锁等）\n**Case1.如何遍历网页？**\n前面说了图论主要有两种遍历方法：DFS和BFS。在网络爬虫中，由于一个页面相同级别的链接更为重要（如打开首页后，和首页直接链接的网页会更重要）。这有点儿像BFS。\n而DFS也有用武之地，由于打开网站有一个和服务器的握手时间成本，以及大型网络爬虫的分布式结构。很多台电脑一起去下载同一个网站的信息，这样就会减少握手次数。在下载一个网站的时候，这个时候用到的又是BFS。（我理解的意思就是对于整体网络，先下完一个再下第二个，这是DFS思想；对于单个网站，下载的信息全部下完，这是BFS）\n综上所述，不是简单的BFS或者DFS。需要有一个**调度系统**，为网页下载的**优先级排序**，随后按照这个URL队列来进行下载。\n\n**Case2.页面分析和URL提取**\n现在的网页超链接URL信息，由JS脚本语言自动生成，URL不易直接获取，需要有**解析程序**。\n\n**Case3.如何记录已经下载的URL**\n一个超大散列表也需要分布式存储。避免**访问遇到瓶颈**，需要一次多条以及明确下载服务器的分工。\n\n**“很多数学方法就是这样，看上去没有什么实际用途，但是随者时间的推移会突然派上大用场。”**\n\n## 第10章与第11章 搜索引擎的部分设计\n\n在搜索中，网站的排名取决于网页本身的信息质量和与这个查询和网页之间的相关性。\n\n### 网页信息质量\n\n别的网站越多地链接到这个网站，这个网站的质量就越高。每一个网站对这个网站的表决权也不同，排名越高的网站，权重越大。这个权重（即排名）的计算，通过矩阵相乘和迭代的方法得到的。\n思想：将互联网看作一个整体，并找到数学的方法和模型(图和矩阵)来表示它。\n\n### 搜索与网页的相关性\n\nTF-IDF：\nTF指的是term frequency，一个单词在一篇文章中的频率。IDF指的是Inverse Document Frequency，逆文本频率指数，也就是评价单词在文章中的分布情况。（这个单词是多次出现在一篇文章中还是出现在多篇文章中，但是每篇文章中的出现次数都很少。显然，前一种情况下这个单词更重要。eg.“原子能”和“的”）\n\n\\*信息论的解释方法（用熵的角度）\n\n## 第12章 地图与本地搜索\n\n本章不讨论卫星定位的问题。讨论两个问题：1.如何解析用户给出的地址 2.路径规划\n\n### 分析地址\n\n有限状态机。当然实际情况更复杂（用户的错别字等），这时需要模糊匹配，基于概率的有限状态机。\n\n\\*最成功的是AT&T的三位科学家写出了有限状态机C语言工具库。\n\n\\*有限状态传感器是有限状态机的一种特殊情况。它加权形式的模型较多地运用于语音识别和自然语言理解上。与一般的有限状态机不同的是，它的每一个状态都由输入输出来定义。\n\n### 路径规划\n\n运用到的是图论中的动态规划。动态规划的主要思想就是局部最优再找到全局最优。基于的一条理论是，如果a->b存在一条最短路径，那么它的子路径(a->c)也是所有a->c中最短的。\n\n## 第13章 阿米特·辛格博士\n\n他推崇**简单**工程思想，以及他要求（特别是针对机器学习方法）所有的优化方法都要给出原理和解释。\n简单的工程思想，他发明了如搜索防作弊、搜索排序等算法。\n\n## 第14章 文本分类——余弦定理\n\n说是余弦定理的应用，其实更准确的应该是向量的应用。\n主要思想（以文本分类为例）：1.提取文本的关键词，由关键词的TF-IDF，将文本转换为由数字表示的向量。2.计算向量（文本）之间的夹角，角度越小则越相似。\n具体分类方法又有两种（有点像有监督学习和无监督学习）：\n1.根据已知类别的特征向量进行分类。 \n2.迭代，自动分类（相似文本并成小类，小类之间再计算角度，再并成大类）。\n\n（基于的理论：文本中的主题词能表示一篇文章，主题相近的文章中主题词也相近）\n\n## 第15章 文本分类——奇异值分解\n\n“一次把所有的新闻相关性计算出来。”\n奇异值分解，是将一个大型矩阵$A_{MN}$（一行为一个文本）分解为三个小矩阵。三个小矩阵分别是：\n1.酉矩阵$X_{MM}$，每一行代表一个词，每一列代表一个语义类\n2.酉矩阵的共轭矩阵$Y_{NN}$，每一列代表一篇文章，每一行代表一个文章类\n3.对角阵$B_{MN}$，反映语义词和文章类的相关性（*行代表语义词对文章类的相关性，列代表文章类对语义词的相关性。）\n\n## 第16章 信息指纹\n\n简单来说，就是**“为了把一长串字符转换乘一小串二进制数字”**的方法。（用作者的话说，是把一段信息通过一个随机函数映射到多维二进制空间的一个点）\n具体应用可以在数据库搜索、信息加密等等。更进一步，还可以用在集合相似度判断、检测文章抄袭和视频反盗版等等。\n而且信息指纹有一种特性，就是**根据信息可以得到指纹，但是根据指纹很难得到信息**。\n产生信息指纹的关键算法叫**伪随机数生成（PRNG）**。PRNG中用的算法又是**梅森旋转算法**。另外在互联网中经常用到的是基于加密的伪随机数生成器（CSPRGN），有MD5和SHA-1等标准。\n\n\\*数学拥有**简洁**之美！数学可以作为信息的另一种表示手段！\n\\* **相似哈希**：在判断网页相似度的一种信息指纹的算法。思想不复杂，很牛逼。\n1.提取k个关键词，每一个词都有自己的n位指纹$t_k$。\n2.设置网页的信息指纹$T$也为n位。\n3.将T扩展为n个初始值为0的实数。\n4.扫描关键词，指纹位上为0，则对应的T的实数减去权重；反之，加上权重。全部扫描完后，得到的n个实数，压缩为二进制（大于零为1，反之为0）。\n\n## 后记\n\n先写到这里，也已经有两千多字了。后面的笔记将整理到新的一篇中去，我也打算找另外的笔记形式，这样好像有点复杂。\n\n保研成功啦，这个学期会比较空，会认真审视一下自我也好好计划一下大四这一年。\n\n今天是中秋佳节，祝福大家平安团圆，吃月饼也也不会胖。","slug":"《数学之美》读书笔记-1","published":1,"updated":"2019-09-13T15:52:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaggz001v38t48fz0fmd2","content":"<p>不知道说什么好，数学牛逼！</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"第9章-图论和网络爬虫\"><a href=\"#第9章-图论和网络爬虫\" class=\"headerlink\" title=\"第9章 图论和网络爬虫\"></a>第9章 图论和网络爬虫</h2><p>图论的起源：欧拉的哥尼斯堡七座桥问题。<br>图的遍历：深度优先和广度优先<br>图与网络爬虫：互联网中的网络之间由超链接相互链接，爬虫相当于对这一张大表进行遍历。如何记录网站是否已经被下载过了呢？用散列表（即哈希表）来记录。关于这部分详见下面的网络爬虫工程的构造。</p>\n<p><strong>（有个问题：哈希到底是个什么神奇的东西？？）</strong></p>\n<h3 id=\"欧拉七桥问题\"><a href=\"#欧拉七桥问题\" class=\"headerlink\" title=\"欧拉七桥问题\"></a>欧拉七桥问题</h3><p>为什么走不通？如果能不重复地走遍的话，每一个点的度数都得是偶数，这样才能走出去了还能回来。哥尼斯堡的陆地有好几个都是单数座桥连通的。</p>\n<h3 id=\"网络爬虫的构建问题\"><a href=\"#网络爬虫的构建问题\" class=\"headerlink\" title=\"网络爬虫的构建问题\"></a>网络爬虫的构建问题</h3><p>三个方面，<strong>URL的获取和记录，遍历方法</strong>。（以及我认为还要注意的问题：网络通信瓶颈，分布式结构通信的锁等）<br><strong>Case1.如何遍历网页？</strong><br>前面说了图论主要有两种遍历方法：DFS和BFS。在网络爬虫中，由于一个页面相同级别的链接更为重要（如打开首页后，和首页直接链接的网页会更重要）。这有点儿像BFS。<br>而DFS也有用武之地，由于打开网站有一个和服务器的握手时间成本，以及大型网络爬虫的分布式结构。很多台电脑一起去下载同一个网站的信息，这样就会减少握手次数。在下载一个网站的时候，这个时候用到的又是BFS。（我理解的意思就是对于整体网络，先下完一个再下第二个，这是DFS思想；对于单个网站，下载的信息全部下完，这是BFS）<br>综上所述，不是简单的BFS或者DFS。需要有一个<strong>调度系统</strong>，为网页下载的<strong>优先级排序</strong>，随后按照这个URL队列来进行下载。</p>\n<p><strong>Case2.页面分析和URL提取</strong><br>现在的网页超链接URL信息，由JS脚本语言自动生成，URL不易直接获取，需要有<strong>解析程序</strong>。</p>\n<p><strong>Case3.如何记录已经下载的URL</strong><br>一个超大散列表也需要分布式存储。避免<strong>访问遇到瓶颈</strong>，需要一次多条以及明确下载服务器的分工。</p>\n<p><strong>“很多数学方法就是这样，看上去没有什么实际用途，但是随者时间的推移会突然派上大用场。”</strong></p>\n<h2 id=\"第10章与第11章-搜索引擎的部分设计\"><a href=\"#第10章与第11章-搜索引擎的部分设计\" class=\"headerlink\" title=\"第10章与第11章 搜索引擎的部分设计\"></a>第10章与第11章 搜索引擎的部分设计</h2><p>在搜索中，网站的排名取决于网页本身的信息质量和与这个查询和网页之间的相关性。</p>\n<h3 id=\"网页信息质量\"><a href=\"#网页信息质量\" class=\"headerlink\" title=\"网页信息质量\"></a>网页信息质量</h3><p>别的网站越多地链接到这个网站，这个网站的质量就越高。每一个网站对这个网站的表决权也不同，排名越高的网站，权重越大。这个权重（即排名）的计算，通过矩阵相乘和迭代的方法得到的。<br>思想：将互联网看作一个整体，并找到数学的方法和模型(图和矩阵)来表示它。</p>\n<h3 id=\"搜索与网页的相关性\"><a href=\"#搜索与网页的相关性\" class=\"headerlink\" title=\"搜索与网页的相关性\"></a>搜索与网页的相关性</h3><p>TF-IDF：<br>TF指的是term frequency，一个单词在一篇文章中的频率。IDF指的是Inverse Document Frequency，逆文本频率指数，也就是评价单词在文章中的分布情况。（这个单词是多次出现在一篇文章中还是出现在多篇文章中，但是每篇文章中的出现次数都很少。显然，前一种情况下这个单词更重要。eg.“原子能”和“的”）</p>\n<p>*信息论的解释方法（用熵的角度）</p>\n<h2 id=\"第12章-地图与本地搜索\"><a href=\"#第12章-地图与本地搜索\" class=\"headerlink\" title=\"第12章 地图与本地搜索\"></a>第12章 地图与本地搜索</h2><p>本章不讨论卫星定位的问题。讨论两个问题：1.如何解析用户给出的地址 2.路径规划</p>\n<h3 id=\"分析地址\"><a href=\"#分析地址\" class=\"headerlink\" title=\"分析地址\"></a>分析地址</h3><p>有限状态机。当然实际情况更复杂（用户的错别字等），这时需要模糊匹配，基于概率的有限状态机。</p>\n<p>*最成功的是AT&amp;T的三位科学家写出了有限状态机C语言工具库。</p>\n<p>*有限状态传感器是有限状态机的一种特殊情况。它加权形式的模型较多地运用于语音识别和自然语言理解上。与一般的有限状态机不同的是，它的每一个状态都由输入输出来定义。</p>\n<h3 id=\"路径规划\"><a href=\"#路径规划\" class=\"headerlink\" title=\"路径规划\"></a>路径规划</h3><p>运用到的是图论中的动态规划。动态规划的主要思想就是局部最优再找到全局最优。基于的一条理论是，如果a-&gt;b存在一条最短路径，那么它的子路径(a-&gt;c)也是所有a-&gt;c中最短的。</p>\n<h2 id=\"第13章-阿米特·辛格博士\"><a href=\"#第13章-阿米特·辛格博士\" class=\"headerlink\" title=\"第13章 阿米特·辛格博士\"></a>第13章 阿米特·辛格博士</h2><p>他推崇<strong>简单</strong>工程思想，以及他要求（特别是针对机器学习方法）所有的优化方法都要给出原理和解释。<br>简单的工程思想，他发明了如搜索防作弊、搜索排序等算法。</p>\n<h2 id=\"第14章-文本分类——余弦定理\"><a href=\"#第14章-文本分类——余弦定理\" class=\"headerlink\" title=\"第14章 文本分类——余弦定理\"></a>第14章 文本分类——余弦定理</h2><p>说是余弦定理的应用，其实更准确的应该是向量的应用。<br>主要思想（以文本分类为例）：1.提取文本的关键词，由关键词的TF-IDF，将文本转换为由数字表示的向量。2.计算向量（文本）之间的夹角，角度越小则越相似。<br>具体分类方法又有两种（有点像有监督学习和无监督学习）：<br>1.根据已知类别的特征向量进行分类。<br>2.迭代，自动分类（相似文本并成小类，小类之间再计算角度，再并成大类）。</p>\n<p>（基于的理论：文本中的主题词能表示一篇文章，主题相近的文章中主题词也相近）</p>\n<h2 id=\"第15章-文本分类——奇异值分解\"><a href=\"#第15章-文本分类——奇异值分解\" class=\"headerlink\" title=\"第15章 文本分类——奇异值分解\"></a>第15章 文本分类——奇异值分解</h2><p>“一次把所有的新闻相关性计算出来。”<br>奇异值分解，是将一个大型矩阵$A_{MN}$（一行为一个文本）分解为三个小矩阵。三个小矩阵分别是：<br>1.酉矩阵$X_{MM}$，每一行代表一个词，每一列代表一个语义类<br>2.酉矩阵的共轭矩阵$Y_{NN}$，每一列代表一篇文章，每一行代表一个文章类<br>3.对角阵$B_{MN}$，反映语义词和文章类的相关性（*行代表语义词对文章类的相关性，列代表文章类对语义词的相关性。）</p>\n<h2 id=\"第16章-信息指纹\"><a href=\"#第16章-信息指纹\" class=\"headerlink\" title=\"第16章 信息指纹\"></a>第16章 信息指纹</h2><p>简单来说，就是<strong>“为了把一长串字符转换乘一小串二进制数字”</strong>的方法。（用作者的话说，是把一段信息通过一个随机函数映射到多维二进制空间的一个点）<br>具体应用可以在数据库搜索、信息加密等等。更进一步，还可以用在集合相似度判断、检测文章抄袭和视频反盗版等等。<br>而且信息指纹有一种特性，就是<strong>根据信息可以得到指纹，但是根据指纹很难得到信息</strong>。<br>产生信息指纹的关键算法叫<strong>伪随机数生成（PRNG）</strong>。PRNG中用的算法又是<strong>梅森旋转算法</strong>。另外在互联网中经常用到的是基于加密的伪随机数生成器（CSPRGN），有MD5和SHA-1等标准。</p>\n<p>*数学拥有<strong>简洁</strong>之美！数学可以作为信息的另一种表示手段！<br>* <strong>相似哈希</strong>：在判断网页相似度的一种信息指纹的算法。思想不复杂，很牛逼。<br>1.提取k个关键词，每一个词都有自己的n位指纹$t_k$。<br>2.设置网页的信息指纹$T$也为n位。<br>3.将T扩展为n个初始值为0的实数。<br>4.扫描关键词，指纹位上为0，则对应的T的实数减去权重；反之，加上权重。全部扫描完后，得到的n个实数，压缩为二进制（大于零为1，反之为0）。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>先写到这里，也已经有两千多字了。后面的笔记将整理到新的一篇中去，我也打算找另外的笔记形式，这样好像有点复杂。</p>\n<p>保研成功啦，这个学期会比较空，会认真审视一下自我也好好计划一下大四这一年。</p>\n<p>今天是中秋佳节，祝福大家平安团圆，吃月饼也也不会胖。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>不知道说什么好，数学牛逼！</p>","more":"<hr>\n<h2 id=\"第9章-图论和网络爬虫\"><a href=\"#第9章-图论和网络爬虫\" class=\"headerlink\" title=\"第9章 图论和网络爬虫\"></a>第9章 图论和网络爬虫</h2><p>图论的起源：欧拉的哥尼斯堡七座桥问题。<br>图的遍历：深度优先和广度优先<br>图与网络爬虫：互联网中的网络之间由超链接相互链接，爬虫相当于对这一张大表进行遍历。如何记录网站是否已经被下载过了呢？用散列表（即哈希表）来记录。关于这部分详见下面的网络爬虫工程的构造。</p>\n<p><strong>（有个问题：哈希到底是个什么神奇的东西？？）</strong></p>\n<h3 id=\"欧拉七桥问题\"><a href=\"#欧拉七桥问题\" class=\"headerlink\" title=\"欧拉七桥问题\"></a>欧拉七桥问题</h3><p>为什么走不通？如果能不重复地走遍的话，每一个点的度数都得是偶数，这样才能走出去了还能回来。哥尼斯堡的陆地有好几个都是单数座桥连通的。</p>\n<h3 id=\"网络爬虫的构建问题\"><a href=\"#网络爬虫的构建问题\" class=\"headerlink\" title=\"网络爬虫的构建问题\"></a>网络爬虫的构建问题</h3><p>三个方面，<strong>URL的获取和记录，遍历方法</strong>。（以及我认为还要注意的问题：网络通信瓶颈，分布式结构通信的锁等）<br><strong>Case1.如何遍历网页？</strong><br>前面说了图论主要有两种遍历方法：DFS和BFS。在网络爬虫中，由于一个页面相同级别的链接更为重要（如打开首页后，和首页直接链接的网页会更重要）。这有点儿像BFS。<br>而DFS也有用武之地，由于打开网站有一个和服务器的握手时间成本，以及大型网络爬虫的分布式结构。很多台电脑一起去下载同一个网站的信息，这样就会减少握手次数。在下载一个网站的时候，这个时候用到的又是BFS。（我理解的意思就是对于整体网络，先下完一个再下第二个，这是DFS思想；对于单个网站，下载的信息全部下完，这是BFS）<br>综上所述，不是简单的BFS或者DFS。需要有一个<strong>调度系统</strong>，为网页下载的<strong>优先级排序</strong>，随后按照这个URL队列来进行下载。</p>\n<p><strong>Case2.页面分析和URL提取</strong><br>现在的网页超链接URL信息，由JS脚本语言自动生成，URL不易直接获取，需要有<strong>解析程序</strong>。</p>\n<p><strong>Case3.如何记录已经下载的URL</strong><br>一个超大散列表也需要分布式存储。避免<strong>访问遇到瓶颈</strong>，需要一次多条以及明确下载服务器的分工。</p>\n<p><strong>“很多数学方法就是这样，看上去没有什么实际用途，但是随者时间的推移会突然派上大用场。”</strong></p>\n<h2 id=\"第10章与第11章-搜索引擎的部分设计\"><a href=\"#第10章与第11章-搜索引擎的部分设计\" class=\"headerlink\" title=\"第10章与第11章 搜索引擎的部分设计\"></a>第10章与第11章 搜索引擎的部分设计</h2><p>在搜索中，网站的排名取决于网页本身的信息质量和与这个查询和网页之间的相关性。</p>\n<h3 id=\"网页信息质量\"><a href=\"#网页信息质量\" class=\"headerlink\" title=\"网页信息质量\"></a>网页信息质量</h3><p>别的网站越多地链接到这个网站，这个网站的质量就越高。每一个网站对这个网站的表决权也不同，排名越高的网站，权重越大。这个权重（即排名）的计算，通过矩阵相乘和迭代的方法得到的。<br>思想：将互联网看作一个整体，并找到数学的方法和模型(图和矩阵)来表示它。</p>\n<h3 id=\"搜索与网页的相关性\"><a href=\"#搜索与网页的相关性\" class=\"headerlink\" title=\"搜索与网页的相关性\"></a>搜索与网页的相关性</h3><p>TF-IDF：<br>TF指的是term frequency，一个单词在一篇文章中的频率。IDF指的是Inverse Document Frequency，逆文本频率指数，也就是评价单词在文章中的分布情况。（这个单词是多次出现在一篇文章中还是出现在多篇文章中，但是每篇文章中的出现次数都很少。显然，前一种情况下这个单词更重要。eg.“原子能”和“的”）</p>\n<p>*信息论的解释方法（用熵的角度）</p>\n<h2 id=\"第12章-地图与本地搜索\"><a href=\"#第12章-地图与本地搜索\" class=\"headerlink\" title=\"第12章 地图与本地搜索\"></a>第12章 地图与本地搜索</h2><p>本章不讨论卫星定位的问题。讨论两个问题：1.如何解析用户给出的地址 2.路径规划</p>\n<h3 id=\"分析地址\"><a href=\"#分析地址\" class=\"headerlink\" title=\"分析地址\"></a>分析地址</h3><p>有限状态机。当然实际情况更复杂（用户的错别字等），这时需要模糊匹配，基于概率的有限状态机。</p>\n<p>*最成功的是AT&amp;T的三位科学家写出了有限状态机C语言工具库。</p>\n<p>*有限状态传感器是有限状态机的一种特殊情况。它加权形式的模型较多地运用于语音识别和自然语言理解上。与一般的有限状态机不同的是，它的每一个状态都由输入输出来定义。</p>\n<h3 id=\"路径规划\"><a href=\"#路径规划\" class=\"headerlink\" title=\"路径规划\"></a>路径规划</h3><p>运用到的是图论中的动态规划。动态规划的主要思想就是局部最优再找到全局最优。基于的一条理论是，如果a-&gt;b存在一条最短路径，那么它的子路径(a-&gt;c)也是所有a-&gt;c中最短的。</p>\n<h2 id=\"第13章-阿米特·辛格博士\"><a href=\"#第13章-阿米特·辛格博士\" class=\"headerlink\" title=\"第13章 阿米特·辛格博士\"></a>第13章 阿米特·辛格博士</h2><p>他推崇<strong>简单</strong>工程思想，以及他要求（特别是针对机器学习方法）所有的优化方法都要给出原理和解释。<br>简单的工程思想，他发明了如搜索防作弊、搜索排序等算法。</p>\n<h2 id=\"第14章-文本分类——余弦定理\"><a href=\"#第14章-文本分类——余弦定理\" class=\"headerlink\" title=\"第14章 文本分类——余弦定理\"></a>第14章 文本分类——余弦定理</h2><p>说是余弦定理的应用，其实更准确的应该是向量的应用。<br>主要思想（以文本分类为例）：1.提取文本的关键词，由关键词的TF-IDF，将文本转换为由数字表示的向量。2.计算向量（文本）之间的夹角，角度越小则越相似。<br>具体分类方法又有两种（有点像有监督学习和无监督学习）：<br>1.根据已知类别的特征向量进行分类。<br>2.迭代，自动分类（相似文本并成小类，小类之间再计算角度，再并成大类）。</p>\n<p>（基于的理论：文本中的主题词能表示一篇文章，主题相近的文章中主题词也相近）</p>\n<h2 id=\"第15章-文本分类——奇异值分解\"><a href=\"#第15章-文本分类——奇异值分解\" class=\"headerlink\" title=\"第15章 文本分类——奇异值分解\"></a>第15章 文本分类——奇异值分解</h2><p>“一次把所有的新闻相关性计算出来。”<br>奇异值分解，是将一个大型矩阵$A_{MN}$（一行为一个文本）分解为三个小矩阵。三个小矩阵分别是：<br>1.酉矩阵$X_{MM}$，每一行代表一个词，每一列代表一个语义类<br>2.酉矩阵的共轭矩阵$Y_{NN}$，每一列代表一篇文章，每一行代表一个文章类<br>3.对角阵$B_{MN}$，反映语义词和文章类的相关性（*行代表语义词对文章类的相关性，列代表文章类对语义词的相关性。）</p>\n<h2 id=\"第16章-信息指纹\"><a href=\"#第16章-信息指纹\" class=\"headerlink\" title=\"第16章 信息指纹\"></a>第16章 信息指纹</h2><p>简单来说，就是<strong>“为了把一长串字符转换乘一小串二进制数字”</strong>的方法。（用作者的话说，是把一段信息通过一个随机函数映射到多维二进制空间的一个点）<br>具体应用可以在数据库搜索、信息加密等等。更进一步，还可以用在集合相似度判断、检测文章抄袭和视频反盗版等等。<br>而且信息指纹有一种特性，就是<strong>根据信息可以得到指纹，但是根据指纹很难得到信息</strong>。<br>产生信息指纹的关键算法叫<strong>伪随机数生成（PRNG）</strong>。PRNG中用的算法又是<strong>梅森旋转算法</strong>。另外在互联网中经常用到的是基于加密的伪随机数生成器（CSPRGN），有MD5和SHA-1等标准。</p>\n<p>*数学拥有<strong>简洁</strong>之美！数学可以作为信息的另一种表示手段！<br>* <strong>相似哈希</strong>：在判断网页相似度的一种信息指纹的算法。思想不复杂，很牛逼。<br>1.提取k个关键词，每一个词都有自己的n位指纹$t_k$。<br>2.设置网页的信息指纹$T$也为n位。<br>3.将T扩展为n个初始值为0的实数。<br>4.扫描关键词，指纹位上为0，则对应的T的实数减去权重；反之，加上权重。全部扫描完后，得到的n个实数，压缩为二进制（大于零为1，反之为0）。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>先写到这里，也已经有两千多字了。后面的笔记将整理到新的一篇中去，我也打算找另外的笔记形式，这样好像有点复杂。</p>\n<p>保研成功啦，这个学期会比较空，会认真审视一下自我也好好计划一下大四这一年。</p>\n<p>今天是中秋佳节，祝福大家平安团圆，吃月饼也也不会胖。</p>"},{"title":"《流星雨》读书笔记","date":"2019-12-10T12:39:31.000Z","_content":"\n那么流星我把它看为哪一种人呢？我把它看为在我们生命中擦肩而过的，一些可能你今生再也不会碰到的人。\n\n<!--more-->\n\n---\n\n## 摘抄\n\n婚后会有多少的多少的问题，但戴上戒指，心理已有承诺，今生今世，好也好，坏也坏，生也好，死也好，爱就来了，这是一条最方便的路。\n\n那么流行我把它看为哪一种人呢？我把它看为在我们生命中擦肩而过的，一些可能你今生再也不会碰到的人，我将他们叫做流星。\n\n我觉得，我们需要从每一个人自己做起，安定、祥和、亲爱、精诚是我们每一个人应该放在心里的事情，而不是一个口号；我觉得，中国人和中国人之间越来越亲密了，我们不可以因为许多不同的观念或者看法把整个的大环境作一个翻身。\n\n我认为有的时候，人说自己的生活枯燥，是因为你不制造生活的气氛。\n\n我们不要让环境影响我们，要不然的话，我们的喜怒哀乐都被别人控制了，连气候都可以控制我们，我们是怎样软弱的人呢！\n\n生离是什么呢？是重逢的开始呀！\n\n可是在心态上，他还是有对自己生命一种乐观进取的弹性，而他的最可贵是在他的不知不觉。\n\n如果你晚上不愿意回去的话，不要有罪恶感，以为自己是坏人。\n\n世界上的一切地方只要出名都不好玩，你要去的是没有名字的地方，它能够让你感动。\n\n你家的一条巷子有春夏秋冬，月亮阴晴圆缺，你都看不完你的巷子。\n\n当别人都在种小麦的时候，我退出，去种玫瑰花。\n\n如果说你有这个机会，最好是先看资料再走路，将自己的经验去印证书本所说的是不是相同，然后你才再写下个人的感想。\n\n我不说离别，事实上每一次旅程里，出发的时候也象征了告别；但是我喜欢将离别形容为“出发”，它本来就是一体两面的。\n\n不要让自己珍贵的感情到处泛滥，那是不好的，知道如何保护自己是相当重要的事。\n有时候，我也会留下一些自己的感情，把我心里小小一块留在了什么地方。但在这种时候，我就想到，虽然不舍，可是前面有一个未知在等待着我。我留下了东西，可是我也是在迎接未来。于是搭上公共汽车，司机一发动车，收音机一扭转，流行歌曲哗哗地唱起来，看着窗外风景不断过去。我会对自己说：人生是多么美好啊！因为下一站要发生什么事情，完全不知道。所以我说，我喜欢出发。\n\n爱是能力，健康是本钱。成功是努力的奖品；失败，没有这个字。考试落榜的弟妹们，记住了，一场付出代价的失败，就是另一种成功。而最重要的，对我，一直支持到今日的，就是：快乐是最大的勇气和智慧。\n\n金钱这东西，在年轻的时候并不是必要的，只要有健康，有希望就好了。何况，我的希望根本不在我会致富。\n\n我觉得一个人追逐金钱，绝对不是只为了“我爱钱”，而是因为他们知道钱后面有它高贵的意义在，而我已经跨越了这一步。衣食住行统统有了之后，金钱对我已经不是很重要了。\n\n秦汉曾经说，他把人生当做一座游戏场，他好比是一个顽童，玩够了就回家。我想现在的我和秦汉差不多——又稍稍差他那么三两步，我终于也变成了一个顽童，在心情上放松了很多，大大方方，从从容容过日子。对，生命到了尽头，天黑了，我也就回家。\n\n## 感受\n\n第一次读三毛的书，觉得这是一个简单又可爱的女孩，控制不住自己地爱哭，平和善良；也很有自己的思想，很酷。真是让我喜欢又羡慕。我也想做这样一个人：有自己的思想，对世界和世人都保持着爱，过一种自己创造快乐和浪漫的生活。\n","source":"_posts/《流星雨》读书笔记.md","raw":"---\ntitle: 《流星雨》读书笔记\ndate: 2019-12-10 20:39:31\ncategories: 读书笔记ReadingNotes\n---\n\n那么流星我把它看为哪一种人呢？我把它看为在我们生命中擦肩而过的，一些可能你今生再也不会碰到的人。\n\n<!--more-->\n\n---\n\n## 摘抄\n\n婚后会有多少的多少的问题，但戴上戒指，心理已有承诺，今生今世，好也好，坏也坏，生也好，死也好，爱就来了，这是一条最方便的路。\n\n那么流行我把它看为哪一种人呢？我把它看为在我们生命中擦肩而过的，一些可能你今生再也不会碰到的人，我将他们叫做流星。\n\n我觉得，我们需要从每一个人自己做起，安定、祥和、亲爱、精诚是我们每一个人应该放在心里的事情，而不是一个口号；我觉得，中国人和中国人之间越来越亲密了，我们不可以因为许多不同的观念或者看法把整个的大环境作一个翻身。\n\n我认为有的时候，人说自己的生活枯燥，是因为你不制造生活的气氛。\n\n我们不要让环境影响我们，要不然的话，我们的喜怒哀乐都被别人控制了，连气候都可以控制我们，我们是怎样软弱的人呢！\n\n生离是什么呢？是重逢的开始呀！\n\n可是在心态上，他还是有对自己生命一种乐观进取的弹性，而他的最可贵是在他的不知不觉。\n\n如果你晚上不愿意回去的话，不要有罪恶感，以为自己是坏人。\n\n世界上的一切地方只要出名都不好玩，你要去的是没有名字的地方，它能够让你感动。\n\n你家的一条巷子有春夏秋冬，月亮阴晴圆缺，你都看不完你的巷子。\n\n当别人都在种小麦的时候，我退出，去种玫瑰花。\n\n如果说你有这个机会，最好是先看资料再走路，将自己的经验去印证书本所说的是不是相同，然后你才再写下个人的感想。\n\n我不说离别，事实上每一次旅程里，出发的时候也象征了告别；但是我喜欢将离别形容为“出发”，它本来就是一体两面的。\n\n不要让自己珍贵的感情到处泛滥，那是不好的，知道如何保护自己是相当重要的事。\n有时候，我也会留下一些自己的感情，把我心里小小一块留在了什么地方。但在这种时候，我就想到，虽然不舍，可是前面有一个未知在等待着我。我留下了东西，可是我也是在迎接未来。于是搭上公共汽车，司机一发动车，收音机一扭转，流行歌曲哗哗地唱起来，看着窗外风景不断过去。我会对自己说：人生是多么美好啊！因为下一站要发生什么事情，完全不知道。所以我说，我喜欢出发。\n\n爱是能力，健康是本钱。成功是努力的奖品；失败，没有这个字。考试落榜的弟妹们，记住了，一场付出代价的失败，就是另一种成功。而最重要的，对我，一直支持到今日的，就是：快乐是最大的勇气和智慧。\n\n金钱这东西，在年轻的时候并不是必要的，只要有健康，有希望就好了。何况，我的希望根本不在我会致富。\n\n我觉得一个人追逐金钱，绝对不是只为了“我爱钱”，而是因为他们知道钱后面有它高贵的意义在，而我已经跨越了这一步。衣食住行统统有了之后，金钱对我已经不是很重要了。\n\n秦汉曾经说，他把人生当做一座游戏场，他好比是一个顽童，玩够了就回家。我想现在的我和秦汉差不多——又稍稍差他那么三两步，我终于也变成了一个顽童，在心情上放松了很多，大大方方，从从容容过日子。对，生命到了尽头，天黑了，我也就回家。\n\n## 感受\n\n第一次读三毛的书，觉得这是一个简单又可爱的女孩，控制不住自己地爱哭，平和善良；也很有自己的思想，很酷。真是让我喜欢又羡慕。我也想做这样一个人：有自己的思想，对世界和世人都保持着爱，过一种自己创造快乐和浪漫的生活。\n","slug":"《流星雨》读书笔记","published":1,"updated":"2019-12-10T12:39:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeagh0001z38t4en2dhju1","content":"<p>那么流星我把它看为哪一种人呢？我把它看为在我们生命中擦肩而过的，一些可能你今生再也不会碰到的人。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"摘抄\"><a href=\"#摘抄\" class=\"headerlink\" title=\"摘抄\"></a>摘抄</h2><p>婚后会有多少的多少的问题，但戴上戒指，心理已有承诺，今生今世，好也好，坏也坏，生也好，死也好，爱就来了，这是一条最方便的路。</p>\n<p>那么流行我把它看为哪一种人呢？我把它看为在我们生命中擦肩而过的，一些可能你今生再也不会碰到的人，我将他们叫做流星。</p>\n<p>我觉得，我们需要从每一个人自己做起，安定、祥和、亲爱、精诚是我们每一个人应该放在心里的事情，而不是一个口号；我觉得，中国人和中国人之间越来越亲密了，我们不可以因为许多不同的观念或者看法把整个的大环境作一个翻身。</p>\n<p>我认为有的时候，人说自己的生活枯燥，是因为你不制造生活的气氛。</p>\n<p>我们不要让环境影响我们，要不然的话，我们的喜怒哀乐都被别人控制了，连气候都可以控制我们，我们是怎样软弱的人呢！</p>\n<p>生离是什么呢？是重逢的开始呀！</p>\n<p>可是在心态上，他还是有对自己生命一种乐观进取的弹性，而他的最可贵是在他的不知不觉。</p>\n<p>如果你晚上不愿意回去的话，不要有罪恶感，以为自己是坏人。</p>\n<p>世界上的一切地方只要出名都不好玩，你要去的是没有名字的地方，它能够让你感动。</p>\n<p>你家的一条巷子有春夏秋冬，月亮阴晴圆缺，你都看不完你的巷子。</p>\n<p>当别人都在种小麦的时候，我退出，去种玫瑰花。</p>\n<p>如果说你有这个机会，最好是先看资料再走路，将自己的经验去印证书本所说的是不是相同，然后你才再写下个人的感想。</p>\n<p>我不说离别，事实上每一次旅程里，出发的时候也象征了告别；但是我喜欢将离别形容为“出发”，它本来就是一体两面的。</p>\n<p>不要让自己珍贵的感情到处泛滥，那是不好的，知道如何保护自己是相当重要的事。<br>有时候，我也会留下一些自己的感情，把我心里小小一块留在了什么地方。但在这种时候，我就想到，虽然不舍，可是前面有一个未知在等待着我。我留下了东西，可是我也是在迎接未来。于是搭上公共汽车，司机一发动车，收音机一扭转，流行歌曲哗哗地唱起来，看着窗外风景不断过去。我会对自己说：人生是多么美好啊！因为下一站要发生什么事情，完全不知道。所以我说，我喜欢出发。</p>\n<p>爱是能力，健康是本钱。成功是努力的奖品；失败，没有这个字。考试落榜的弟妹们，记住了，一场付出代价的失败，就是另一种成功。而最重要的，对我，一直支持到今日的，就是：快乐是最大的勇气和智慧。</p>\n<p>金钱这东西，在年轻的时候并不是必要的，只要有健康，有希望就好了。何况，我的希望根本不在我会致富。</p>\n<p>我觉得一个人追逐金钱，绝对不是只为了“我爱钱”，而是因为他们知道钱后面有它高贵的意义在，而我已经跨越了这一步。衣食住行统统有了之后，金钱对我已经不是很重要了。</p>\n<p>秦汉曾经说，他把人生当做一座游戏场，他好比是一个顽童，玩够了就回家。我想现在的我和秦汉差不多——又稍稍差他那么三两步，我终于也变成了一个顽童，在心情上放松了很多，大大方方，从从容容过日子。对，生命到了尽头，天黑了，我也就回家。</p>\n<h2 id=\"感受\"><a href=\"#感受\" class=\"headerlink\" title=\"感受\"></a>感受</h2><p>第一次读三毛的书，觉得这是一个简单又可爱的女孩，控制不住自己地爱哭，平和善良；也很有自己的思想，很酷。真是让我喜欢又羡慕。我也想做这样一个人：有自己的思想，对世界和世人都保持着爱，过一种自己创造快乐和浪漫的生活。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>那么流星我把它看为哪一种人呢？我把它看为在我们生命中擦肩而过的，一些可能你今生再也不会碰到的人。</p>","more":"<hr>\n<h2 id=\"摘抄\"><a href=\"#摘抄\" class=\"headerlink\" title=\"摘抄\"></a>摘抄</h2><p>婚后会有多少的多少的问题，但戴上戒指，心理已有承诺，今生今世，好也好，坏也坏，生也好，死也好，爱就来了，这是一条最方便的路。</p>\n<p>那么流行我把它看为哪一种人呢？我把它看为在我们生命中擦肩而过的，一些可能你今生再也不会碰到的人，我将他们叫做流星。</p>\n<p>我觉得，我们需要从每一个人自己做起，安定、祥和、亲爱、精诚是我们每一个人应该放在心里的事情，而不是一个口号；我觉得，中国人和中国人之间越来越亲密了，我们不可以因为许多不同的观念或者看法把整个的大环境作一个翻身。</p>\n<p>我认为有的时候，人说自己的生活枯燥，是因为你不制造生活的气氛。</p>\n<p>我们不要让环境影响我们，要不然的话，我们的喜怒哀乐都被别人控制了，连气候都可以控制我们，我们是怎样软弱的人呢！</p>\n<p>生离是什么呢？是重逢的开始呀！</p>\n<p>可是在心态上，他还是有对自己生命一种乐观进取的弹性，而他的最可贵是在他的不知不觉。</p>\n<p>如果你晚上不愿意回去的话，不要有罪恶感，以为自己是坏人。</p>\n<p>世界上的一切地方只要出名都不好玩，你要去的是没有名字的地方，它能够让你感动。</p>\n<p>你家的一条巷子有春夏秋冬，月亮阴晴圆缺，你都看不完你的巷子。</p>\n<p>当别人都在种小麦的时候，我退出，去种玫瑰花。</p>\n<p>如果说你有这个机会，最好是先看资料再走路，将自己的经验去印证书本所说的是不是相同，然后你才再写下个人的感想。</p>\n<p>我不说离别，事实上每一次旅程里，出发的时候也象征了告别；但是我喜欢将离别形容为“出发”，它本来就是一体两面的。</p>\n<p>不要让自己珍贵的感情到处泛滥，那是不好的，知道如何保护自己是相当重要的事。<br>有时候，我也会留下一些自己的感情，把我心里小小一块留在了什么地方。但在这种时候，我就想到，虽然不舍，可是前面有一个未知在等待着我。我留下了东西，可是我也是在迎接未来。于是搭上公共汽车，司机一发动车，收音机一扭转，流行歌曲哗哗地唱起来，看着窗外风景不断过去。我会对自己说：人生是多么美好啊！因为下一站要发生什么事情，完全不知道。所以我说，我喜欢出发。</p>\n<p>爱是能力，健康是本钱。成功是努力的奖品；失败，没有这个字。考试落榜的弟妹们，记住了，一场付出代价的失败，就是另一种成功。而最重要的，对我，一直支持到今日的，就是：快乐是最大的勇气和智慧。</p>\n<p>金钱这东西，在年轻的时候并不是必要的，只要有健康，有希望就好了。何况，我的希望根本不在我会致富。</p>\n<p>我觉得一个人追逐金钱，绝对不是只为了“我爱钱”，而是因为他们知道钱后面有它高贵的意义在，而我已经跨越了这一步。衣食住行统统有了之后，金钱对我已经不是很重要了。</p>\n<p>秦汉曾经说，他把人生当做一座游戏场，他好比是一个顽童，玩够了就回家。我想现在的我和秦汉差不多——又稍稍差他那么三两步，我终于也变成了一个顽童，在心情上放松了很多，大大方方，从从容容过日子。对，生命到了尽头，天黑了，我也就回家。</p>\n<h2 id=\"感受\"><a href=\"#感受\" class=\"headerlink\" title=\"感受\"></a>感受</h2><p>第一次读三毛的书，觉得这是一个简单又可爱的女孩，控制不住自己地爱哭，平和善良；也很有自己的思想，很酷。真是让我喜欢又羡慕。我也想做这样一个人：有自己的思想，对世界和世人都保持着爱，过一种自己创造快乐和浪漫的生活。</p>"},{"title":"三月观影读书","date":"2020-04-07T14:36:59.000Z","_content":"\n三体Ⅲ、阿Q正传、第二性、你当像鸟飞往你的山、我的天才女友、梨泰院class\n\n<!--more-->\n\n## 三体Ⅲ\n\n正如我之前说的，这一部比前两部都更吸引我。最后书中呈现出的景象与现在的地球，现在的宇宙相比，都已经面目全非。\n穿过了一千八百多万年的岁月，我有一种超然的感觉，像书里说的“以上帝视角看蚁穴”。人的一生终究是短暂而渺小的。在我们的时间尺度中漫长的一生，在宇宙的时间尺度中只是比眨眼更微小的瞬间。有些人的存在，改变了历史走向；而大多数人的存在，最后也只会被遗忘。对于宇宙之神来说不重要的瞬间，却是我的全部。\n\n大家都骂程心，我觉得她每一个引导文明走向灭亡的选择，都不全 是她的错。以当时的情况而言，谁也不一定都能做出最好的选择。我也不能说喜欢这个角色，只是不讨厌。想起三体Ⅱ的豆瓣短评，说大刘笔下的女性角色都这么蠢，我感觉到了...\n\n还有程心和关一帆走在一起，而AA和云天明走在一起，这样的结局是有点意外的，莫名其妙的？\n\n书里好几个点展开一下又是一本书，很期待这个系列的续作，虽然不知道会不会有。\n\n\n## 阿Q正传\n\n阿Q啊，就是一个普普通通又没什么文化的人。但是他也一心想要变好的，但又不太懂，只能想着法子去学别人的样，又加上自己寻思出来的办法。他虽如此，也是很有自尊的，绝不想被人欺负，也不想被人看扁，就是不会写字要在纸上画圆，也一定要卯足了劲地把圆画圆了。即使要死了，也要继续着“精神胜利法”聊以自慰。\n\n若他死后还能听见人们纷纷的议论，大抵也会想：人生天地间，大约本来有时也未免...\n\n站在阿Q的角度看他经历的所有事情，所有感觉都不一样了。全篇没有一处明写“苦”，但我读来怎么这么苦呢...对于社会，只是一个草民被枪毙了，对于旁人，也只是阿Q一定干了什么坏事被枪毙了，而对于阿Q，到底为什么要被枪毙呢？也不知道原因，寻思着人生大概本来也就是这样的吧。\n\n好苦好苦，我说不出来。\n\n在刚开始看书的时候，我也会嘲笑阿Q这个人，他的价值观和他的言行。后来他死的时候，我觉得很苦。怎么说呢？我觉得他很无辜，他究竟做错了什么要遭得这样的罪？他即使在临死的时候，也跟平常并无两样。\n我有种感觉，有点文化的人仿佛站在可以随意摆布他的高处。再结合写作背景就更明白一些。国内掀起了革命，却只停留在资产阶级与地主阶级，革命似乎只与这些阶级联系起来，却没有考虑包括农民在内的无产阶级。\n\n## 第二性\n\n什么是女人？女人为什么要被作为他者？从基本的生物学看起，女性深深地受到物种的制约，生育的要求极大地影响着女性的一生，从青春期到更年期。直到更年期后，女人重新获得内分泌上的平衡，表现出全新的活力。\n“在所有雌性哺乳动物中，女人是受到异化程度最高的，并且最激烈地拒绝这种异化。”\n“她要确定自身为个体，要起来反抗命运，所以她的命运显得更为悲苦。”\n但是生物学上的论据并不能作为女人成为他者的原因。也并不能说明男人与女人之间孰优孰劣。它们是不可磨灭的事实，但本身并没有什么意义。在解释原因的时候，我们应该从人出发，从存在出发去界定。\n\n过去我一直觉得更年期的到来，就是女人的结束，为此感到悲哀。现在看来，生育与女人捆绑在一起的思想早就在我的脑子里根深蒂固。从青春期到更年期，女人一直受到无法摆脱的物种制约。\n\n我在我母亲身上看到了根植于我们心中的观念。我越来越感受到自己在成为一个独立的人，站在这样一个角度，母亲的形象越来越清晰。她要从家庭中获得对自身的肯定，她也有作为个体和作为他者之间的挣扎。我有点说不明白，理解也不一定对。但是我真的很心疼她，我们女性都被看上去理所当然却错误腐烂的观念所束缚。\n\n我很小的时候就会想：男孩子做得到的事情，我也要做到。我一直想要证明我们女生可以不比男生差。我也从来没有问过自己：为什么在大家的观念里，女生会比男生差？为什么我要以男生作为自己的目标？为什么我要去成为另一个性别？\n\n读了一半多，因为社科类的书籍，我总是读读就会走神...\n\n## 你当像鸟飞往你的山\n\n“决定你是谁的最强大的因素来自你的内心。”“她只是一个穿着漂亮衣服的伦敦人。知道她相信自己。那时，她穿什么衣服已经无关紧要了。”\n我想起我的小学。我一直在试着成为那种人。但是我觉得我不是。拥有的一切似乎都不应该属于我。\n我突然明白了余华曾经在朗读者里说的：“离开成就了我。”我也明白了，我要离开。我也当像鸟，飞往我的山。\n\n这本书教我这两个道理：拥有**自己**的思想，去评价不同的思想、历史与观点。以及，你有权利追求更好的，而不需要感到羞耻。\n\n摘录几条我感触比较深的几句话：\n“汇而构成人一生的所有决定——人们共同或者独自做出的那些决定，聚合起来，制造了每一桩单独事件。沙粒不可计数，叠压成沉积物，然后成为岩石。”\n“我看到的是一个坚不可摧、像石头一样难以对付的自己。起初我仅仅是让自己相信这一点，直到有一天它变成了现实。然后我才能坦诚地告诉自己，这对我没有影响，因为没有什么可以影响我。我不明白我的这种正确是多么病态，不明白自己是如何掏空了自己。尽管我一直被那晚的后果所困扰，但我误解了最重要的事实：它没有影响我，这本身就是它的影响。”\n“承认不确定性，就是被迫承认自己的软弱和无能，但也意味着你相信你自己。”\n“只有我们自己才能解放我们的思想。”\n“评价多种思想、多种历史和多种观点的能力是自我创造力的核心。”\n“历史是由谁书写的呢？我想，是我。”\n“你可以用很多说法来称呼这个自我：转变，蜕变，虚伪，叛逆。而我称之为：教育。”\n\n\n## 我的天才女友\n\n看完了HBO的两季剧集。角色选人特别棒，没看过原著，但是每一个人的性格都表现得淋漓尽致，小时候和青年时代的角色也有几分相像。\n莱农和莉拉这两个角色我都很喜欢。我心疼莉拉。她天赋过人，有着崇高又坚定的内心。她早就知道自己是庶民，整个城区都是庶民，渴望改变却无法改变。她心中有一块纯净的地方，不以外界为转移。但是她从骨子里散发出自卑，是因为她知道自己缺少教育，自己的眼界都局限在这个街区。\n完全相反的莱农从小就讨人喜爱。她也一样散发出自卑，是因为她从小都在莉拉的影子里。莱农一直在怀疑：我比她更好吗？我有她那么好吗？即使在她决定听从自己内心之后，在看到莉拉的日记时依然觉得恐惧。莉拉的痛苦源自“发现了问题，却无法解决问题”。她聪明有思想，不想做一个庶民，更不想自己的后代依然是庶民。她做出各种选择，希望找到出口，得到改变。\n莱农和莉拉互相成就了对方。这部作品反映的不止是她们二人间的战争与友谊。还有整个社会，包括男权社会中的女性、原生家庭等等。\n\n之后想找到原著来看，看到原著里的一段话，我发现文字表达的内容会比画面更丰富。\n\n## 梨泰院class\n\n一开始一口气看到最新一集，后来看着看着就不香了。\n男主几乎靠着女主一路发展起来，而且这发展得也太顺了吧？结局几乎毫无悬念（但是我还没看）。而且我觉得男女主没有CP感。","source":"_posts/三月观影读书.md","raw":"---\ntitle: 三月观影读书\ndate: 2020-04-07 22:36:59\ncategories: 生活Life\n---\n\n三体Ⅲ、阿Q正传、第二性、你当像鸟飞往你的山、我的天才女友、梨泰院class\n\n<!--more-->\n\n## 三体Ⅲ\n\n正如我之前说的，这一部比前两部都更吸引我。最后书中呈现出的景象与现在的地球，现在的宇宙相比，都已经面目全非。\n穿过了一千八百多万年的岁月，我有一种超然的感觉，像书里说的“以上帝视角看蚁穴”。人的一生终究是短暂而渺小的。在我们的时间尺度中漫长的一生，在宇宙的时间尺度中只是比眨眼更微小的瞬间。有些人的存在，改变了历史走向；而大多数人的存在，最后也只会被遗忘。对于宇宙之神来说不重要的瞬间，却是我的全部。\n\n大家都骂程心，我觉得她每一个引导文明走向灭亡的选择，都不全 是她的错。以当时的情况而言，谁也不一定都能做出最好的选择。我也不能说喜欢这个角色，只是不讨厌。想起三体Ⅱ的豆瓣短评，说大刘笔下的女性角色都这么蠢，我感觉到了...\n\n还有程心和关一帆走在一起，而AA和云天明走在一起，这样的结局是有点意外的，莫名其妙的？\n\n书里好几个点展开一下又是一本书，很期待这个系列的续作，虽然不知道会不会有。\n\n\n## 阿Q正传\n\n阿Q啊，就是一个普普通通又没什么文化的人。但是他也一心想要变好的，但又不太懂，只能想着法子去学别人的样，又加上自己寻思出来的办法。他虽如此，也是很有自尊的，绝不想被人欺负，也不想被人看扁，就是不会写字要在纸上画圆，也一定要卯足了劲地把圆画圆了。即使要死了，也要继续着“精神胜利法”聊以自慰。\n\n若他死后还能听见人们纷纷的议论，大抵也会想：人生天地间，大约本来有时也未免...\n\n站在阿Q的角度看他经历的所有事情，所有感觉都不一样了。全篇没有一处明写“苦”，但我读来怎么这么苦呢...对于社会，只是一个草民被枪毙了，对于旁人，也只是阿Q一定干了什么坏事被枪毙了，而对于阿Q，到底为什么要被枪毙呢？也不知道原因，寻思着人生大概本来也就是这样的吧。\n\n好苦好苦，我说不出来。\n\n在刚开始看书的时候，我也会嘲笑阿Q这个人，他的价值观和他的言行。后来他死的时候，我觉得很苦。怎么说呢？我觉得他很无辜，他究竟做错了什么要遭得这样的罪？他即使在临死的时候，也跟平常并无两样。\n我有种感觉，有点文化的人仿佛站在可以随意摆布他的高处。再结合写作背景就更明白一些。国内掀起了革命，却只停留在资产阶级与地主阶级，革命似乎只与这些阶级联系起来，却没有考虑包括农民在内的无产阶级。\n\n## 第二性\n\n什么是女人？女人为什么要被作为他者？从基本的生物学看起，女性深深地受到物种的制约，生育的要求极大地影响着女性的一生，从青春期到更年期。直到更年期后，女人重新获得内分泌上的平衡，表现出全新的活力。\n“在所有雌性哺乳动物中，女人是受到异化程度最高的，并且最激烈地拒绝这种异化。”\n“她要确定自身为个体，要起来反抗命运，所以她的命运显得更为悲苦。”\n但是生物学上的论据并不能作为女人成为他者的原因。也并不能说明男人与女人之间孰优孰劣。它们是不可磨灭的事实，但本身并没有什么意义。在解释原因的时候，我们应该从人出发，从存在出发去界定。\n\n过去我一直觉得更年期的到来，就是女人的结束，为此感到悲哀。现在看来，生育与女人捆绑在一起的思想早就在我的脑子里根深蒂固。从青春期到更年期，女人一直受到无法摆脱的物种制约。\n\n我在我母亲身上看到了根植于我们心中的观念。我越来越感受到自己在成为一个独立的人，站在这样一个角度，母亲的形象越来越清晰。她要从家庭中获得对自身的肯定，她也有作为个体和作为他者之间的挣扎。我有点说不明白，理解也不一定对。但是我真的很心疼她，我们女性都被看上去理所当然却错误腐烂的观念所束缚。\n\n我很小的时候就会想：男孩子做得到的事情，我也要做到。我一直想要证明我们女生可以不比男生差。我也从来没有问过自己：为什么在大家的观念里，女生会比男生差？为什么我要以男生作为自己的目标？为什么我要去成为另一个性别？\n\n读了一半多，因为社科类的书籍，我总是读读就会走神...\n\n## 你当像鸟飞往你的山\n\n“决定你是谁的最强大的因素来自你的内心。”“她只是一个穿着漂亮衣服的伦敦人。知道她相信自己。那时，她穿什么衣服已经无关紧要了。”\n我想起我的小学。我一直在试着成为那种人。但是我觉得我不是。拥有的一切似乎都不应该属于我。\n我突然明白了余华曾经在朗读者里说的：“离开成就了我。”我也明白了，我要离开。我也当像鸟，飞往我的山。\n\n这本书教我这两个道理：拥有**自己**的思想，去评价不同的思想、历史与观点。以及，你有权利追求更好的，而不需要感到羞耻。\n\n摘录几条我感触比较深的几句话：\n“汇而构成人一生的所有决定——人们共同或者独自做出的那些决定，聚合起来，制造了每一桩单独事件。沙粒不可计数，叠压成沉积物，然后成为岩石。”\n“我看到的是一个坚不可摧、像石头一样难以对付的自己。起初我仅仅是让自己相信这一点，直到有一天它变成了现实。然后我才能坦诚地告诉自己，这对我没有影响，因为没有什么可以影响我。我不明白我的这种正确是多么病态，不明白自己是如何掏空了自己。尽管我一直被那晚的后果所困扰，但我误解了最重要的事实：它没有影响我，这本身就是它的影响。”\n“承认不确定性，就是被迫承认自己的软弱和无能，但也意味着你相信你自己。”\n“只有我们自己才能解放我们的思想。”\n“评价多种思想、多种历史和多种观点的能力是自我创造力的核心。”\n“历史是由谁书写的呢？我想，是我。”\n“你可以用很多说法来称呼这个自我：转变，蜕变，虚伪，叛逆。而我称之为：教育。”\n\n\n## 我的天才女友\n\n看完了HBO的两季剧集。角色选人特别棒，没看过原著，但是每一个人的性格都表现得淋漓尽致，小时候和青年时代的角色也有几分相像。\n莱农和莉拉这两个角色我都很喜欢。我心疼莉拉。她天赋过人，有着崇高又坚定的内心。她早就知道自己是庶民，整个城区都是庶民，渴望改变却无法改变。她心中有一块纯净的地方，不以外界为转移。但是她从骨子里散发出自卑，是因为她知道自己缺少教育，自己的眼界都局限在这个街区。\n完全相反的莱农从小就讨人喜爱。她也一样散发出自卑，是因为她从小都在莉拉的影子里。莱农一直在怀疑：我比她更好吗？我有她那么好吗？即使在她决定听从自己内心之后，在看到莉拉的日记时依然觉得恐惧。莉拉的痛苦源自“发现了问题，却无法解决问题”。她聪明有思想，不想做一个庶民，更不想自己的后代依然是庶民。她做出各种选择，希望找到出口，得到改变。\n莱农和莉拉互相成就了对方。这部作品反映的不止是她们二人间的战争与友谊。还有整个社会，包括男权社会中的女性、原生家庭等等。\n\n之后想找到原著来看，看到原著里的一段话，我发现文字表达的内容会比画面更丰富。\n\n## 梨泰院class\n\n一开始一口气看到最新一集，后来看着看着就不香了。\n男主几乎靠着女主一路发展起来，而且这发展得也太顺了吧？结局几乎毫无悬念（但是我还没看）。而且我觉得男女主没有CP感。","slug":"三月观影读书","published":1,"updated":"2020-04-07T14:36:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeagh1002238t485qu3g18","content":"<p>三体Ⅲ、阿Q正传、第二性、你当像鸟飞往你的山、我的天才女友、梨泰院class</p>\n<span id=\"more\"></span>\n\n<h2 id=\"三体Ⅲ\"><a href=\"#三体Ⅲ\" class=\"headerlink\" title=\"三体Ⅲ\"></a>三体Ⅲ</h2><p>正如我之前说的，这一部比前两部都更吸引我。最后书中呈现出的景象与现在的地球，现在的宇宙相比，都已经面目全非。<br>穿过了一千八百多万年的岁月，我有一种超然的感觉，像书里说的“以上帝视角看蚁穴”。人的一生终究是短暂而渺小的。在我们的时间尺度中漫长的一生，在宇宙的时间尺度中只是比眨眼更微小的瞬间。有些人的存在，改变了历史走向；而大多数人的存在，最后也只会被遗忘。对于宇宙之神来说不重要的瞬间，却是我的全部。</p>\n<p>大家都骂程心，我觉得她每一个引导文明走向灭亡的选择，都不全 是她的错。以当时的情况而言，谁也不一定都能做出最好的选择。我也不能说喜欢这个角色，只是不讨厌。想起三体Ⅱ的豆瓣短评，说大刘笔下的女性角色都这么蠢，我感觉到了…</p>\n<p>还有程心和关一帆走在一起，而AA和云天明走在一起，这样的结局是有点意外的，莫名其妙的？</p>\n<p>书里好几个点展开一下又是一本书，很期待这个系列的续作，虽然不知道会不会有。</p>\n<h2 id=\"阿Q正传\"><a href=\"#阿Q正传\" class=\"headerlink\" title=\"阿Q正传\"></a>阿Q正传</h2><p>阿Q啊，就是一个普普通通又没什么文化的人。但是他也一心想要变好的，但又不太懂，只能想着法子去学别人的样，又加上自己寻思出来的办法。他虽如此，也是很有自尊的，绝不想被人欺负，也不想被人看扁，就是不会写字要在纸上画圆，也一定要卯足了劲地把圆画圆了。即使要死了，也要继续着“精神胜利法”聊以自慰。</p>\n<p>若他死后还能听见人们纷纷的议论，大抵也会想：人生天地间，大约本来有时也未免…</p>\n<p>站在阿Q的角度看他经历的所有事情，所有感觉都不一样了。全篇没有一处明写“苦”，但我读来怎么这么苦呢…对于社会，只是一个草民被枪毙了，对于旁人，也只是阿Q一定干了什么坏事被枪毙了，而对于阿Q，到底为什么要被枪毙呢？也不知道原因，寻思着人生大概本来也就是这样的吧。</p>\n<p>好苦好苦，我说不出来。</p>\n<p>在刚开始看书的时候，我也会嘲笑阿Q这个人，他的价值观和他的言行。后来他死的时候，我觉得很苦。怎么说呢？我觉得他很无辜，他究竟做错了什么要遭得这样的罪？他即使在临死的时候，也跟平常并无两样。<br>我有种感觉，有点文化的人仿佛站在可以随意摆布他的高处。再结合写作背景就更明白一些。国内掀起了革命，却只停留在资产阶级与地主阶级，革命似乎只与这些阶级联系起来，却没有考虑包括农民在内的无产阶级。</p>\n<h2 id=\"第二性\"><a href=\"#第二性\" class=\"headerlink\" title=\"第二性\"></a>第二性</h2><p>什么是女人？女人为什么要被作为他者？从基本的生物学看起，女性深深地受到物种的制约，生育的要求极大地影响着女性的一生，从青春期到更年期。直到更年期后，女人重新获得内分泌上的平衡，表现出全新的活力。<br>“在所有雌性哺乳动物中，女人是受到异化程度最高的，并且最激烈地拒绝这种异化。”<br>“她要确定自身为个体，要起来反抗命运，所以她的命运显得更为悲苦。”<br>但是生物学上的论据并不能作为女人成为他者的原因。也并不能说明男人与女人之间孰优孰劣。它们是不可磨灭的事实，但本身并没有什么意义。在解释原因的时候，我们应该从人出发，从存在出发去界定。</p>\n<p>过去我一直觉得更年期的到来，就是女人的结束，为此感到悲哀。现在看来，生育与女人捆绑在一起的思想早就在我的脑子里根深蒂固。从青春期到更年期，女人一直受到无法摆脱的物种制约。</p>\n<p>我在我母亲身上看到了根植于我们心中的观念。我越来越感受到自己在成为一个独立的人，站在这样一个角度，母亲的形象越来越清晰。她要从家庭中获得对自身的肯定，她也有作为个体和作为他者之间的挣扎。我有点说不明白，理解也不一定对。但是我真的很心疼她，我们女性都被看上去理所当然却错误腐烂的观念所束缚。</p>\n<p>我很小的时候就会想：男孩子做得到的事情，我也要做到。我一直想要证明我们女生可以不比男生差。我也从来没有问过自己：为什么在大家的观念里，女生会比男生差？为什么我要以男生作为自己的目标？为什么我要去成为另一个性别？</p>\n<p>读了一半多，因为社科类的书籍，我总是读读就会走神…</p>\n<h2 id=\"你当像鸟飞往你的山\"><a href=\"#你当像鸟飞往你的山\" class=\"headerlink\" title=\"你当像鸟飞往你的山\"></a>你当像鸟飞往你的山</h2><p>“决定你是谁的最强大的因素来自你的内心。”“她只是一个穿着漂亮衣服的伦敦人。知道她相信自己。那时，她穿什么衣服已经无关紧要了。”<br>我想起我的小学。我一直在试着成为那种人。但是我觉得我不是。拥有的一切似乎都不应该属于我。<br>我突然明白了余华曾经在朗读者里说的：“离开成就了我。”我也明白了，我要离开。我也当像鸟，飞往我的山。</p>\n<p>这本书教我这两个道理：拥有<strong>自己</strong>的思想，去评价不同的思想、历史与观点。以及，你有权利追求更好的，而不需要感到羞耻。</p>\n<p>摘录几条我感触比较深的几句话：<br>“汇而构成人一生的所有决定——人们共同或者独自做出的那些决定，聚合起来，制造了每一桩单独事件。沙粒不可计数，叠压成沉积物，然后成为岩石。”<br>“我看到的是一个坚不可摧、像石头一样难以对付的自己。起初我仅仅是让自己相信这一点，直到有一天它变成了现实。然后我才能坦诚地告诉自己，这对我没有影响，因为没有什么可以影响我。我不明白我的这种正确是多么病态，不明白自己是如何掏空了自己。尽管我一直被那晚的后果所困扰，但我误解了最重要的事实：它没有影响我，这本身就是它的影响。”<br>“承认不确定性，就是被迫承认自己的软弱和无能，但也意味着你相信你自己。”<br>“只有我们自己才能解放我们的思想。”<br>“评价多种思想、多种历史和多种观点的能力是自我创造力的核心。”<br>“历史是由谁书写的呢？我想，是我。”<br>“你可以用很多说法来称呼这个自我：转变，蜕变，虚伪，叛逆。而我称之为：教育。”</p>\n<h2 id=\"我的天才女友\"><a href=\"#我的天才女友\" class=\"headerlink\" title=\"我的天才女友\"></a>我的天才女友</h2><p>看完了HBO的两季剧集。角色选人特别棒，没看过原著，但是每一个人的性格都表现得淋漓尽致，小时候和青年时代的角色也有几分相像。<br>莱农和莉拉这两个角色我都很喜欢。我心疼莉拉。她天赋过人，有着崇高又坚定的内心。她早就知道自己是庶民，整个城区都是庶民，渴望改变却无法改变。她心中有一块纯净的地方，不以外界为转移。但是她从骨子里散发出自卑，是因为她知道自己缺少教育，自己的眼界都局限在这个街区。<br>完全相反的莱农从小就讨人喜爱。她也一样散发出自卑，是因为她从小都在莉拉的影子里。莱农一直在怀疑：我比她更好吗？我有她那么好吗？即使在她决定听从自己内心之后，在看到莉拉的日记时依然觉得恐惧。莉拉的痛苦源自“发现了问题，却无法解决问题”。她聪明有思想，不想做一个庶民，更不想自己的后代依然是庶民。她做出各种选择，希望找到出口，得到改变。<br>莱农和莉拉互相成就了对方。这部作品反映的不止是她们二人间的战争与友谊。还有整个社会，包括男权社会中的女性、原生家庭等等。</p>\n<p>之后想找到原著来看，看到原著里的一段话，我发现文字表达的内容会比画面更丰富。</p>\n<h2 id=\"梨泰院class\"><a href=\"#梨泰院class\" class=\"headerlink\" title=\"梨泰院class\"></a>梨泰院class</h2><p>一开始一口气看到最新一集，后来看着看着就不香了。<br>男主几乎靠着女主一路发展起来，而且这发展得也太顺了吧？结局几乎毫无悬念（但是我还没看）。而且我觉得男女主没有CP感。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>三体Ⅲ、阿Q正传、第二性、你当像鸟飞往你的山、我的天才女友、梨泰院class</p>","more":"<h2 id=\"三体Ⅲ\"><a href=\"#三体Ⅲ\" class=\"headerlink\" title=\"三体Ⅲ\"></a>三体Ⅲ</h2><p>正如我之前说的，这一部比前两部都更吸引我。最后书中呈现出的景象与现在的地球，现在的宇宙相比，都已经面目全非。<br>穿过了一千八百多万年的岁月，我有一种超然的感觉，像书里说的“以上帝视角看蚁穴”。人的一生终究是短暂而渺小的。在我们的时间尺度中漫长的一生，在宇宙的时间尺度中只是比眨眼更微小的瞬间。有些人的存在，改变了历史走向；而大多数人的存在，最后也只会被遗忘。对于宇宙之神来说不重要的瞬间，却是我的全部。</p>\n<p>大家都骂程心，我觉得她每一个引导文明走向灭亡的选择，都不全 是她的错。以当时的情况而言，谁也不一定都能做出最好的选择。我也不能说喜欢这个角色，只是不讨厌。想起三体Ⅱ的豆瓣短评，说大刘笔下的女性角色都这么蠢，我感觉到了…</p>\n<p>还有程心和关一帆走在一起，而AA和云天明走在一起，这样的结局是有点意外的，莫名其妙的？</p>\n<p>书里好几个点展开一下又是一本书，很期待这个系列的续作，虽然不知道会不会有。</p>\n<h2 id=\"阿Q正传\"><a href=\"#阿Q正传\" class=\"headerlink\" title=\"阿Q正传\"></a>阿Q正传</h2><p>阿Q啊，就是一个普普通通又没什么文化的人。但是他也一心想要变好的，但又不太懂，只能想着法子去学别人的样，又加上自己寻思出来的办法。他虽如此，也是很有自尊的，绝不想被人欺负，也不想被人看扁，就是不会写字要在纸上画圆，也一定要卯足了劲地把圆画圆了。即使要死了，也要继续着“精神胜利法”聊以自慰。</p>\n<p>若他死后还能听见人们纷纷的议论，大抵也会想：人生天地间，大约本来有时也未免…</p>\n<p>站在阿Q的角度看他经历的所有事情，所有感觉都不一样了。全篇没有一处明写“苦”，但我读来怎么这么苦呢…对于社会，只是一个草民被枪毙了，对于旁人，也只是阿Q一定干了什么坏事被枪毙了，而对于阿Q，到底为什么要被枪毙呢？也不知道原因，寻思着人生大概本来也就是这样的吧。</p>\n<p>好苦好苦，我说不出来。</p>\n<p>在刚开始看书的时候，我也会嘲笑阿Q这个人，他的价值观和他的言行。后来他死的时候，我觉得很苦。怎么说呢？我觉得他很无辜，他究竟做错了什么要遭得这样的罪？他即使在临死的时候，也跟平常并无两样。<br>我有种感觉，有点文化的人仿佛站在可以随意摆布他的高处。再结合写作背景就更明白一些。国内掀起了革命，却只停留在资产阶级与地主阶级，革命似乎只与这些阶级联系起来，却没有考虑包括农民在内的无产阶级。</p>\n<h2 id=\"第二性\"><a href=\"#第二性\" class=\"headerlink\" title=\"第二性\"></a>第二性</h2><p>什么是女人？女人为什么要被作为他者？从基本的生物学看起，女性深深地受到物种的制约，生育的要求极大地影响着女性的一生，从青春期到更年期。直到更年期后，女人重新获得内分泌上的平衡，表现出全新的活力。<br>“在所有雌性哺乳动物中，女人是受到异化程度最高的，并且最激烈地拒绝这种异化。”<br>“她要确定自身为个体，要起来反抗命运，所以她的命运显得更为悲苦。”<br>但是生物学上的论据并不能作为女人成为他者的原因。也并不能说明男人与女人之间孰优孰劣。它们是不可磨灭的事实，但本身并没有什么意义。在解释原因的时候，我们应该从人出发，从存在出发去界定。</p>\n<p>过去我一直觉得更年期的到来，就是女人的结束，为此感到悲哀。现在看来，生育与女人捆绑在一起的思想早就在我的脑子里根深蒂固。从青春期到更年期，女人一直受到无法摆脱的物种制约。</p>\n<p>我在我母亲身上看到了根植于我们心中的观念。我越来越感受到自己在成为一个独立的人，站在这样一个角度，母亲的形象越来越清晰。她要从家庭中获得对自身的肯定，她也有作为个体和作为他者之间的挣扎。我有点说不明白，理解也不一定对。但是我真的很心疼她，我们女性都被看上去理所当然却错误腐烂的观念所束缚。</p>\n<p>我很小的时候就会想：男孩子做得到的事情，我也要做到。我一直想要证明我们女生可以不比男生差。我也从来没有问过自己：为什么在大家的观念里，女生会比男生差？为什么我要以男生作为自己的目标？为什么我要去成为另一个性别？</p>\n<p>读了一半多，因为社科类的书籍，我总是读读就会走神…</p>\n<h2 id=\"你当像鸟飞往你的山\"><a href=\"#你当像鸟飞往你的山\" class=\"headerlink\" title=\"你当像鸟飞往你的山\"></a>你当像鸟飞往你的山</h2><p>“决定你是谁的最强大的因素来自你的内心。”“她只是一个穿着漂亮衣服的伦敦人。知道她相信自己。那时，她穿什么衣服已经无关紧要了。”<br>我想起我的小学。我一直在试着成为那种人。但是我觉得我不是。拥有的一切似乎都不应该属于我。<br>我突然明白了余华曾经在朗读者里说的：“离开成就了我。”我也明白了，我要离开。我也当像鸟，飞往我的山。</p>\n<p>这本书教我这两个道理：拥有<strong>自己</strong>的思想，去评价不同的思想、历史与观点。以及，你有权利追求更好的，而不需要感到羞耻。</p>\n<p>摘录几条我感触比较深的几句话：<br>“汇而构成人一生的所有决定——人们共同或者独自做出的那些决定，聚合起来，制造了每一桩单独事件。沙粒不可计数，叠压成沉积物，然后成为岩石。”<br>“我看到的是一个坚不可摧、像石头一样难以对付的自己。起初我仅仅是让自己相信这一点，直到有一天它变成了现实。然后我才能坦诚地告诉自己，这对我没有影响，因为没有什么可以影响我。我不明白我的这种正确是多么病态，不明白自己是如何掏空了自己。尽管我一直被那晚的后果所困扰，但我误解了最重要的事实：它没有影响我，这本身就是它的影响。”<br>“承认不确定性，就是被迫承认自己的软弱和无能，但也意味着你相信你自己。”<br>“只有我们自己才能解放我们的思想。”<br>“评价多种思想、多种历史和多种观点的能力是自我创造力的核心。”<br>“历史是由谁书写的呢？我想，是我。”<br>“你可以用很多说法来称呼这个自我：转变，蜕变，虚伪，叛逆。而我称之为：教育。”</p>\n<h2 id=\"我的天才女友\"><a href=\"#我的天才女友\" class=\"headerlink\" title=\"我的天才女友\"></a>我的天才女友</h2><p>看完了HBO的两季剧集。角色选人特别棒，没看过原著，但是每一个人的性格都表现得淋漓尽致，小时候和青年时代的角色也有几分相像。<br>莱农和莉拉这两个角色我都很喜欢。我心疼莉拉。她天赋过人，有着崇高又坚定的内心。她早就知道自己是庶民，整个城区都是庶民，渴望改变却无法改变。她心中有一块纯净的地方，不以外界为转移。但是她从骨子里散发出自卑，是因为她知道自己缺少教育，自己的眼界都局限在这个街区。<br>完全相反的莱农从小就讨人喜爱。她也一样散发出自卑，是因为她从小都在莉拉的影子里。莱农一直在怀疑：我比她更好吗？我有她那么好吗？即使在她决定听从自己内心之后，在看到莉拉的日记时依然觉得恐惧。莉拉的痛苦源自“发现了问题，却无法解决问题”。她聪明有思想，不想做一个庶民，更不想自己的后代依然是庶民。她做出各种选择，希望找到出口，得到改变。<br>莱农和莉拉互相成就了对方。这部作品反映的不止是她们二人间的战争与友谊。还有整个社会，包括男权社会中的女性、原生家庭等等。</p>\n<p>之后想找到原著来看，看到原著里的一段话，我发现文字表达的内容会比画面更丰富。</p>\n<h2 id=\"梨泰院class\"><a href=\"#梨泰院class\" class=\"headerlink\" title=\"梨泰院class\"></a>梨泰院class</h2><p>一开始一口气看到最新一集，后来看着看着就不香了。<br>男主几乎靠着女主一路发展起来，而且这发展得也太顺了吧？结局几乎毫无悬念（但是我还没看）。而且我觉得男女主没有CP感。</p>"},{"title":"九月观影看书","date":"2019-10-09T03:48:38.000Z","_content":"\n《罗小黑战记》、《三体Ⅰ 地球往事》、《浪漫的体质》、《Begin Again》、《七月与安生》\n\n<!--more-->\n\n---\n\n## 写在前面\n\n推荐《Begin Again》、《浪漫的体质》、《三体》。《罗小黑战记》也推荐，但受众可能比较小，可以尝试欣赏一下2D的打戏和场景制作。\n\n## 罗小黑战记\n\n和同学在上映第一天就去看了。八年更了28集（每集5-7分钟）的国漫居然出电影了。看前还看了一下动画版的《罗小黑战记》。事实上，不管是不是粉丝，都能欣赏到电影。\n电影画面是**2D**的，除了大场景（如城市与市民）用了3D建模。画面很流畅的，尤其是**打戏**部分。电影中打戏部分一点也没有偷工减料，镜头转换也做得很好。（这个在动画中也是，棒！）**场景**画面的设计和绘制也很精致，不管是在森林，在海面上，还是后面风息和无限打斗的商场。\n关于情节，我觉得有的地方没有交代清楚，有一点瑕疵，又或者是我没看好。关于小黑的“领域”，风息的故事线等。另外，我觉得编剧有想强调妖与人共生的问题，也想强调善恶价值观的问题，主题都挺好的，但是很模糊，没有一种主题突出和升华，引人思考的感觉。缺了一点点深度。\n都是个人感觉，但是**小黑好可爱，无限好帅**！！~~我要做无限身上的金属片！~~\n\n## 三体Ⅰ\n\n久仰大名！终于读了第一部。也是第一次真正地读科幻小说。书中描绘的三体世界尤其震撼。不管是三体游戏，还是三体世界，都充满想象力。但是这天马行空的**想象**又让人能感到一点**真实**，作者的文字和读者的想象力就是马良的神笔，读来有种身临其境的感觉。这是科幻小说最吸引人的地方之一，精心的描绘让读者有足够的空间去想象，构造自己脑海中三体世界的样子。\n另外最吸引人的地方就是关于**人性与道德**的讨论和思考。人类中衍生出的异己群体，三体文明中也有着像1379号监听员那样的存在。当外星势力侵略时，末日降临时，人们表现出不同的态度。主要体现在高级知识分子和普通百姓，三体组织的三大派系。\n而每一个变成异己的人都必定有其特别的经历，书中就以叶文洁为代表，另外还有伊文斯加以佐证。这里体现了作者写作的手法。作者在场景描绘上也是手法巧妙。我印象最深的是当使用纳米材料对“审判日”号采取行动时，那个细节的描述很震撼。\n还有最吸引的地方一定是**对宇宙的思考和疑问**。就目前所知，我们是宇宙中一颗孤独的星球，而人们也从来没有停止过对外星生命的探索。外星智慧生命会是一种怎样的存在，如果真的收到了外星讯息我们会发生什么，这发人深思。书中关于维度的描述也引人思考：是否存在别的宇宙？我们身处的宇宙对于一个更高级的文明而言，是否就像虫子对于我们而言？\n想起叶文洁对汪淼说过的一句话：**“有时觉得生命真珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值得一提。”**\n补充一点新的想法。对于三体文明而言，我们是低级的物种。在地球上，我们是作为食物链顶端的人类，很少去考虑更为低级的生命物种。生命真的是平等的吗？如果是，那又何为**平等**？\n\n## 浪漫的体质\n\n值得二刷，剧中金句的密集度极高。作为一个还未步入社会的学生，可能共鸣会更少一点，就像剧中主角都是步入三十的一样，这个岁数的人看会更有感触一些吧。\n那么作为一个二十一岁的人，看着自己再过几年就会步入的生活，下面是我的Ideas。\n生活中会有诸多不如意，职场、感情、家庭等等，虽没有了二十岁的风风火火，但也没有了二十岁的稚嫩。面对烦恼已经习以为常，也能说出些人生道理，不会再轻易流泪，但还是会和朋友们去吐槽。\n“到了三十岁就会好起来”，到底是什么会好起来呢？年轻时候的所有经历变成经验，那些流下的眼泪，背负着的痛苦，都慢慢习惯。生活有变好起来吗？好像也没有，糟心事还是一件接着一件。但是慢慢习惯了，也明白了自己要的是什么。\n对于寒珠的变化，我印象很深。当初离婚时，她问丈夫：“那我的幸福怎么办？”后来前夫又找到她希望复合时，她说出了：“我是不会依赖男人来得到幸福。”\n看完了结局，最后每一个人的结局都有不同，这才更像是真实的生活。最后大家都离开了这个房子，没有太多伤感，只是如同平日一样聊天。时间让我们学会了：**不管遇到什么事，都要往前看，都会变好的**。\n\n## Begin Again\n\n冲着《Lost Stars》来看的电影。\n打9分。很喜欢这部电影，非常治愈。特别喜欢它的结局，女主谁也没有选，告诉我们还有第三种选择：**自己**。没有回到Dave的身边，也没有迷恋与Dan的短暂火花。看着最后Gretta一个人在纽约的灯光下骑着单车，心里有点沸腾，忍不住跟着她一起笑了。看到豆瓣一个影评（@Miss歪）：最想成为的女生不是《律政俏佳人》里的Elle Woods，也不是《公主日记》里的Mia。是呀，不是所有女生都有那样的运气和背景，倒是更想成为像Gretta这样的坚强率真又可爱的女生。**去选择自己的人生，去勇敢追求未来，勇敢告别过去。**\n很喜欢中间在纽约到处取景录歌的片段，太欢乐了！看得我非常想去学写歌，学乐器。\n饰演女主的Keria Knightly也太美了。每一套衣服都好适合她，像个干瘦的假小子，又带着女性专属的率性和气质。性格特点都很符合，但我觉得差一点音乐人的气质，毕竟KK也不是专业歌手。\n啊还有演Dan的Mark，这迷人的气质到底是哪里来的？快点停止散发你那该死的魅力！是我，我都不敢直视他的眼睛，他的眼睛也太会说话了~~（开始做梦）~~。跟女主待一起时我总觉得下一秒就要吻上去！（还好没吻，不然剧情有点跑偏。）\n骚当也意外合适，没有出戏的感觉。\n另，关于Dave写歌给别的女生，女主听一半就一耳光扇过去。后来我想明白了，不是从歌里听出来的，而是Dave躲闪的眼神，恋爱中的女生都是mind reader。\n**啊我真是好喜欢这部电影！**\n也很喜欢《Lost Stars》，两个版本就是两首歌，都很喜欢。\n> \nYouth is wasted on the young\nIt's hunting season and this lamb is on the run\nWe are searching for meaning\nBut are we all lost stars\ntrying to light up the dark\nWho are we\nJust a speck of dust within the galaxy\nWoe is me\nIf we're not careful turns into reality\n\n## 七月与安生\n\n其实看之前我还以为是一部同性电影呢...没想到是闺蜜同时喜欢上一个男人的剧情。\n我给它打7分。先说**不喜欢的地方**，主要是**剧情**。我觉得剧情有一点**狗血**，比如喜欢上同一个男人，安生把男生让给七月，家明喜欢上了安生，家明与安生的重逢，家明逃婚，七月死于产后大出血等等。这些在影视作品中也太寻常了，但是在生活中却又好像不太寻常。但是这样狗血的剧情跟这个故事还挺搭。\n再说说**喜欢的地方**，首先是**女生间的感情刻画**。那种**细腻**可能是只有女生才能体会到。感情深到一定程度后，虽然会撕X会吵架，但事后又为自己的所作所为后悔，再次相遇一个拥抱能化解冰块。两个背景性格都极为不同的女生的友情中，除了真心为对方好，也一定有羡慕、嫉妒甚至恨。**又因为爱，而讨厌那个嫉妒对方的自己。**\n其次是周冬雨和马思纯的**演技**，不愧是拿下了金马影后，两个人都很适合她们的角色。\n最后再**简单聊聊故事**。最后结局的反转让我很意外，也很难过，在半夜看哭了。这个故事里三个人都是受害者，它从一开始就决定了是个悲剧。这个故事告诉我们，不管是关系多么好的朋友，两个人始终应该是独立的个体。七月是安生的影子，安生也是七月的影子，两个人从相遇开始，就一直想要成为对方。\n家明也是个受害者。背了逃婚的锅，为了成全七月。心里装了两个人，最后谁的爱也没有得到。但是这个男人太没有担当了啊，什么也不说清楚，两边都不给个明白话，就打算顺水推舟和七月结婚，一首《算什么男人》送给他。\n另，日漫《NANA》也是讲的两个女生之间的故事，悲剧收场，有点像。\n\n## 碎碎念。\n\n九月的电影目标达成，读书目标还差一本，十月努力达成目标吧。\n不是很会写影评和书评，但是**“如果不去写的话，那就连垃圾也写不出来。”**不好意思啦亲爱的读者，可能让你读了一篇垃圾...但我还是会努力的。\n","source":"_posts/九月观影看书.md","raw":"---\ntitle: 九月观影看书\ndate: 2019-10-09 11:48:38\ncategories: 生活Life\n\n---\n\n《罗小黑战记》、《三体Ⅰ 地球往事》、《浪漫的体质》、《Begin Again》、《七月与安生》\n\n<!--more-->\n\n---\n\n## 写在前面\n\n推荐《Begin Again》、《浪漫的体质》、《三体》。《罗小黑战记》也推荐，但受众可能比较小，可以尝试欣赏一下2D的打戏和场景制作。\n\n## 罗小黑战记\n\n和同学在上映第一天就去看了。八年更了28集（每集5-7分钟）的国漫居然出电影了。看前还看了一下动画版的《罗小黑战记》。事实上，不管是不是粉丝，都能欣赏到电影。\n电影画面是**2D**的，除了大场景（如城市与市民）用了3D建模。画面很流畅的，尤其是**打戏**部分。电影中打戏部分一点也没有偷工减料，镜头转换也做得很好。（这个在动画中也是，棒！）**场景**画面的设计和绘制也很精致，不管是在森林，在海面上，还是后面风息和无限打斗的商场。\n关于情节，我觉得有的地方没有交代清楚，有一点瑕疵，又或者是我没看好。关于小黑的“领域”，风息的故事线等。另外，我觉得编剧有想强调妖与人共生的问题，也想强调善恶价值观的问题，主题都挺好的，但是很模糊，没有一种主题突出和升华，引人思考的感觉。缺了一点点深度。\n都是个人感觉，但是**小黑好可爱，无限好帅**！！~~我要做无限身上的金属片！~~\n\n## 三体Ⅰ\n\n久仰大名！终于读了第一部。也是第一次真正地读科幻小说。书中描绘的三体世界尤其震撼。不管是三体游戏，还是三体世界，都充满想象力。但是这天马行空的**想象**又让人能感到一点**真实**，作者的文字和读者的想象力就是马良的神笔，读来有种身临其境的感觉。这是科幻小说最吸引人的地方之一，精心的描绘让读者有足够的空间去想象，构造自己脑海中三体世界的样子。\n另外最吸引人的地方就是关于**人性与道德**的讨论和思考。人类中衍生出的异己群体，三体文明中也有着像1379号监听员那样的存在。当外星势力侵略时，末日降临时，人们表现出不同的态度。主要体现在高级知识分子和普通百姓，三体组织的三大派系。\n而每一个变成异己的人都必定有其特别的经历，书中就以叶文洁为代表，另外还有伊文斯加以佐证。这里体现了作者写作的手法。作者在场景描绘上也是手法巧妙。我印象最深的是当使用纳米材料对“审判日”号采取行动时，那个细节的描述很震撼。\n还有最吸引的地方一定是**对宇宙的思考和疑问**。就目前所知，我们是宇宙中一颗孤独的星球，而人们也从来没有停止过对外星生命的探索。外星智慧生命会是一种怎样的存在，如果真的收到了外星讯息我们会发生什么，这发人深思。书中关于维度的描述也引人思考：是否存在别的宇宙？我们身处的宇宙对于一个更高级的文明而言，是否就像虫子对于我们而言？\n想起叶文洁对汪淼说过的一句话：**“有时觉得生命真珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值得一提。”**\n补充一点新的想法。对于三体文明而言，我们是低级的物种。在地球上，我们是作为食物链顶端的人类，很少去考虑更为低级的生命物种。生命真的是平等的吗？如果是，那又何为**平等**？\n\n## 浪漫的体质\n\n值得二刷，剧中金句的密集度极高。作为一个还未步入社会的学生，可能共鸣会更少一点，就像剧中主角都是步入三十的一样，这个岁数的人看会更有感触一些吧。\n那么作为一个二十一岁的人，看着自己再过几年就会步入的生活，下面是我的Ideas。\n生活中会有诸多不如意，职场、感情、家庭等等，虽没有了二十岁的风风火火，但也没有了二十岁的稚嫩。面对烦恼已经习以为常，也能说出些人生道理，不会再轻易流泪，但还是会和朋友们去吐槽。\n“到了三十岁就会好起来”，到底是什么会好起来呢？年轻时候的所有经历变成经验，那些流下的眼泪，背负着的痛苦，都慢慢习惯。生活有变好起来吗？好像也没有，糟心事还是一件接着一件。但是慢慢习惯了，也明白了自己要的是什么。\n对于寒珠的变化，我印象很深。当初离婚时，她问丈夫：“那我的幸福怎么办？”后来前夫又找到她希望复合时，她说出了：“我是不会依赖男人来得到幸福。”\n看完了结局，最后每一个人的结局都有不同，这才更像是真实的生活。最后大家都离开了这个房子，没有太多伤感，只是如同平日一样聊天。时间让我们学会了：**不管遇到什么事，都要往前看，都会变好的**。\n\n## Begin Again\n\n冲着《Lost Stars》来看的电影。\n打9分。很喜欢这部电影，非常治愈。特别喜欢它的结局，女主谁也没有选，告诉我们还有第三种选择：**自己**。没有回到Dave的身边，也没有迷恋与Dan的短暂火花。看着最后Gretta一个人在纽约的灯光下骑着单车，心里有点沸腾，忍不住跟着她一起笑了。看到豆瓣一个影评（@Miss歪）：最想成为的女生不是《律政俏佳人》里的Elle Woods，也不是《公主日记》里的Mia。是呀，不是所有女生都有那样的运气和背景，倒是更想成为像Gretta这样的坚强率真又可爱的女生。**去选择自己的人生，去勇敢追求未来，勇敢告别过去。**\n很喜欢中间在纽约到处取景录歌的片段，太欢乐了！看得我非常想去学写歌，学乐器。\n饰演女主的Keria Knightly也太美了。每一套衣服都好适合她，像个干瘦的假小子，又带着女性专属的率性和气质。性格特点都很符合，但我觉得差一点音乐人的气质，毕竟KK也不是专业歌手。\n啊还有演Dan的Mark，这迷人的气质到底是哪里来的？快点停止散发你那该死的魅力！是我，我都不敢直视他的眼睛，他的眼睛也太会说话了~~（开始做梦）~~。跟女主待一起时我总觉得下一秒就要吻上去！（还好没吻，不然剧情有点跑偏。）\n骚当也意外合适，没有出戏的感觉。\n另，关于Dave写歌给别的女生，女主听一半就一耳光扇过去。后来我想明白了，不是从歌里听出来的，而是Dave躲闪的眼神，恋爱中的女生都是mind reader。\n**啊我真是好喜欢这部电影！**\n也很喜欢《Lost Stars》，两个版本就是两首歌，都很喜欢。\n> \nYouth is wasted on the young\nIt's hunting season and this lamb is on the run\nWe are searching for meaning\nBut are we all lost stars\ntrying to light up the dark\nWho are we\nJust a speck of dust within the galaxy\nWoe is me\nIf we're not careful turns into reality\n\n## 七月与安生\n\n其实看之前我还以为是一部同性电影呢...没想到是闺蜜同时喜欢上一个男人的剧情。\n我给它打7分。先说**不喜欢的地方**，主要是**剧情**。我觉得剧情有一点**狗血**，比如喜欢上同一个男人，安生把男生让给七月，家明喜欢上了安生，家明与安生的重逢，家明逃婚，七月死于产后大出血等等。这些在影视作品中也太寻常了，但是在生活中却又好像不太寻常。但是这样狗血的剧情跟这个故事还挺搭。\n再说说**喜欢的地方**，首先是**女生间的感情刻画**。那种**细腻**可能是只有女生才能体会到。感情深到一定程度后，虽然会撕X会吵架，但事后又为自己的所作所为后悔，再次相遇一个拥抱能化解冰块。两个背景性格都极为不同的女生的友情中，除了真心为对方好，也一定有羡慕、嫉妒甚至恨。**又因为爱，而讨厌那个嫉妒对方的自己。**\n其次是周冬雨和马思纯的**演技**，不愧是拿下了金马影后，两个人都很适合她们的角色。\n最后再**简单聊聊故事**。最后结局的反转让我很意外，也很难过，在半夜看哭了。这个故事里三个人都是受害者，它从一开始就决定了是个悲剧。这个故事告诉我们，不管是关系多么好的朋友，两个人始终应该是独立的个体。七月是安生的影子，安生也是七月的影子，两个人从相遇开始，就一直想要成为对方。\n家明也是个受害者。背了逃婚的锅，为了成全七月。心里装了两个人，最后谁的爱也没有得到。但是这个男人太没有担当了啊，什么也不说清楚，两边都不给个明白话，就打算顺水推舟和七月结婚，一首《算什么男人》送给他。\n另，日漫《NANA》也是讲的两个女生之间的故事，悲剧收场，有点像。\n\n## 碎碎念。\n\n九月的电影目标达成，读书目标还差一本，十月努力达成目标吧。\n不是很会写影评和书评，但是**“如果不去写的话，那就连垃圾也写不出来。”**不好意思啦亲爱的读者，可能让你读了一篇垃圾...但我还是会努力的。\n","slug":"九月观影看书","published":1,"updated":"2019-10-09T03:48:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeagh2002538t4akyh7g0u","content":"<p>《罗小黑战记》、《三体Ⅰ 地球往事》、《浪漫的体质》、《Begin Again》、《七月与安生》</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>推荐《Begin Again》、《浪漫的体质》、《三体》。《罗小黑战记》也推荐，但受众可能比较小，可以尝试欣赏一下2D的打戏和场景制作。</p>\n<h2 id=\"罗小黑战记\"><a href=\"#罗小黑战记\" class=\"headerlink\" title=\"罗小黑战记\"></a>罗小黑战记</h2><p>和同学在上映第一天就去看了。八年更了28集（每集5-7分钟）的国漫居然出电影了。看前还看了一下动画版的《罗小黑战记》。事实上，不管是不是粉丝，都能欣赏到电影。<br>电影画面是<strong>2D</strong>的，除了大场景（如城市与市民）用了3D建模。画面很流畅的，尤其是<strong>打戏</strong>部分。电影中打戏部分一点也没有偷工减料，镜头转换也做得很好。（这个在动画中也是，棒！）<strong>场景</strong>画面的设计和绘制也很精致，不管是在森林，在海面上，还是后面风息和无限打斗的商场。<br>关于情节，我觉得有的地方没有交代清楚，有一点瑕疵，又或者是我没看好。关于小黑的“领域”，风息的故事线等。另外，我觉得编剧有想强调妖与人共生的问题，也想强调善恶价值观的问题，主题都挺好的，但是很模糊，没有一种主题突出和升华，引人思考的感觉。缺了一点点深度。<br>都是个人感觉，但是<strong>小黑好可爱，无限好帅</strong>！！<del>我要做无限身上的金属片！</del></p>\n<h2 id=\"三体Ⅰ\"><a href=\"#三体Ⅰ\" class=\"headerlink\" title=\"三体Ⅰ\"></a>三体Ⅰ</h2><p>久仰大名！终于读了第一部。也是第一次真正地读科幻小说。书中描绘的三体世界尤其震撼。不管是三体游戏，还是三体世界，都充满想象力。但是这天马行空的<strong>想象</strong>又让人能感到一点<strong>真实</strong>，作者的文字和读者的想象力就是马良的神笔，读来有种身临其境的感觉。这是科幻小说最吸引人的地方之一，精心的描绘让读者有足够的空间去想象，构造自己脑海中三体世界的样子。<br>另外最吸引人的地方就是关于<strong>人性与道德</strong>的讨论和思考。人类中衍生出的异己群体，三体文明中也有着像1379号监听员那样的存在。当外星势力侵略时，末日降临时，人们表现出不同的态度。主要体现在高级知识分子和普通百姓，三体组织的三大派系。<br>而每一个变成异己的人都必定有其特别的经历，书中就以叶文洁为代表，另外还有伊文斯加以佐证。这里体现了作者写作的手法。作者在场景描绘上也是手法巧妙。我印象最深的是当使用纳米材料对“审判日”号采取行动时，那个细节的描述很震撼。<br>还有最吸引的地方一定是<strong>对宇宙的思考和疑问</strong>。就目前所知，我们是宇宙中一颗孤独的星球，而人们也从来没有停止过对外星生命的探索。外星智慧生命会是一种怎样的存在，如果真的收到了外星讯息我们会发生什么，这发人深思。书中关于维度的描述也引人思考：是否存在别的宇宙？我们身处的宇宙对于一个更高级的文明而言，是否就像虫子对于我们而言？<br>想起叶文洁对汪淼说过的一句话：<strong>“有时觉得生命真珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值得一提。”</strong><br>补充一点新的想法。对于三体文明而言，我们是低级的物种。在地球上，我们是作为食物链顶端的人类，很少去考虑更为低级的生命物种。生命真的是平等的吗？如果是，那又何为<strong>平等</strong>？</p>\n<h2 id=\"浪漫的体质\"><a href=\"#浪漫的体质\" class=\"headerlink\" title=\"浪漫的体质\"></a>浪漫的体质</h2><p>值得二刷，剧中金句的密集度极高。作为一个还未步入社会的学生，可能共鸣会更少一点，就像剧中主角都是步入三十的一样，这个岁数的人看会更有感触一些吧。<br>那么作为一个二十一岁的人，看着自己再过几年就会步入的生活，下面是我的Ideas。<br>生活中会有诸多不如意，职场、感情、家庭等等，虽没有了二十岁的风风火火，但也没有了二十岁的稚嫩。面对烦恼已经习以为常，也能说出些人生道理，不会再轻易流泪，但还是会和朋友们去吐槽。<br>“到了三十岁就会好起来”，到底是什么会好起来呢？年轻时候的所有经历变成经验，那些流下的眼泪，背负着的痛苦，都慢慢习惯。生活有变好起来吗？好像也没有，糟心事还是一件接着一件。但是慢慢习惯了，也明白了自己要的是什么。<br>对于寒珠的变化，我印象很深。当初离婚时，她问丈夫：“那我的幸福怎么办？”后来前夫又找到她希望复合时，她说出了：“我是不会依赖男人来得到幸福。”<br>看完了结局，最后每一个人的结局都有不同，这才更像是真实的生活。最后大家都离开了这个房子，没有太多伤感，只是如同平日一样聊天。时间让我们学会了：<strong>不管遇到什么事，都要往前看，都会变好的</strong>。</p>\n<h2 id=\"Begin-Again\"><a href=\"#Begin-Again\" class=\"headerlink\" title=\"Begin Again\"></a>Begin Again</h2><p>冲着《Lost Stars》来看的电影。<br>打9分。很喜欢这部电影，非常治愈。特别喜欢它的结局，女主谁也没有选，告诉我们还有第三种选择：<strong>自己</strong>。没有回到Dave的身边，也没有迷恋与Dan的短暂火花。看着最后Gretta一个人在纽约的灯光下骑着单车，心里有点沸腾，忍不住跟着她一起笑了。看到豆瓣一个影评（@Miss歪）：最想成为的女生不是《律政俏佳人》里的Elle Woods，也不是《公主日记》里的Mia。是呀，不是所有女生都有那样的运气和背景，倒是更想成为像Gretta这样的坚强率真又可爱的女生。<strong>去选择自己的人生，去勇敢追求未来，勇敢告别过去。</strong><br>很喜欢中间在纽约到处取景录歌的片段，太欢乐了！看得我非常想去学写歌，学乐器。<br>饰演女主的Keria Knightly也太美了。每一套衣服都好适合她，像个干瘦的假小子，又带着女性专属的率性和气质。性格特点都很符合，但我觉得差一点音乐人的气质，毕竟KK也不是专业歌手。<br>啊还有演Dan的Mark，这迷人的气质到底是哪里来的？快点停止散发你那该死的魅力！是我，我都不敢直视他的眼睛，他的眼睛也太会说话了<del>（开始做梦）</del>。跟女主待一起时我总觉得下一秒就要吻上去！（还好没吻，不然剧情有点跑偏。）<br>骚当也意外合适，没有出戏的感觉。<br>另，关于Dave写歌给别的女生，女主听一半就一耳光扇过去。后来我想明白了，不是从歌里听出来的，而是Dave躲闪的眼神，恋爱中的女生都是mind reader。<br><strong>啊我真是好喜欢这部电影！</strong><br>也很喜欢《Lost Stars》，两个版本就是两首歌，都很喜欢。</p>\n<blockquote>\n</blockquote>\n<p>Youth is wasted on the young<br>It’s hunting season and this lamb is on the run<br>We are searching for meaning<br>But are we all lost stars<br>trying to light up the dark<br>Who are we<br>Just a speck of dust within the galaxy<br>Woe is me<br>If we’re not careful turns into reality</p>\n<h2 id=\"七月与安生\"><a href=\"#七月与安生\" class=\"headerlink\" title=\"七月与安生\"></a>七月与安生</h2><p>其实看之前我还以为是一部同性电影呢…没想到是闺蜜同时喜欢上一个男人的剧情。<br>我给它打7分。先说<strong>不喜欢的地方</strong>，主要是<strong>剧情</strong>。我觉得剧情有一点<strong>狗血</strong>，比如喜欢上同一个男人，安生把男生让给七月，家明喜欢上了安生，家明与安生的重逢，家明逃婚，七月死于产后大出血等等。这些在影视作品中也太寻常了，但是在生活中却又好像不太寻常。但是这样狗血的剧情跟这个故事还挺搭。<br>再说说<strong>喜欢的地方</strong>，首先是<strong>女生间的感情刻画</strong>。那种<strong>细腻</strong>可能是只有女生才能体会到。感情深到一定程度后，虽然会撕X会吵架，但事后又为自己的所作所为后悔，再次相遇一个拥抱能化解冰块。两个背景性格都极为不同的女生的友情中，除了真心为对方好，也一定有羡慕、嫉妒甚至恨。<strong>又因为爱，而讨厌那个嫉妒对方的自己。</strong><br>其次是周冬雨和马思纯的<strong>演技</strong>，不愧是拿下了金马影后，两个人都很适合她们的角色。<br>最后再<strong>简单聊聊故事</strong>。最后结局的反转让我很意外，也很难过，在半夜看哭了。这个故事里三个人都是受害者，它从一开始就决定了是个悲剧。这个故事告诉我们，不管是关系多么好的朋友，两个人始终应该是独立的个体。七月是安生的影子，安生也是七月的影子，两个人从相遇开始，就一直想要成为对方。<br>家明也是个受害者。背了逃婚的锅，为了成全七月。心里装了两个人，最后谁的爱也没有得到。但是这个男人太没有担当了啊，什么也不说清楚，两边都不给个明白话，就打算顺水推舟和七月结婚，一首《算什么男人》送给他。<br>另，日漫《NANA》也是讲的两个女生之间的故事，悲剧收场，有点像。</p>\n<h2 id=\"碎碎念。\"><a href=\"#碎碎念。\" class=\"headerlink\" title=\"碎碎念。\"></a>碎碎念。</h2><p>九月的电影目标达成，读书目标还差一本，十月努力达成目标吧。<br>不是很会写影评和书评，但是<strong>“如果不去写的话，那就连垃圾也写不出来。”</strong>不好意思啦亲爱的读者，可能让你读了一篇垃圾…但我还是会努力的。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>《罗小黑战记》、《三体Ⅰ 地球往事》、《浪漫的体质》、《Begin Again》、《七月与安生》</p>","more":"<hr>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>推荐《Begin Again》、《浪漫的体质》、《三体》。《罗小黑战记》也推荐，但受众可能比较小，可以尝试欣赏一下2D的打戏和场景制作。</p>\n<h2 id=\"罗小黑战记\"><a href=\"#罗小黑战记\" class=\"headerlink\" title=\"罗小黑战记\"></a>罗小黑战记</h2><p>和同学在上映第一天就去看了。八年更了28集（每集5-7分钟）的国漫居然出电影了。看前还看了一下动画版的《罗小黑战记》。事实上，不管是不是粉丝，都能欣赏到电影。<br>电影画面是<strong>2D</strong>的，除了大场景（如城市与市民）用了3D建模。画面很流畅的，尤其是<strong>打戏</strong>部分。电影中打戏部分一点也没有偷工减料，镜头转换也做得很好。（这个在动画中也是，棒！）<strong>场景</strong>画面的设计和绘制也很精致，不管是在森林，在海面上，还是后面风息和无限打斗的商场。<br>关于情节，我觉得有的地方没有交代清楚，有一点瑕疵，又或者是我没看好。关于小黑的“领域”，风息的故事线等。另外，我觉得编剧有想强调妖与人共生的问题，也想强调善恶价值观的问题，主题都挺好的，但是很模糊，没有一种主题突出和升华，引人思考的感觉。缺了一点点深度。<br>都是个人感觉，但是<strong>小黑好可爱，无限好帅</strong>！！<del>我要做无限身上的金属片！</del></p>\n<h2 id=\"三体Ⅰ\"><a href=\"#三体Ⅰ\" class=\"headerlink\" title=\"三体Ⅰ\"></a>三体Ⅰ</h2><p>久仰大名！终于读了第一部。也是第一次真正地读科幻小说。书中描绘的三体世界尤其震撼。不管是三体游戏，还是三体世界，都充满想象力。但是这天马行空的<strong>想象</strong>又让人能感到一点<strong>真实</strong>，作者的文字和读者的想象力就是马良的神笔，读来有种身临其境的感觉。这是科幻小说最吸引人的地方之一，精心的描绘让读者有足够的空间去想象，构造自己脑海中三体世界的样子。<br>另外最吸引人的地方就是关于<strong>人性与道德</strong>的讨论和思考。人类中衍生出的异己群体，三体文明中也有着像1379号监听员那样的存在。当外星势力侵略时，末日降临时，人们表现出不同的态度。主要体现在高级知识分子和普通百姓，三体组织的三大派系。<br>而每一个变成异己的人都必定有其特别的经历，书中就以叶文洁为代表，另外还有伊文斯加以佐证。这里体现了作者写作的手法。作者在场景描绘上也是手法巧妙。我印象最深的是当使用纳米材料对“审判日”号采取行动时，那个细节的描述很震撼。<br>还有最吸引的地方一定是<strong>对宇宙的思考和疑问</strong>。就目前所知，我们是宇宙中一颗孤独的星球，而人们也从来没有停止过对外星生命的探索。外星智慧生命会是一种怎样的存在，如果真的收到了外星讯息我们会发生什么，这发人深思。书中关于维度的描述也引人思考：是否存在别的宇宙？我们身处的宇宙对于一个更高级的文明而言，是否就像虫子对于我们而言？<br>想起叶文洁对汪淼说过的一句话：<strong>“有时觉得生命真珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值得一提。”</strong><br>补充一点新的想法。对于三体文明而言，我们是低级的物种。在地球上，我们是作为食物链顶端的人类，很少去考虑更为低级的生命物种。生命真的是平等的吗？如果是，那又何为<strong>平等</strong>？</p>\n<h2 id=\"浪漫的体质\"><a href=\"#浪漫的体质\" class=\"headerlink\" title=\"浪漫的体质\"></a>浪漫的体质</h2><p>值得二刷，剧中金句的密集度极高。作为一个还未步入社会的学生，可能共鸣会更少一点，就像剧中主角都是步入三十的一样，这个岁数的人看会更有感触一些吧。<br>那么作为一个二十一岁的人，看着自己再过几年就会步入的生活，下面是我的Ideas。<br>生活中会有诸多不如意，职场、感情、家庭等等，虽没有了二十岁的风风火火，但也没有了二十岁的稚嫩。面对烦恼已经习以为常，也能说出些人生道理，不会再轻易流泪，但还是会和朋友们去吐槽。<br>“到了三十岁就会好起来”，到底是什么会好起来呢？年轻时候的所有经历变成经验，那些流下的眼泪，背负着的痛苦，都慢慢习惯。生活有变好起来吗？好像也没有，糟心事还是一件接着一件。但是慢慢习惯了，也明白了自己要的是什么。<br>对于寒珠的变化，我印象很深。当初离婚时，她问丈夫：“那我的幸福怎么办？”后来前夫又找到她希望复合时，她说出了：“我是不会依赖男人来得到幸福。”<br>看完了结局，最后每一个人的结局都有不同，这才更像是真实的生活。最后大家都离开了这个房子，没有太多伤感，只是如同平日一样聊天。时间让我们学会了：<strong>不管遇到什么事，都要往前看，都会变好的</strong>。</p>\n<h2 id=\"Begin-Again\"><a href=\"#Begin-Again\" class=\"headerlink\" title=\"Begin Again\"></a>Begin Again</h2><p>冲着《Lost Stars》来看的电影。<br>打9分。很喜欢这部电影，非常治愈。特别喜欢它的结局，女主谁也没有选，告诉我们还有第三种选择：<strong>自己</strong>。没有回到Dave的身边，也没有迷恋与Dan的短暂火花。看着最后Gretta一个人在纽约的灯光下骑着单车，心里有点沸腾，忍不住跟着她一起笑了。看到豆瓣一个影评（@Miss歪）：最想成为的女生不是《律政俏佳人》里的Elle Woods，也不是《公主日记》里的Mia。是呀，不是所有女生都有那样的运气和背景，倒是更想成为像Gretta这样的坚强率真又可爱的女生。<strong>去选择自己的人生，去勇敢追求未来，勇敢告别过去。</strong><br>很喜欢中间在纽约到处取景录歌的片段，太欢乐了！看得我非常想去学写歌，学乐器。<br>饰演女主的Keria Knightly也太美了。每一套衣服都好适合她，像个干瘦的假小子，又带着女性专属的率性和气质。性格特点都很符合，但我觉得差一点音乐人的气质，毕竟KK也不是专业歌手。<br>啊还有演Dan的Mark，这迷人的气质到底是哪里来的？快点停止散发你那该死的魅力！是我，我都不敢直视他的眼睛，他的眼睛也太会说话了<del>（开始做梦）</del>。跟女主待一起时我总觉得下一秒就要吻上去！（还好没吻，不然剧情有点跑偏。）<br>骚当也意外合适，没有出戏的感觉。<br>另，关于Dave写歌给别的女生，女主听一半就一耳光扇过去。后来我想明白了，不是从歌里听出来的，而是Dave躲闪的眼神，恋爱中的女生都是mind reader。<br><strong>啊我真是好喜欢这部电影！</strong><br>也很喜欢《Lost Stars》，两个版本就是两首歌，都很喜欢。</p>\n<blockquote>\n</blockquote>\n<p>Youth is wasted on the young<br>It’s hunting season and this lamb is on the run<br>We are searching for meaning<br>But are we all lost stars<br>trying to light up the dark<br>Who are we<br>Just a speck of dust within the galaxy<br>Woe is me<br>If we’re not careful turns into reality</p>\n<h2 id=\"七月与安生\"><a href=\"#七月与安生\" class=\"headerlink\" title=\"七月与安生\"></a>七月与安生</h2><p>其实看之前我还以为是一部同性电影呢…没想到是闺蜜同时喜欢上一个男人的剧情。<br>我给它打7分。先说<strong>不喜欢的地方</strong>，主要是<strong>剧情</strong>。我觉得剧情有一点<strong>狗血</strong>，比如喜欢上同一个男人，安生把男生让给七月，家明喜欢上了安生，家明与安生的重逢，家明逃婚，七月死于产后大出血等等。这些在影视作品中也太寻常了，但是在生活中却又好像不太寻常。但是这样狗血的剧情跟这个故事还挺搭。<br>再说说<strong>喜欢的地方</strong>，首先是<strong>女生间的感情刻画</strong>。那种<strong>细腻</strong>可能是只有女生才能体会到。感情深到一定程度后，虽然会撕X会吵架，但事后又为自己的所作所为后悔，再次相遇一个拥抱能化解冰块。两个背景性格都极为不同的女生的友情中，除了真心为对方好，也一定有羡慕、嫉妒甚至恨。<strong>又因为爱，而讨厌那个嫉妒对方的自己。</strong><br>其次是周冬雨和马思纯的<strong>演技</strong>，不愧是拿下了金马影后，两个人都很适合她们的角色。<br>最后再<strong>简单聊聊故事</strong>。最后结局的反转让我很意外，也很难过，在半夜看哭了。这个故事里三个人都是受害者，它从一开始就决定了是个悲剧。这个故事告诉我们，不管是关系多么好的朋友，两个人始终应该是独立的个体。七月是安生的影子，安生也是七月的影子，两个人从相遇开始，就一直想要成为对方。<br>家明也是个受害者。背了逃婚的锅，为了成全七月。心里装了两个人，最后谁的爱也没有得到。但是这个男人太没有担当了啊，什么也不说清楚，两边都不给个明白话，就打算顺水推舟和七月结婚，一首《算什么男人》送给他。<br>另，日漫《NANA》也是讲的两个女生之间的故事，悲剧收场，有点像。</p>\n<h2 id=\"碎碎念。\"><a href=\"#碎碎念。\" class=\"headerlink\" title=\"碎碎念。\"></a>碎碎念。</h2><p>九月的电影目标达成，读书目标还差一本，十月努力达成目标吧。<br>不是很会写影评和书评，但是<strong>“如果不去写的话，那就连垃圾也写不出来。”</strong>不好意思啦亲爱的读者，可能让你读了一篇垃圾…但我还是会努力的。</p>"},{"title":"二月观影看剧分享|影评|剧评","date":"2019-02-28T13:43:59.000Z","_content":"流浪地球、飞驰人生、我是大哥大、3年A班、刺客伍六七、请回答1988\n<!--more-->\n\n---\n## 写在最前面\n\n总结一下，推荐你们《流浪地球》，《刺客伍六七》，《请回答1988》\n第一次写，没好好斟酌词句，还请各位读者宽容一下~\n\n## 《流浪地球》\n![流浪地球][1]\n春节档里话题屠榜的电影。\n看之前，一个朋友跟我说：“你喜欢天文的话，那你喜不喜欢科幻小说电影？”然后就跟我推荐了《流浪地球》，也给我推荐了小刘的书还有《星际穿越》。\n高中看过一点《星际穿越》，但是的确没怎么接触科幻题材的。\n这次第一次去电影院看科幻灾难片，感觉还是很爽的！看到天边被放大的木星而激动，也为片中人物的丧生而落泪。\n说说个人感受，的确算是中国科幻片的一个里程碑吧，是一个标志着开始的里程碑。到目前为止，优秀科幻片中几乎都是欧美面孔。而《流浪地球》就是开创了这样的一条先河。它不是最好的，但是给后面的中国科幻电影起了个好头。\n在现在电影水片很多的大形势下，我们需要这样的认真的电影。\n当然啦，还是有很长的路要走呢~\n\n\n## 《飞驰人生》\n![飞驰人生][2]\n和两个高中姐妹一起去看的，临时决定。\n看前，我只知道阿信唱了片尾曲。在电影院听到阿信的声音还是超开心！\n看完之后，没什么很大的感觉。带着追梦情怀的喜剧片。沈叔叔长得就很好笑。黄景瑜也太帅了！这部是那种我没事的时候，不会找来看的影片。\n最精彩的部分就是阿信唱歌了！\n次精彩的部分就是中间汽车零件的特效！\n我感觉现在很多电影里都会有一些太刻意的搞笑。我讲不清，但是大概就是这个意思。\n\n## 《我是大哥大》\n![我是大哥大][3]\n很热门的日剧。全员颜艺，有的情节真的很好笑我会倒回去看好几遍。剧组也特别欢乐，我也去找了片场花絮看。\n伊藤三桥京子理子都好帅！今井好好笑！这是不良之间的友情啊~全剧就是打架骂人谈恋爱。\n(一部沙雕剧的剧评我实在写不下去了告辞...)\n看到了一篇文章，剧里其实有好多好多梗啊！\n[《我是大哥大》绝不只是一部沙雕剧这么简单 |机核][8]\n\n## 《刺客伍六七》\n![刺客伍六七][4]\n\"我今天就要带她走，我看谁敢拦我。\"\n这是阿七在最后一集对梅花说的话。帅炸了！\n这部国漫讲阿七做刺客的时候发生的事情，以及他慢慢唤醒的记忆。非常期待今年的第二季，正如制作组在第一季片尾说的：“不用完结撒花，阿七的故事才刚刚开始。”\n每一个任务可能都有些奇怪也有些搞笑，阿七是一个有自己原则的刺客。\n他作为一个刺客，但不是谁都杀。\n片尾曲很喜欢：“无论你样子是多么怪异，我还是会喜欢你。”\n\n**以下内容涉及严重剧透！**\n**以下内容涉及严重剧透！**\n**以下内容涉及严重剧透！**\n每一集虽然制作的简单，但是有几集的内涵还是很深刻的。我很喜欢这部国漫。为内裤哥仗义出手，没偷没抢只是爱好不同又有什么错。为小咪和小汪解开心结，不管什么事，不说出来就永远不会知道彼此的心意。陪伴绝症女孩，最后得知真相没有杀她。阿婆虽然做尽了恶，但因为一些原因在阿婆要死的时候挡下了飞镖。（这集有点争议，但是豆瓣上的一篇文章分析地很好）最后为了保护这个小岛，虽然对手极强但依然出手相救。\n**剧透结束！**\n\n总而言之，很推荐你们去看《刺客伍六七》。\n今年要出第二季，愣着干嘛？追啊！\n\n## 《画江湖之不良人》\n![不良人][5]\n\n追到第三季啦！从第二季开始追的，剧情还是很好看的。《不良人》也能代表中国动漫的高水平了。虽然官方把格局越铺越大，支线剧情也越来越多。但是，第三季有了很大的进步。我看剧不懂得分析人物，但是感觉得到男主这一季真的成熟很多。比起之前，我更喜欢现在这样更成熟更有担当的样子。\n剧情好看就行了嘛，人物塑造得也挺饱满的~我最喜欢蚩梦啦！\n（海报没找到合适的，私心放一张蚩梦。官方爸爸听到了吗？求你们出一张好点的全员海报吧！）\n\n## 《3年A班-现在开始，全员人质》\n![3年a班][6]\n**没什么剧透，放心往下看**\n\n在追。苏打凉太都很帅我就不多说了。剧情一直在反转，很精彩。苏打饰演的柊一飒策划一起犯罪，让全班同学去揭开另一个案件的真相。小飒让学生都得到了改变，也讲了一个教师应该怎么去引导学生。\n我看下来印象最深的是这句话：“学生只能看到三步以内的未来。”\n的确是这样，我没有碰到给我讲三步以后的未来的老师，也或许是当时看到三步以内未来的我根本就听不进去吧。\n作为学生，我也想要想苏打这样的老师啊！\n\n## 《请回答1988》\n![请回答1988][7]\n真的真的很好看。剧里的每一个人都非常的鲜活，让你感觉就在自己身边。剧中的故事就好像是发生在自己身上的事，平平淡淡又有哭有笑。这个有机会捡几集好好写写剧评。\n有很多感同身受的故事，我看得哭。能引起共鸣的剧最难得吧，这就是这部剧的魅力所在。\n\n## 其他\n\n看了三集《我的英雄学园》，充满热血的追梦故事。不合我的胃口-ω-\n看了三集《高岭之花》，十元女士我喜欢你，但是这部剧我不喜欢-ω-\n## 后记\n第一次写影评/剧评，实在是词穷...orz\n没想到写起来这么花时间，下次要挑着写了！主要是因为真的不会写。那么多片放一起，居然能写到将近两千字，看到这里的你们可真棒！\n希望下个月能继续有观影看剧分享，再加上阅读和手账分享。在此许（wa）愿（keng）~以及最近思想上有一个很大的转变，也想写出来！\n\nPS：达成在二月三更成就！下个月开始准备考研了，我又要回到年更博主的身份了。\n\n\n  [1]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/liu-lang-di-qiu.png\n  [2]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/fei-chi-ren-sheng.jpg\n  [3]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/wo-shi-da-ge-da.png\n  [4]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/ci-ke-wu-liu-qi.png\n  [5]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/bu-liang-ren.jpeg\n  [6]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/3-nian-a-ban.jpg\n  [7]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/qing-hui-da-1988.jpg\n  [8]: https://www.gcores.com/articles/104945","source":"_posts/二月观影看剧分享-影评-剧评.md","raw":"---\ntitle: 二月观影看剧分享|影评|剧评\ndate: 2019-02-28 21:43:59\ncategories: 生活Life\n---\n流浪地球、飞驰人生、我是大哥大、3年A班、刺客伍六七、请回答1988\n<!--more-->\n\n---\n## 写在最前面\n\n总结一下，推荐你们《流浪地球》，《刺客伍六七》，《请回答1988》\n第一次写，没好好斟酌词句，还请各位读者宽容一下~\n\n## 《流浪地球》\n![流浪地球][1]\n春节档里话题屠榜的电影。\n看之前，一个朋友跟我说：“你喜欢天文的话，那你喜不喜欢科幻小说电影？”然后就跟我推荐了《流浪地球》，也给我推荐了小刘的书还有《星际穿越》。\n高中看过一点《星际穿越》，但是的确没怎么接触科幻题材的。\n这次第一次去电影院看科幻灾难片，感觉还是很爽的！看到天边被放大的木星而激动，也为片中人物的丧生而落泪。\n说说个人感受，的确算是中国科幻片的一个里程碑吧，是一个标志着开始的里程碑。到目前为止，优秀科幻片中几乎都是欧美面孔。而《流浪地球》就是开创了这样的一条先河。它不是最好的，但是给后面的中国科幻电影起了个好头。\n在现在电影水片很多的大形势下，我们需要这样的认真的电影。\n当然啦，还是有很长的路要走呢~\n\n\n## 《飞驰人生》\n![飞驰人生][2]\n和两个高中姐妹一起去看的，临时决定。\n看前，我只知道阿信唱了片尾曲。在电影院听到阿信的声音还是超开心！\n看完之后，没什么很大的感觉。带着追梦情怀的喜剧片。沈叔叔长得就很好笑。黄景瑜也太帅了！这部是那种我没事的时候，不会找来看的影片。\n最精彩的部分就是阿信唱歌了！\n次精彩的部分就是中间汽车零件的特效！\n我感觉现在很多电影里都会有一些太刻意的搞笑。我讲不清，但是大概就是这个意思。\n\n## 《我是大哥大》\n![我是大哥大][3]\n很热门的日剧。全员颜艺，有的情节真的很好笑我会倒回去看好几遍。剧组也特别欢乐，我也去找了片场花絮看。\n伊藤三桥京子理子都好帅！今井好好笑！这是不良之间的友情啊~全剧就是打架骂人谈恋爱。\n(一部沙雕剧的剧评我实在写不下去了告辞...)\n看到了一篇文章，剧里其实有好多好多梗啊！\n[《我是大哥大》绝不只是一部沙雕剧这么简单 |机核][8]\n\n## 《刺客伍六七》\n![刺客伍六七][4]\n\"我今天就要带她走，我看谁敢拦我。\"\n这是阿七在最后一集对梅花说的话。帅炸了！\n这部国漫讲阿七做刺客的时候发生的事情，以及他慢慢唤醒的记忆。非常期待今年的第二季，正如制作组在第一季片尾说的：“不用完结撒花，阿七的故事才刚刚开始。”\n每一个任务可能都有些奇怪也有些搞笑，阿七是一个有自己原则的刺客。\n他作为一个刺客，但不是谁都杀。\n片尾曲很喜欢：“无论你样子是多么怪异，我还是会喜欢你。”\n\n**以下内容涉及严重剧透！**\n**以下内容涉及严重剧透！**\n**以下内容涉及严重剧透！**\n每一集虽然制作的简单，但是有几集的内涵还是很深刻的。我很喜欢这部国漫。为内裤哥仗义出手，没偷没抢只是爱好不同又有什么错。为小咪和小汪解开心结，不管什么事，不说出来就永远不会知道彼此的心意。陪伴绝症女孩，最后得知真相没有杀她。阿婆虽然做尽了恶，但因为一些原因在阿婆要死的时候挡下了飞镖。（这集有点争议，但是豆瓣上的一篇文章分析地很好）最后为了保护这个小岛，虽然对手极强但依然出手相救。\n**剧透结束！**\n\n总而言之，很推荐你们去看《刺客伍六七》。\n今年要出第二季，愣着干嘛？追啊！\n\n## 《画江湖之不良人》\n![不良人][5]\n\n追到第三季啦！从第二季开始追的，剧情还是很好看的。《不良人》也能代表中国动漫的高水平了。虽然官方把格局越铺越大，支线剧情也越来越多。但是，第三季有了很大的进步。我看剧不懂得分析人物，但是感觉得到男主这一季真的成熟很多。比起之前，我更喜欢现在这样更成熟更有担当的样子。\n剧情好看就行了嘛，人物塑造得也挺饱满的~我最喜欢蚩梦啦！\n（海报没找到合适的，私心放一张蚩梦。官方爸爸听到了吗？求你们出一张好点的全员海报吧！）\n\n## 《3年A班-现在开始，全员人质》\n![3年a班][6]\n**没什么剧透，放心往下看**\n\n在追。苏打凉太都很帅我就不多说了。剧情一直在反转，很精彩。苏打饰演的柊一飒策划一起犯罪，让全班同学去揭开另一个案件的真相。小飒让学生都得到了改变，也讲了一个教师应该怎么去引导学生。\n我看下来印象最深的是这句话：“学生只能看到三步以内的未来。”\n的确是这样，我没有碰到给我讲三步以后的未来的老师，也或许是当时看到三步以内未来的我根本就听不进去吧。\n作为学生，我也想要想苏打这样的老师啊！\n\n## 《请回答1988》\n![请回答1988][7]\n真的真的很好看。剧里的每一个人都非常的鲜活，让你感觉就在自己身边。剧中的故事就好像是发生在自己身上的事，平平淡淡又有哭有笑。这个有机会捡几集好好写写剧评。\n有很多感同身受的故事，我看得哭。能引起共鸣的剧最难得吧，这就是这部剧的魅力所在。\n\n## 其他\n\n看了三集《我的英雄学园》，充满热血的追梦故事。不合我的胃口-ω-\n看了三集《高岭之花》，十元女士我喜欢你，但是这部剧我不喜欢-ω-\n## 后记\n第一次写影评/剧评，实在是词穷...orz\n没想到写起来这么花时间，下次要挑着写了！主要是因为真的不会写。那么多片放一起，居然能写到将近两千字，看到这里的你们可真棒！\n希望下个月能继续有观影看剧分享，再加上阅读和手账分享。在此许（wa）愿（keng）~以及最近思想上有一个很大的转变，也想写出来！\n\nPS：达成在二月三更成就！下个月开始准备考研了，我又要回到年更博主的身份了。\n\n\n  [1]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/liu-lang-di-qiu.png\n  [2]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/fei-chi-ren-sheng.jpg\n  [3]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/wo-shi-da-ge-da.png\n  [4]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/ci-ke-wu-liu-qi.png\n  [5]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/bu-liang-ren.jpeg\n  [6]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/3-nian-a-ban.jpg\n  [7]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/qing-hui-da-1988.jpg\n  [8]: https://www.gcores.com/articles/104945","slug":"二月观影看剧分享-影评-剧评","published":1,"updated":"2019-02-28T13:43:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeagh2002938t44b61gr7h","content":"<p>流浪地球、飞驰人生、我是大哥大、3年A班、刺客伍六七、请回答1988</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"写在最前面\"><a href=\"#写在最前面\" class=\"headerlink\" title=\"写在最前面\"></a>写在最前面</h2><p>总结一下，推荐你们《流浪地球》，《刺客伍六七》，《请回答1988》<br>第一次写，没好好斟酌词句，还请各位读者宽容一下~</p>\n<h2 id=\"《流浪地球》\"><a href=\"#《流浪地球》\" class=\"headerlink\" title=\"《流浪地球》\"></a>《流浪地球》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/liu-lang-di-qiu.png\" alt=\"流浪地球\"><br>春节档里话题屠榜的电影。<br>看之前，一个朋友跟我说：“你喜欢天文的话，那你喜不喜欢科幻小说电影？”然后就跟我推荐了《流浪地球》，也给我推荐了小刘的书还有《星际穿越》。<br>高中看过一点《星际穿越》，但是的确没怎么接触科幻题材的。<br>这次第一次去电影院看科幻灾难片，感觉还是很爽的！看到天边被放大的木星而激动，也为片中人物的丧生而落泪。<br>说说个人感受，的确算是中国科幻片的一个里程碑吧，是一个标志着开始的里程碑。到目前为止，优秀科幻片中几乎都是欧美面孔。而《流浪地球》就是开创了这样的一条先河。它不是最好的，但是给后面的中国科幻电影起了个好头。<br>在现在电影水片很多的大形势下，我们需要这样的认真的电影。<br>当然啦，还是有很长的路要走呢~</p>\n<h2 id=\"《飞驰人生》\"><a href=\"#《飞驰人生》\" class=\"headerlink\" title=\"《飞驰人生》\"></a>《飞驰人生》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/fei-chi-ren-sheng.jpg\" alt=\"飞驰人生\"><br>和两个高中姐妹一起去看的，临时决定。<br>看前，我只知道阿信唱了片尾曲。在电影院听到阿信的声音还是超开心！<br>看完之后，没什么很大的感觉。带着追梦情怀的喜剧片。沈叔叔长得就很好笑。黄景瑜也太帅了！这部是那种我没事的时候，不会找来看的影片。<br>最精彩的部分就是阿信唱歌了！<br>次精彩的部分就是中间汽车零件的特效！<br>我感觉现在很多电影里都会有一些太刻意的搞笑。我讲不清，但是大概就是这个意思。</p>\n<h2 id=\"《我是大哥大》\"><a href=\"#《我是大哥大》\" class=\"headerlink\" title=\"《我是大哥大》\"></a>《我是大哥大》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/wo-shi-da-ge-da.png\" alt=\"我是大哥大\"><br>很热门的日剧。全员颜艺，有的情节真的很好笑我会倒回去看好几遍。剧组也特别欢乐，我也去找了片场花絮看。<br>伊藤三桥京子理子都好帅！今井好好笑！这是不良之间的友情啊~全剧就是打架骂人谈恋爱。<br>(一部沙雕剧的剧评我实在写不下去了告辞…)<br>看到了一篇文章，剧里其实有好多好多梗啊！<br><a href=\"https://www.gcores.com/articles/104945\">《我是大哥大》绝不只是一部沙雕剧这么简单 |机核</a></p>\n<h2 id=\"《刺客伍六七》\"><a href=\"#《刺客伍六七》\" class=\"headerlink\" title=\"《刺客伍六七》\"></a>《刺客伍六七》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ci-ke-wu-liu-qi.png\" alt=\"刺客伍六七\"><br>“我今天就要带她走，我看谁敢拦我。”<br>这是阿七在最后一集对梅花说的话。帅炸了！<br>这部国漫讲阿七做刺客的时候发生的事情，以及他慢慢唤醒的记忆。非常期待今年的第二季，正如制作组在第一季片尾说的：“不用完结撒花，阿七的故事才刚刚开始。”<br>每一个任务可能都有些奇怪也有些搞笑，阿七是一个有自己原则的刺客。<br>他作为一个刺客，但不是谁都杀。<br>片尾曲很喜欢：“无论你样子是多么怪异，我还是会喜欢你。”</p>\n<p><strong>以下内容涉及严重剧透！</strong><br><strong>以下内容涉及严重剧透！</strong><br><strong>以下内容涉及严重剧透！</strong><br>每一集虽然制作的简单，但是有几集的内涵还是很深刻的。我很喜欢这部国漫。为内裤哥仗义出手，没偷没抢只是爱好不同又有什么错。为小咪和小汪解开心结，不管什么事，不说出来就永远不会知道彼此的心意。陪伴绝症女孩，最后得知真相没有杀她。阿婆虽然做尽了恶，但因为一些原因在阿婆要死的时候挡下了飞镖。（这集有点争议，但是豆瓣上的一篇文章分析地很好）最后为了保护这个小岛，虽然对手极强但依然出手相救。<br><strong>剧透结束！</strong></p>\n<p>总而言之，很推荐你们去看《刺客伍六七》。<br>今年要出第二季，愣着干嘛？追啊！</p>\n<h2 id=\"《画江湖之不良人》\"><a href=\"#《画江湖之不良人》\" class=\"headerlink\" title=\"《画江湖之不良人》\"></a>《画江湖之不良人》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/bu-liang-ren.jpeg\" alt=\"不良人\"></p>\n<p>追到第三季啦！从第二季开始追的，剧情还是很好看的。《不良人》也能代表中国动漫的高水平了。虽然官方把格局越铺越大，支线剧情也越来越多。但是，第三季有了很大的进步。我看剧不懂得分析人物，但是感觉得到男主这一季真的成熟很多。比起之前，我更喜欢现在这样更成熟更有担当的样子。<br>剧情好看就行了嘛，人物塑造得也挺饱满的~我最喜欢蚩梦啦！<br>（海报没找到合适的，私心放一张蚩梦。官方爸爸听到了吗？求你们出一张好点的全员海报吧！）</p>\n<h2 id=\"《3年A班-现在开始，全员人质》\"><a href=\"#《3年A班-现在开始，全员人质》\" class=\"headerlink\" title=\"《3年A班-现在开始，全员人质》\"></a>《3年A班-现在开始，全员人质》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/3-nian-a-ban.jpg\" alt=\"3年a班\"><br><strong>没什么剧透，放心往下看</strong></p>\n<p>在追。苏打凉太都很帅我就不多说了。剧情一直在反转，很精彩。苏打饰演的柊一飒策划一起犯罪，让全班同学去揭开另一个案件的真相。小飒让学生都得到了改变，也讲了一个教师应该怎么去引导学生。<br>我看下来印象最深的是这句话：“学生只能看到三步以内的未来。”<br>的确是这样，我没有碰到给我讲三步以后的未来的老师，也或许是当时看到三步以内未来的我根本就听不进去吧。<br>作为学生，我也想要想苏打这样的老师啊！</p>\n<h2 id=\"《请回答1988》\"><a href=\"#《请回答1988》\" class=\"headerlink\" title=\"《请回答1988》\"></a>《请回答1988》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/qing-hui-da-1988.jpg\" alt=\"请回答1988\"><br>真的真的很好看。剧里的每一个人都非常的鲜活，让你感觉就在自己身边。剧中的故事就好像是发生在自己身上的事，平平淡淡又有哭有笑。这个有机会捡几集好好写写剧评。<br>有很多感同身受的故事，我看得哭。能引起共鸣的剧最难得吧，这就是这部剧的魅力所在。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>看了三集《我的英雄学园》，充满热血的追梦故事。不合我的胃口-ω-<br>看了三集《高岭之花》，十元女士我喜欢你，但是这部剧我不喜欢-ω-</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>第一次写影评/剧评，实在是词穷…orz<br>没想到写起来这么花时间，下次要挑着写了！主要是因为真的不会写。那么多片放一起，居然能写到将近两千字，看到这里的你们可真棒！<br>希望下个月能继续有观影看剧分享，再加上阅读和手账分享。在此许（wa）愿（keng）~以及最近思想上有一个很大的转变，也想写出来！</p>\n<p>PS：达成在二月三更成就！下个月开始准备考研了，我又要回到年更博主的身份了。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>流浪地球、飞驰人生、我是大哥大、3年A班、刺客伍六七、请回答1988</p>","more":"<hr>\n<h2 id=\"写在最前面\"><a href=\"#写在最前面\" class=\"headerlink\" title=\"写在最前面\"></a>写在最前面</h2><p>总结一下，推荐你们《流浪地球》，《刺客伍六七》，《请回答1988》<br>第一次写，没好好斟酌词句，还请各位读者宽容一下~</p>\n<h2 id=\"《流浪地球》\"><a href=\"#《流浪地球》\" class=\"headerlink\" title=\"《流浪地球》\"></a>《流浪地球》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/liu-lang-di-qiu.png\" alt=\"流浪地球\"><br>春节档里话题屠榜的电影。<br>看之前，一个朋友跟我说：“你喜欢天文的话，那你喜不喜欢科幻小说电影？”然后就跟我推荐了《流浪地球》，也给我推荐了小刘的书还有《星际穿越》。<br>高中看过一点《星际穿越》，但是的确没怎么接触科幻题材的。<br>这次第一次去电影院看科幻灾难片，感觉还是很爽的！看到天边被放大的木星而激动，也为片中人物的丧生而落泪。<br>说说个人感受，的确算是中国科幻片的一个里程碑吧，是一个标志着开始的里程碑。到目前为止，优秀科幻片中几乎都是欧美面孔。而《流浪地球》就是开创了这样的一条先河。它不是最好的，但是给后面的中国科幻电影起了个好头。<br>在现在电影水片很多的大形势下，我们需要这样的认真的电影。<br>当然啦，还是有很长的路要走呢~</p>\n<h2 id=\"《飞驰人生》\"><a href=\"#《飞驰人生》\" class=\"headerlink\" title=\"《飞驰人生》\"></a>《飞驰人生》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/fei-chi-ren-sheng.jpg\" alt=\"飞驰人生\"><br>和两个高中姐妹一起去看的，临时决定。<br>看前，我只知道阿信唱了片尾曲。在电影院听到阿信的声音还是超开心！<br>看完之后，没什么很大的感觉。带着追梦情怀的喜剧片。沈叔叔长得就很好笑。黄景瑜也太帅了！这部是那种我没事的时候，不会找来看的影片。<br>最精彩的部分就是阿信唱歌了！<br>次精彩的部分就是中间汽车零件的特效！<br>我感觉现在很多电影里都会有一些太刻意的搞笑。我讲不清，但是大概就是这个意思。</p>\n<h2 id=\"《我是大哥大》\"><a href=\"#《我是大哥大》\" class=\"headerlink\" title=\"《我是大哥大》\"></a>《我是大哥大》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/wo-shi-da-ge-da.png\" alt=\"我是大哥大\"><br>很热门的日剧。全员颜艺，有的情节真的很好笑我会倒回去看好几遍。剧组也特别欢乐，我也去找了片场花絮看。<br>伊藤三桥京子理子都好帅！今井好好笑！这是不良之间的友情啊~全剧就是打架骂人谈恋爱。<br>(一部沙雕剧的剧评我实在写不下去了告辞…)<br>看到了一篇文章，剧里其实有好多好多梗啊！<br><a href=\"https://www.gcores.com/articles/104945\">《我是大哥大》绝不只是一部沙雕剧这么简单 |机核</a></p>\n<h2 id=\"《刺客伍六七》\"><a href=\"#《刺客伍六七》\" class=\"headerlink\" title=\"《刺客伍六七》\"></a>《刺客伍六七》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ci-ke-wu-liu-qi.png\" alt=\"刺客伍六七\"><br>“我今天就要带她走，我看谁敢拦我。”<br>这是阿七在最后一集对梅花说的话。帅炸了！<br>这部国漫讲阿七做刺客的时候发生的事情，以及他慢慢唤醒的记忆。非常期待今年的第二季，正如制作组在第一季片尾说的：“不用完结撒花，阿七的故事才刚刚开始。”<br>每一个任务可能都有些奇怪也有些搞笑，阿七是一个有自己原则的刺客。<br>他作为一个刺客，但不是谁都杀。<br>片尾曲很喜欢：“无论你样子是多么怪异，我还是会喜欢你。”</p>\n<p><strong>以下内容涉及严重剧透！</strong><br><strong>以下内容涉及严重剧透！</strong><br><strong>以下内容涉及严重剧透！</strong><br>每一集虽然制作的简单，但是有几集的内涵还是很深刻的。我很喜欢这部国漫。为内裤哥仗义出手，没偷没抢只是爱好不同又有什么错。为小咪和小汪解开心结，不管什么事，不说出来就永远不会知道彼此的心意。陪伴绝症女孩，最后得知真相没有杀她。阿婆虽然做尽了恶，但因为一些原因在阿婆要死的时候挡下了飞镖。（这集有点争议，但是豆瓣上的一篇文章分析地很好）最后为了保护这个小岛，虽然对手极强但依然出手相救。<br><strong>剧透结束！</strong></p>\n<p>总而言之，很推荐你们去看《刺客伍六七》。<br>今年要出第二季，愣着干嘛？追啊！</p>\n<h2 id=\"《画江湖之不良人》\"><a href=\"#《画江湖之不良人》\" class=\"headerlink\" title=\"《画江湖之不良人》\"></a>《画江湖之不良人》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/bu-liang-ren.jpeg\" alt=\"不良人\"></p>\n<p>追到第三季啦！从第二季开始追的，剧情还是很好看的。《不良人》也能代表中国动漫的高水平了。虽然官方把格局越铺越大，支线剧情也越来越多。但是，第三季有了很大的进步。我看剧不懂得分析人物，但是感觉得到男主这一季真的成熟很多。比起之前，我更喜欢现在这样更成熟更有担当的样子。<br>剧情好看就行了嘛，人物塑造得也挺饱满的~我最喜欢蚩梦啦！<br>（海报没找到合适的，私心放一张蚩梦。官方爸爸听到了吗？求你们出一张好点的全员海报吧！）</p>\n<h2 id=\"《3年A班-现在开始，全员人质》\"><a href=\"#《3年A班-现在开始，全员人质》\" class=\"headerlink\" title=\"《3年A班-现在开始，全员人质》\"></a>《3年A班-现在开始，全员人质》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/3-nian-a-ban.jpg\" alt=\"3年a班\"><br><strong>没什么剧透，放心往下看</strong></p>\n<p>在追。苏打凉太都很帅我就不多说了。剧情一直在反转，很精彩。苏打饰演的柊一飒策划一起犯罪，让全班同学去揭开另一个案件的真相。小飒让学生都得到了改变，也讲了一个教师应该怎么去引导学生。<br>我看下来印象最深的是这句话：“学生只能看到三步以内的未来。”<br>的确是这样，我没有碰到给我讲三步以后的未来的老师，也或许是当时看到三步以内未来的我根本就听不进去吧。<br>作为学生，我也想要想苏打这样的老师啊！</p>\n<h2 id=\"《请回答1988》\"><a href=\"#《请回答1988》\" class=\"headerlink\" title=\"《请回答1988》\"></a>《请回答1988》</h2><p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/qing-hui-da-1988.jpg\" alt=\"请回答1988\"><br>真的真的很好看。剧里的每一个人都非常的鲜活，让你感觉就在自己身边。剧中的故事就好像是发生在自己身上的事，平平淡淡又有哭有笑。这个有机会捡几集好好写写剧评。<br>有很多感同身受的故事，我看得哭。能引起共鸣的剧最难得吧，这就是这部剧的魅力所在。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>看了三集《我的英雄学园》，充满热血的追梦故事。不合我的胃口-ω-<br>看了三集《高岭之花》，十元女士我喜欢你，但是这部剧我不喜欢-ω-</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>第一次写影评/剧评，实在是词穷…orz<br>没想到写起来这么花时间，下次要挑着写了！主要是因为真的不会写。那么多片放一起，居然能写到将近两千字，看到这里的你们可真棒！<br>希望下个月能继续有观影看剧分享，再加上阅读和手账分享。在此许（wa）愿（keng）~以及最近思想上有一个很大的转变，也想写出来！</p>\n<p>PS：达成在二月三更成就！下个月开始准备考研了，我又要回到年更博主的身份了。</p>"},{"title":"四月读书观影分享","date":"2019-05-04T11:34:15.000Z","_content":"\n《请回答1988》，《爱，死亡，机器人》，《成为香奈儿》，《雷霆沙赞》，《3年A班》\n\n<!--more-->\n\n---\n\n\n\n## 《爱，死亡，机器人》\n为了紧跟潮流，我也去看了。是值得几刷的剧。每一集的感觉都不一样，从画风、故事主题都非常丰富。\n还没看完，有的地方对我来说有点血腥。成人动画里才会有的，把所有美好的东西破坏给你看。\n\n## 《成为香奈儿》\n无意间在图书馆中看到的书，看到了最后一章。\n香奈儿女士真的很厉害。这本书的真实性暂且不论，也不知道Coco是不是真的这么风流，这样的女人还是保持成一个谜好了。她非常清楚自己想要的是什么，也非常清楚自己拥有的是什么。当然她也有过迷茫，有过怀疑，但是她终究能坚持自我，创造出自己的帝国。她凭借着自己的智慧，获得她想要的一切。\n“生活未曾取悦于我，因此我创造了生活。”她身上那种桀骜不驯的魅力极为吸引我。她的一生真的成为了传奇，永久流传。\nPS：很想闻一下Chanel N5° 香水\nPPS：想看看Chanel本人设计的衣服。书里一张插图都没有，这点不好。毕竟是搞时尚的，起码放两件服装的照片嘛~\n\n**没看过《请回答1988》的但是会去看的，或者正在看的还不知道结局的请马上关掉本页面。**\n除非你真的不care剧透。\n\n## 《请回答1988》\n没错，这是一部我看了三个月还没看完的剧。\n突然在微博上看到剧透，我搁了好久才重新开始看。一部剧没看完，就不要通过任何方式对任何问题搜索！！！否则别怪我没提醒你！！！\n**包括我这篇，你还没看的话，建议你到这里就别看了！！！**\n\n我真的哭了，这部韩剧没问题非常的好看。只是...\n为什么最后德善和阿泽在一起了啊！！！狗焕你为什么不去表白！！！啊！！！到最后才说！！！还开玩笑地表了白？我真的哭了！！！爆哭！！！\n“让我错过初恋的，不是捉弄人的红绿灯，而是我无数次的犹豫不决。”\n靠！！！\n个人原因，没办法写剧评了，让我缓缓。截止发稿，还差最后两集。\n呜呜呜，等我看完下一篇再来好好写剧评吧，呜呜呜\n\n## 《雷霆沙赞》\n\n我对超级英雄片没太大感觉，只是每次看都很爽，觉得自己也有超能力就好了好帅啊哈哈哈哈哈\n这片挺搞笑的，然后我很想摸摸男主变身后的肌肉（逃\n\n## 《3年A班》\n\n看完啦，最后讲的是网络暴力。这东西真的很可怕，在网上似乎真的言论“自由”了。每个人都不用为自己说的话承担责任。每个人只要跟随大众，不管说好说坏，跟自己都没有什么关系似的。每个人都不用去了解清楚事情的真相，凭借自己的想象和他人的言论，就可以随意攻击。\n看完这片，我也反思了一下自己。我也的确是个不了解事情真相，就会随大流发表自己言论的人。\n对于网上的事，还是要在了解真相后，在思考后，再说话吧！\n**Let's think!\n\n## 后记\n5.24 五月天演唱会大电影就要上映了，欢迎大家去电影院支持我第一部参演的电影~\n五月会很忙，但其实也还好，希望自己能调整好。\n五月影单《星际穿越》\n五月书单《成为香奈儿》，《数学之美》\n\n另，今天正好是五四运动百年纪念日。我有时候会想，当代学生是否还会有当年学生的那种血性。","source":"_posts/四月读书观影分享.md","raw":"---\ntitle: 四月读书观影分享\ndate: 2019-05-04 19:34:15\ncategories: 生活Life\n---\n\n《请回答1988》，《爱，死亡，机器人》，《成为香奈儿》，《雷霆沙赞》，《3年A班》\n\n<!--more-->\n\n---\n\n\n\n## 《爱，死亡，机器人》\n为了紧跟潮流，我也去看了。是值得几刷的剧。每一集的感觉都不一样，从画风、故事主题都非常丰富。\n还没看完，有的地方对我来说有点血腥。成人动画里才会有的，把所有美好的东西破坏给你看。\n\n## 《成为香奈儿》\n无意间在图书馆中看到的书，看到了最后一章。\n香奈儿女士真的很厉害。这本书的真实性暂且不论，也不知道Coco是不是真的这么风流，这样的女人还是保持成一个谜好了。她非常清楚自己想要的是什么，也非常清楚自己拥有的是什么。当然她也有过迷茫，有过怀疑，但是她终究能坚持自我，创造出自己的帝国。她凭借着自己的智慧，获得她想要的一切。\n“生活未曾取悦于我，因此我创造了生活。”她身上那种桀骜不驯的魅力极为吸引我。她的一生真的成为了传奇，永久流传。\nPS：很想闻一下Chanel N5° 香水\nPPS：想看看Chanel本人设计的衣服。书里一张插图都没有，这点不好。毕竟是搞时尚的，起码放两件服装的照片嘛~\n\n**没看过《请回答1988》的但是会去看的，或者正在看的还不知道结局的请马上关掉本页面。**\n除非你真的不care剧透。\n\n## 《请回答1988》\n没错，这是一部我看了三个月还没看完的剧。\n突然在微博上看到剧透，我搁了好久才重新开始看。一部剧没看完，就不要通过任何方式对任何问题搜索！！！否则别怪我没提醒你！！！\n**包括我这篇，你还没看的话，建议你到这里就别看了！！！**\n\n我真的哭了，这部韩剧没问题非常的好看。只是...\n为什么最后德善和阿泽在一起了啊！！！狗焕你为什么不去表白！！！啊！！！到最后才说！！！还开玩笑地表了白？我真的哭了！！！爆哭！！！\n“让我错过初恋的，不是捉弄人的红绿灯，而是我无数次的犹豫不决。”\n靠！！！\n个人原因，没办法写剧评了，让我缓缓。截止发稿，还差最后两集。\n呜呜呜，等我看完下一篇再来好好写剧评吧，呜呜呜\n\n## 《雷霆沙赞》\n\n我对超级英雄片没太大感觉，只是每次看都很爽，觉得自己也有超能力就好了好帅啊哈哈哈哈哈\n这片挺搞笑的，然后我很想摸摸男主变身后的肌肉（逃\n\n## 《3年A班》\n\n看完啦，最后讲的是网络暴力。这东西真的很可怕，在网上似乎真的言论“自由”了。每个人都不用为自己说的话承担责任。每个人只要跟随大众，不管说好说坏，跟自己都没有什么关系似的。每个人都不用去了解清楚事情的真相，凭借自己的想象和他人的言论，就可以随意攻击。\n看完这片，我也反思了一下自己。我也的确是个不了解事情真相，就会随大流发表自己言论的人。\n对于网上的事，还是要在了解真相后，在思考后，再说话吧！\n**Let's think!\n\n## 后记\n5.24 五月天演唱会大电影就要上映了，欢迎大家去电影院支持我第一部参演的电影~\n五月会很忙，但其实也还好，希望自己能调整好。\n五月影单《星际穿越》\n五月书单《成为香奈儿》，《数学之美》\n\n另，今天正好是五四运动百年纪念日。我有时候会想，当代学生是否还会有当年学生的那种血性。","slug":"四月读书观影分享","published":1,"updated":"2019-05-04T11:34:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeagh5002b38t4e7uobrld","content":"<p>《请回答1988》，《爱，死亡，机器人》，《成为香奈儿》，《雷霆沙赞》，《3年A班》</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"《爱，死亡，机器人》\"><a href=\"#《爱，死亡，机器人》\" class=\"headerlink\" title=\"《爱，死亡，机器人》\"></a>《爱，死亡，机器人》</h2><p>为了紧跟潮流，我也去看了。是值得几刷的剧。每一集的感觉都不一样，从画风、故事主题都非常丰富。<br>还没看完，有的地方对我来说有点血腥。成人动画里才会有的，把所有美好的东西破坏给你看。</p>\n<h2 id=\"《成为香奈儿》\"><a href=\"#《成为香奈儿》\" class=\"headerlink\" title=\"《成为香奈儿》\"></a>《成为香奈儿》</h2><p>无意间在图书馆中看到的书，看到了最后一章。<br>香奈儿女士真的很厉害。这本书的真实性暂且不论，也不知道Coco是不是真的这么风流，这样的女人还是保持成一个谜好了。她非常清楚自己想要的是什么，也非常清楚自己拥有的是什么。当然她也有过迷茫，有过怀疑，但是她终究能坚持自我，创造出自己的帝国。她凭借着自己的智慧，获得她想要的一切。<br>“生活未曾取悦于我，因此我创造了生活。”她身上那种桀骜不驯的魅力极为吸引我。她的一生真的成为了传奇，永久流传。<br>PS：很想闻一下Chanel N5° 香水<br>PPS：想看看Chanel本人设计的衣服。书里一张插图都没有，这点不好。毕竟是搞时尚的，起码放两件服装的照片嘛~</p>\n<p><strong>没看过《请回答1988》的但是会去看的，或者正在看的还不知道结局的请马上关掉本页面。</strong><br>除非你真的不care剧透。</p>\n<h2 id=\"《请回答1988》\"><a href=\"#《请回答1988》\" class=\"headerlink\" title=\"《请回答1988》\"></a>《请回答1988》</h2><p>没错，这是一部我看了三个月还没看完的剧。<br>突然在微博上看到剧透，我搁了好久才重新开始看。一部剧没看完，就不要通过任何方式对任何问题搜索！！！否则别怪我没提醒你！！！<br><strong>包括我这篇，你还没看的话，建议你到这里就别看了！！！</strong></p>\n<p>我真的哭了，这部韩剧没问题非常的好看。只是…<br>为什么最后德善和阿泽在一起了啊！！！狗焕你为什么不去表白！！！啊！！！到最后才说！！！还开玩笑地表了白？我真的哭了！！！爆哭！！！<br>“让我错过初恋的，不是捉弄人的红绿灯，而是我无数次的犹豫不决。”<br>靠！！！<br>个人原因，没办法写剧评了，让我缓缓。截止发稿，还差最后两集。<br>呜呜呜，等我看完下一篇再来好好写剧评吧，呜呜呜</p>\n<h2 id=\"《雷霆沙赞》\"><a href=\"#《雷霆沙赞》\" class=\"headerlink\" title=\"《雷霆沙赞》\"></a>《雷霆沙赞》</h2><p>我对超级英雄片没太大感觉，只是每次看都很爽，觉得自己也有超能力就好了好帅啊哈哈哈哈哈<br>这片挺搞笑的，然后我很想摸摸男主变身后的肌肉（逃</p>\n<h2 id=\"《3年A班》\"><a href=\"#《3年A班》\" class=\"headerlink\" title=\"《3年A班》\"></a>《3年A班》</h2><p>看完啦，最后讲的是网络暴力。这东西真的很可怕，在网上似乎真的言论“自由”了。每个人都不用为自己说的话承担责任。每个人只要跟随大众，不管说好说坏，跟自己都没有什么关系似的。每个人都不用去了解清楚事情的真相，凭借自己的想象和他人的言论，就可以随意攻击。<br>看完这片，我也反思了一下自己。我也的确是个不了解事情真相，就会随大流发表自己言论的人。<br>对于网上的事，还是要在了解真相后，在思考后，再说话吧！<br>**Let’s think!</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>5.24 五月天演唱会大电影就要上映了，欢迎大家去电影院支持我第一部参演的电影~<br>五月会很忙，但其实也还好，希望自己能调整好。<br>五月影单《星际穿越》<br>五月书单《成为香奈儿》，《数学之美》</p>\n<p>另，今天正好是五四运动百年纪念日。我有时候会想，当代学生是否还会有当年学生的那种血性。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>《请回答1988》，《爱，死亡，机器人》，《成为香奈儿》，《雷霆沙赞》，《3年A班》</p>","more":"<hr>\n<h2 id=\"《爱，死亡，机器人》\"><a href=\"#《爱，死亡，机器人》\" class=\"headerlink\" title=\"《爱，死亡，机器人》\"></a>《爱，死亡，机器人》</h2><p>为了紧跟潮流，我也去看了。是值得几刷的剧。每一集的感觉都不一样，从画风、故事主题都非常丰富。<br>还没看完，有的地方对我来说有点血腥。成人动画里才会有的，把所有美好的东西破坏给你看。</p>\n<h2 id=\"《成为香奈儿》\"><a href=\"#《成为香奈儿》\" class=\"headerlink\" title=\"《成为香奈儿》\"></a>《成为香奈儿》</h2><p>无意间在图书馆中看到的书，看到了最后一章。<br>香奈儿女士真的很厉害。这本书的真实性暂且不论，也不知道Coco是不是真的这么风流，这样的女人还是保持成一个谜好了。她非常清楚自己想要的是什么，也非常清楚自己拥有的是什么。当然她也有过迷茫，有过怀疑，但是她终究能坚持自我，创造出自己的帝国。她凭借着自己的智慧，获得她想要的一切。<br>“生活未曾取悦于我，因此我创造了生活。”她身上那种桀骜不驯的魅力极为吸引我。她的一生真的成为了传奇，永久流传。<br>PS：很想闻一下Chanel N5° 香水<br>PPS：想看看Chanel本人设计的衣服。书里一张插图都没有，这点不好。毕竟是搞时尚的，起码放两件服装的照片嘛~</p>\n<p><strong>没看过《请回答1988》的但是会去看的，或者正在看的还不知道结局的请马上关掉本页面。</strong><br>除非你真的不care剧透。</p>\n<h2 id=\"《请回答1988》\"><a href=\"#《请回答1988》\" class=\"headerlink\" title=\"《请回答1988》\"></a>《请回答1988》</h2><p>没错，这是一部我看了三个月还没看完的剧。<br>突然在微博上看到剧透，我搁了好久才重新开始看。一部剧没看完，就不要通过任何方式对任何问题搜索！！！否则别怪我没提醒你！！！<br><strong>包括我这篇，你还没看的话，建议你到这里就别看了！！！</strong></p>\n<p>我真的哭了，这部韩剧没问题非常的好看。只是…<br>为什么最后德善和阿泽在一起了啊！！！狗焕你为什么不去表白！！！啊！！！到最后才说！！！还开玩笑地表了白？我真的哭了！！！爆哭！！！<br>“让我错过初恋的，不是捉弄人的红绿灯，而是我无数次的犹豫不决。”<br>靠！！！<br>个人原因，没办法写剧评了，让我缓缓。截止发稿，还差最后两集。<br>呜呜呜，等我看完下一篇再来好好写剧评吧，呜呜呜</p>\n<h2 id=\"《雷霆沙赞》\"><a href=\"#《雷霆沙赞》\" class=\"headerlink\" title=\"《雷霆沙赞》\"></a>《雷霆沙赞》</h2><p>我对超级英雄片没太大感觉，只是每次看都很爽，觉得自己也有超能力就好了好帅啊哈哈哈哈哈<br>这片挺搞笑的，然后我很想摸摸男主变身后的肌肉（逃</p>\n<h2 id=\"《3年A班》\"><a href=\"#《3年A班》\" class=\"headerlink\" title=\"《3年A班》\"></a>《3年A班》</h2><p>看完啦，最后讲的是网络暴力。这东西真的很可怕，在网上似乎真的言论“自由”了。每个人都不用为自己说的话承担责任。每个人只要跟随大众，不管说好说坏，跟自己都没有什么关系似的。每个人都不用去了解清楚事情的真相，凭借自己的想象和他人的言论，就可以随意攻击。<br>看完这片，我也反思了一下自己。我也的确是个不了解事情真相，就会随大流发表自己言论的人。<br>对于网上的事，还是要在了解真相后，在思考后，再说话吧！<br>**Let’s think!</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>5.24 五月天演唱会大电影就要上映了，欢迎大家去电影院支持我第一部参演的电影~<br>五月会很忙，但其实也还好，希望自己能调整好。<br>五月影单《星际穿越》<br>五月书单《成为香奈儿》，《数学之美》</p>\n<p>另，今天正好是五四运动百年纪念日。我有时候会想，当代学生是否还会有当年学生的那种血性。</p>"},{"title":"在用hexo和github搭建个人博客中遇到的问题及解决办法","date":"2018-04-16T11:04:53.000Z","_content":"博客搭建前前后后遇到了不少问题，挺花时间的。现在做个总结和记录，或许也能帮到后来的人。\n<!--more-->\n---\n## **博客部署问题**\n> **部署莫名失败**\n\n当时Git的local无法使用，错误大致显示为这样：\n![deploy][1]\n最后发现是因为我换了一个管理员登录，无法部署。再换回来就好啦。\n\n\n\n\n## __博客评论功能__\n> **友言评论无法显示**\n\n之前试过__友言__，在手机端以及本地博客都能正常显示，可是__在PC端远程网站上无法显示__。最后发现可能是因为友言__不支持https__，只能作罢。另外，据说畅言也不支持https。\n解决办法是**换一个**！目前使用的是来必力，但是加载比较慢，其他都好。\n之后或许能尝试一下自己搭建一个评论功能。\n\n## __安全证书失效__\n> **无法进入自己的博客，Chrome显示“您的连接不是私密连接”**\n\n本来还以为自己的网站被黑了呢之类的，后来知道了像我这样的静态网页是不存在这种问题的，不太需要考虑安全问题。最后发现是github颁发给我的证书过期了。\n去网上搜索了一下，说通常过两天就自动更新了（我过期五天了）；有说直接找github客服解决，几小时就好；有说是http和https的问题\n解决办法是更新域名解析。方法跟当初绑定域名的一样。ping一下自己的blog，返回的一个IP值，就是github主机的IP值\n![ping][3]\n然后去域名解析的地方设置一下这个IP：\n![resolve][4]\n关于这些记录类型和主机记录的含义，参见阿里云的[帮助文档](https://help.aliyun.com/document_detail/29716.html)\n\n## __更换电脑__\n> 适用于保留原文件夹的情况\n\n前提是安装了nodejs，hexo，然后只要在原来的文件夹下面npm install 就可以啦。\n\n## __更换域名__\n> 用阿里云上买的域名\n\n之前的cosmos227.xyz过期啦，一看续费要69，索性换了一个.top的~\n买完域名之后，你只要上阿里云的控制台上，给你购买的域名添加记录值就可以了。添加什么值，见上面那个设置IP的图~\n\n## 链接已重置\n\n遇到这个问题已经有两周了。本来以为等等就好，但是一直没好！目前网上的方法有：\n\n1. Chrome的问题。在`chrome://net-internals/#hsts`里加入需要的域名。参考[chrome无法访问此网站 - 知乎](https://zhuanlan.zhihu.com/p/71261322)\n2. 修改host，加入github相关的解析。（地址是`C:\\Windows\\System32\\drivers\\etc\\host`，host文件保存域名和IP的映射，可以直接访问IP，就不用等待域名服务器的解析了，参见[windows下的host文件在哪里，有什么作用?](https://blog.csdn.net/xifeijian/article/details/15660185)）\n\n但是都不行，而且换个设备也登不上去。应该是网站本身的问题。\n\n连接已重置的根本原因？[浏览器显示“连接已重置”的根本原因是什么？ - 知乎](https://www.zhihu.com/question/61870898)\n\n什么是TLS？[SSL/TLS协议运行机制的概述 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)\n\n找到这个[GitHub Pages (*.github.io) TLS劫持和连接重置问题 | Heary's Blog](https://heary.cn/posts/GitHub-Pages-github-io-TLS%E5%8A%AB%E6%8C%81%E5%92%8C%E8%BF%9E%E6%8E%A5%E9%87%8D%E7%BD%AE%E9%97%AE%E9%A2%98/)，但是依然没有解决我的问题，我的证书没有问题啊~\n\n感觉我网站也不是被墙了，搭了梯子访问也还是访问不了\n\n## 小结\n\n>遇到问题的时候，不能放过任何一个可能的错误并且找到对应解决方法。\n\nPS0:拖延如我，在时隔两个月之后找到了当初写的这篇草稿...已经忘了不少了，不够全面，先挖个坑等我记起来来填！（不会了...\nPS1:更于0719，添加了安全证书的问题\nPS2:更于20190215，添加了更换电脑后如何继续更新博客\nPS3:更于20190327，添加了如何更换域名\n\nPS4:更于20210607，添加了如何解决连接已重置\n\n[1]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog1.jpg\n[2]: https://help.aliyun.com/document_detail/29716.html\n[3]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog2.jpg\n[4]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog3.jpg","source":"_posts/在用hexo和github搭建个人博客中遇到的问题及解决办法.md","raw":"---\ntitle: 在用hexo和github搭建个人博客中遇到的问题及解决办法\ndate: 2018-04-16 19:04:53\ntags: 搭建博客\ncategories: 问题解决SolvedProblems\n---\n博客搭建前前后后遇到了不少问题，挺花时间的。现在做个总结和记录，或许也能帮到后来的人。\n<!--more-->\n---\n## **博客部署问题**\n> **部署莫名失败**\n\n当时Git的local无法使用，错误大致显示为这样：\n![deploy][1]\n最后发现是因为我换了一个管理员登录，无法部署。再换回来就好啦。\n\n\n\n\n## __博客评论功能__\n> **友言评论无法显示**\n\n之前试过__友言__，在手机端以及本地博客都能正常显示，可是__在PC端远程网站上无法显示__。最后发现可能是因为友言__不支持https__，只能作罢。另外，据说畅言也不支持https。\n解决办法是**换一个**！目前使用的是来必力，但是加载比较慢，其他都好。\n之后或许能尝试一下自己搭建一个评论功能。\n\n## __安全证书失效__\n> **无法进入自己的博客，Chrome显示“您的连接不是私密连接”**\n\n本来还以为自己的网站被黑了呢之类的，后来知道了像我这样的静态网页是不存在这种问题的，不太需要考虑安全问题。最后发现是github颁发给我的证书过期了。\n去网上搜索了一下，说通常过两天就自动更新了（我过期五天了）；有说直接找github客服解决，几小时就好；有说是http和https的问题\n解决办法是更新域名解析。方法跟当初绑定域名的一样。ping一下自己的blog，返回的一个IP值，就是github主机的IP值\n![ping][3]\n然后去域名解析的地方设置一下这个IP：\n![resolve][4]\n关于这些记录类型和主机记录的含义，参见阿里云的[帮助文档](https://help.aliyun.com/document_detail/29716.html)\n\n## __更换电脑__\n> 适用于保留原文件夹的情况\n\n前提是安装了nodejs，hexo，然后只要在原来的文件夹下面npm install 就可以啦。\n\n## __更换域名__\n> 用阿里云上买的域名\n\n之前的cosmos227.xyz过期啦，一看续费要69，索性换了一个.top的~\n买完域名之后，你只要上阿里云的控制台上，给你购买的域名添加记录值就可以了。添加什么值，见上面那个设置IP的图~\n\n## 链接已重置\n\n遇到这个问题已经有两周了。本来以为等等就好，但是一直没好！目前网上的方法有：\n\n1. Chrome的问题。在`chrome://net-internals/#hsts`里加入需要的域名。参考[chrome无法访问此网站 - 知乎](https://zhuanlan.zhihu.com/p/71261322)\n2. 修改host，加入github相关的解析。（地址是`C:\\Windows\\System32\\drivers\\etc\\host`，host文件保存域名和IP的映射，可以直接访问IP，就不用等待域名服务器的解析了，参见[windows下的host文件在哪里，有什么作用?](https://blog.csdn.net/xifeijian/article/details/15660185)）\n\n但是都不行，而且换个设备也登不上去。应该是网站本身的问题。\n\n连接已重置的根本原因？[浏览器显示“连接已重置”的根本原因是什么？ - 知乎](https://www.zhihu.com/question/61870898)\n\n什么是TLS？[SSL/TLS协议运行机制的概述 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)\n\n找到这个[GitHub Pages (*.github.io) TLS劫持和连接重置问题 | Heary's Blog](https://heary.cn/posts/GitHub-Pages-github-io-TLS%E5%8A%AB%E6%8C%81%E5%92%8C%E8%BF%9E%E6%8E%A5%E9%87%8D%E7%BD%AE%E9%97%AE%E9%A2%98/)，但是依然没有解决我的问题，我的证书没有问题啊~\n\n感觉我网站也不是被墙了，搭了梯子访问也还是访问不了\n\n## 小结\n\n>遇到问题的时候，不能放过任何一个可能的错误并且找到对应解决方法。\n\nPS0:拖延如我，在时隔两个月之后找到了当初写的这篇草稿...已经忘了不少了，不够全面，先挖个坑等我记起来来填！（不会了...\nPS1:更于0719，添加了安全证书的问题\nPS2:更于20190215，添加了更换电脑后如何继续更新博客\nPS3:更于20190327，添加了如何更换域名\n\nPS4:更于20210607，添加了如何解决连接已重置\n\n[1]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog1.jpg\n[2]: https://help.aliyun.com/document_detail/29716.html\n[3]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog2.jpg\n[4]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog3.jpg","slug":"在用hexo和github搭建个人博客中遇到的问题及解决办法","published":1,"updated":"2018-04-16T11:04:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeagh5002f38t40xv53ean","content":"<p>博客搭建前前后后遇到了不少问题，挺花时间的。现在做个总结和记录，或许也能帮到后来的人。</p>\n<span id=\"more\"></span>\n<hr>\n<h2 id=\"博客部署问题\"><a href=\"#博客部署问题\" class=\"headerlink\" title=\"博客部署问题\"></a><strong>博客部署问题</strong></h2><blockquote>\n<p><strong>部署莫名失败</strong></p>\n</blockquote>\n<p>当时Git的local无法使用，错误大致显示为这样：<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog1.jpg\" alt=\"deploy\"><br>最后发现是因为我换了一个管理员登录，无法部署。再换回来就好啦。</p>\n<h2 id=\"博客评论功能\"><a href=\"#博客评论功能\" class=\"headerlink\" title=\"博客评论功能\"></a><strong>博客评论功能</strong></h2><blockquote>\n<p><strong>友言评论无法显示</strong></p>\n</blockquote>\n<p>之前试过__友言__，在手机端以及本地博客都能正常显示，可是__在PC端远程网站上无法显示__。最后发现可能是因为友言__不支持https__，只能作罢。另外，据说畅言也不支持https。<br>解决办法是<strong>换一个</strong>！目前使用的是来必力，但是加载比较慢，其他都好。<br>之后或许能尝试一下自己搭建一个评论功能。</p>\n<h2 id=\"安全证书失效\"><a href=\"#安全证书失效\" class=\"headerlink\" title=\"安全证书失效\"></a><strong>安全证书失效</strong></h2><blockquote>\n<p><strong>无法进入自己的博客，Chrome显示“您的连接不是私密连接”</strong></p>\n</blockquote>\n<p>本来还以为自己的网站被黑了呢之类的，后来知道了像我这样的静态网页是不存在这种问题的，不太需要考虑安全问题。最后发现是github颁发给我的证书过期了。<br>去网上搜索了一下，说通常过两天就自动更新了（我过期五天了）；有说直接找github客服解决，几小时就好；有说是http和https的问题<br>解决办法是更新域名解析。方法跟当初绑定域名的一样。ping一下自己的blog，返回的一个IP值，就是github主机的IP值<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog2.jpg\" alt=\"ping\"><br>然后去域名解析的地方设置一下这个IP：<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog3.jpg\" alt=\"resolve\"><br>关于这些记录类型和主机记录的含义，参见阿里云的<a href=\"https://help.aliyun.com/document_detail/29716.html\">帮助文档</a></p>\n<h2 id=\"更换电脑\"><a href=\"#更换电脑\" class=\"headerlink\" title=\"更换电脑\"></a><strong>更换电脑</strong></h2><blockquote>\n<p>适用于保留原文件夹的情况</p>\n</blockquote>\n<p>前提是安装了nodejs，hexo，然后只要在原来的文件夹下面npm install 就可以啦。</p>\n<h2 id=\"更换域名\"><a href=\"#更换域名\" class=\"headerlink\" title=\"更换域名\"></a><strong>更换域名</strong></h2><blockquote>\n<p>用阿里云上买的域名</p>\n</blockquote>\n<p>之前的cosmos227.xyz过期啦，一看续费要69，索性换了一个.top的~<br>买完域名之后，你只要上阿里云的控制台上，给你购买的域名添加记录值就可以了。添加什么值，见上面那个设置IP的图~</p>\n<h2 id=\"链接已重置\"><a href=\"#链接已重置\" class=\"headerlink\" title=\"链接已重置\"></a>链接已重置</h2><p>遇到这个问题已经有两周了。本来以为等等就好，但是一直没好！目前网上的方法有：</p>\n<ol>\n<li>Chrome的问题。在<code>chrome://net-internals/#hsts</code>里加入需要的域名。参考<a href=\"https://zhuanlan.zhihu.com/p/71261322\">chrome无法访问此网站 - 知乎</a></li>\n<li>修改host，加入github相关的解析。（地址是<code>C:\\Windows\\System32\\drivers\\etc\\host</code>，host文件保存域名和IP的映射，可以直接访问IP，就不用等待域名服务器的解析了，参见<a href=\"https://blog.csdn.net/xifeijian/article/details/15660185\">windows下的host文件在哪里，有什么作用?</a>）</li>\n</ol>\n<p>但是都不行，而且换个设备也登不上去。应该是网站本身的问题。</p>\n<p>连接已重置的根本原因？<a href=\"https://www.zhihu.com/question/61870898\">浏览器显示“连接已重置”的根本原因是什么？ - 知乎</a></p>\n<p>什么是TLS？<a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\">SSL/TLS协议运行机制的概述 - 阮一峰的网络日志</a></p>\n<p>找到这个<a href=\"https://heary.cn/posts/GitHub-Pages-github-io-TLS%E5%8A%AB%E6%8C%81%E5%92%8C%E8%BF%9E%E6%8E%A5%E9%87%8D%E7%BD%AE%E9%97%AE%E9%A2%98/\">GitHub Pages (*.github.io) TLS劫持和连接重置问题 | Heary’s Blog</a>，但是依然没有解决我的问题，我的证书没有问题啊~</p>\n<p>感觉我网站也不是被墙了，搭了梯子访问也还是访问不了</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><blockquote>\n<p>遇到问题的时候，不能放过任何一个可能的错误并且找到对应解决方法。</p>\n</blockquote>\n<p>PS0:拖延如我，在时隔两个月之后找到了当初写的这篇草稿…已经忘了不少了，不够全面，先挖个坑等我记起来来填！（不会了…<br>PS1:更于0719，添加了安全证书的问题<br>PS2:更于20190215，添加了更换电脑后如何继续更新博客<br>PS3:更于20190327，添加了如何更换域名</p>\n<p>PS4:更于20210607，添加了如何解决连接已重置</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>博客搭建前前后后遇到了不少问题，挺花时间的。现在做个总结和记录，或许也能帮到后来的人。</p>","more":"<hr>\n<h2 id=\"博客部署问题\"><a href=\"#博客部署问题\" class=\"headerlink\" title=\"博客部署问题\"></a><strong>博客部署问题</strong></h2><blockquote>\n<p><strong>部署莫名失败</strong></p>\n</blockquote>\n<p>当时Git的local无法使用，错误大致显示为这样：<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog1.jpg\" alt=\"deploy\"><br>最后发现是因为我换了一个管理员登录，无法部署。再换回来就好啦。</p>\n<h2 id=\"博客评论功能\"><a href=\"#博客评论功能\" class=\"headerlink\" title=\"博客评论功能\"></a><strong>博客评论功能</strong></h2><blockquote>\n<p><strong>友言评论无法显示</strong></p>\n</blockquote>\n<p>之前试过__友言__，在手机端以及本地博客都能正常显示，可是__在PC端远程网站上无法显示__。最后发现可能是因为友言__不支持https__，只能作罢。另外，据说畅言也不支持https。<br>解决办法是<strong>换一个</strong>！目前使用的是来必力，但是加载比较慢，其他都好。<br>之后或许能尝试一下自己搭建一个评论功能。</p>\n<h2 id=\"安全证书失效\"><a href=\"#安全证书失效\" class=\"headerlink\" title=\"安全证书失效\"></a><strong>安全证书失效</strong></h2><blockquote>\n<p><strong>无法进入自己的博客，Chrome显示“您的连接不是私密连接”</strong></p>\n</blockquote>\n<p>本来还以为自己的网站被黑了呢之类的，后来知道了像我这样的静态网页是不存在这种问题的，不太需要考虑安全问题。最后发现是github颁发给我的证书过期了。<br>去网上搜索了一下，说通常过两天就自动更新了（我过期五天了）；有说直接找github客服解决，几小时就好；有说是http和https的问题<br>解决办法是更新域名解析。方法跟当初绑定域名的一样。ping一下自己的blog，返回的一个IP值，就是github主机的IP值<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog2.jpg\" alt=\"ping\"><br>然后去域名解析的地方设置一下这个IP：<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/conblog3.jpg\" alt=\"resolve\"><br>关于这些记录类型和主机记录的含义，参见阿里云的<a href=\"https://help.aliyun.com/document_detail/29716.html\">帮助文档</a></p>\n<h2 id=\"更换电脑\"><a href=\"#更换电脑\" class=\"headerlink\" title=\"更换电脑\"></a><strong>更换电脑</strong></h2><blockquote>\n<p>适用于保留原文件夹的情况</p>\n</blockquote>\n<p>前提是安装了nodejs，hexo，然后只要在原来的文件夹下面npm install 就可以啦。</p>\n<h2 id=\"更换域名\"><a href=\"#更换域名\" class=\"headerlink\" title=\"更换域名\"></a><strong>更换域名</strong></h2><blockquote>\n<p>用阿里云上买的域名</p>\n</blockquote>\n<p>之前的cosmos227.xyz过期啦，一看续费要69，索性换了一个.top的~<br>买完域名之后，你只要上阿里云的控制台上，给你购买的域名添加记录值就可以了。添加什么值，见上面那个设置IP的图~</p>\n<h2 id=\"链接已重置\"><a href=\"#链接已重置\" class=\"headerlink\" title=\"链接已重置\"></a>链接已重置</h2><p>遇到这个问题已经有两周了。本来以为等等就好，但是一直没好！目前网上的方法有：</p>\n<ol>\n<li>Chrome的问题。在<code>chrome://net-internals/#hsts</code>里加入需要的域名。参考<a href=\"https://zhuanlan.zhihu.com/p/71261322\">chrome无法访问此网站 - 知乎</a></li>\n<li>修改host，加入github相关的解析。（地址是<code>C:\\Windows\\System32\\drivers\\etc\\host</code>，host文件保存域名和IP的映射，可以直接访问IP，就不用等待域名服务器的解析了，参见<a href=\"https://blog.csdn.net/xifeijian/article/details/15660185\">windows下的host文件在哪里，有什么作用?</a>）</li>\n</ol>\n<p>但是都不行，而且换个设备也登不上去。应该是网站本身的问题。</p>\n<p>连接已重置的根本原因？<a href=\"https://www.zhihu.com/question/61870898\">浏览器显示“连接已重置”的根本原因是什么？ - 知乎</a></p>\n<p>什么是TLS？<a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\">SSL/TLS协议运行机制的概述 - 阮一峰的网络日志</a></p>\n<p>找到这个<a href=\"https://heary.cn/posts/GitHub-Pages-github-io-TLS%E5%8A%AB%E6%8C%81%E5%92%8C%E8%BF%9E%E6%8E%A5%E9%87%8D%E7%BD%AE%E9%97%AE%E9%A2%98/\">GitHub Pages (*.github.io) TLS劫持和连接重置问题 | Heary’s Blog</a>，但是依然没有解决我的问题，我的证书没有问题啊~</p>\n<p>感觉我网站也不是被墙了，搭了梯子访问也还是访问不了</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><blockquote>\n<p>遇到问题的时候，不能放过任何一个可能的错误并且找到对应解决方法。</p>\n</blockquote>\n<p>PS0:拖延如我，在时隔两个月之后找到了当初写的这篇草稿…已经忘了不少了，不够全面，先挖个坑等我记起来来填！（不会了…<br>PS1:更于0719，添加了安全证书的问题<br>PS2:更于20190215，添加了更换电脑后如何继续更新博客<br>PS3:更于20190327，添加了如何更换域名</p>\n<p>PS4:更于20210607，添加了如何解决连接已重置</p>"},{"title":"如何做文献阅读笔记","date":"2021-04-11T14:51:57.000Z","_content":"\nGoogle时发现的一篇文章，来自多伦多大学。翻译过来学习一下~\n\n![cover_pic](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/cover_picture/5.png)\n\n<!--more-->\n\n原文地址：\n\n[Taking Notes from Research Reading | Writing Advice](https://advice.writing.utoronto.ca/researching/notes-from-research/)\n\n文章把记笔记分成了三个要点：\n\n> 1. 有目标地读文献\n> 2. 不用写太多\n> 3. 给笔记做上标签\n\n# 有目标地读文献\n\n要有目的地去读文献，清楚自己需要记录什么样的idea，这样一来可以把相关的idea分出来。具体来说一下四点：\n\n1. 对那你的领域（topic）有一个大致了解，如这个领域包括的思想和观点。\n2. 把你需要了解的子领域列出来。\n3. 选择你感兴趣的角度，形成你想要研究的问题。\n4. 那些能够解决你问题的理论就是你要在文献中注意的内容。\n\n# 不用写太多\n\n笔记应该是自己思考的结果，而不是把别人的观点抄一遍。笔记应该是和你的研究内容密切相关，而且是对别人观点的总结与思考。笔记可以是下面的内容：\n\n1. 论文中很棒的表达，可以在自己论文中引用。\n2. 除了上一点，把作者观点用自己的话表达出来。记录最重要的ideas，用标签或者标题的方式记下来，然后再解释一下。\n3. 不要只画画线不写笔记（输出很重要呀）。\n\n# 给笔记做上标签\n\n选择你喜欢的方式，只要能让你的笔记之后还能拿出来用。\n\n1. 有意识地整理笔记，标注上作者，出处等。\n2. 一张纸上写一份笔记。记笔记的时候可以专注于这个topic，分类起来也好分。\n3. 留些空档给第二次记录\n\n# 碎碎念\n\n按例来个碎碎念。我觉得就我而言，老师给我定好了接下去做的方向。我还是要梳理一下我在做的方向，**列出涉及到的方法、idea、概念之类**的。然后读文献，做笔记。做笔记的时候要注意把idea用自己的话总结出来（我就是那个最喜欢用不同颜色高亮文献的人）\n\n","source":"_posts/如何做文献阅读笔记.md","raw":"---\ntitle: 如何做文献阅读笔记\ndate: 2021-04-11 22:51:57\ntags: 转载\ncategories: 科研Research\n---\n\nGoogle时发现的一篇文章，来自多伦多大学。翻译过来学习一下~\n\n![cover_pic](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/cover_picture/5.png)\n\n<!--more-->\n\n原文地址：\n\n[Taking Notes from Research Reading | Writing Advice](https://advice.writing.utoronto.ca/researching/notes-from-research/)\n\n文章把记笔记分成了三个要点：\n\n> 1. 有目标地读文献\n> 2. 不用写太多\n> 3. 给笔记做上标签\n\n# 有目标地读文献\n\n要有目的地去读文献，清楚自己需要记录什么样的idea，这样一来可以把相关的idea分出来。具体来说一下四点：\n\n1. 对那你的领域（topic）有一个大致了解，如这个领域包括的思想和观点。\n2. 把你需要了解的子领域列出来。\n3. 选择你感兴趣的角度，形成你想要研究的问题。\n4. 那些能够解决你问题的理论就是你要在文献中注意的内容。\n\n# 不用写太多\n\n笔记应该是自己思考的结果，而不是把别人的观点抄一遍。笔记应该是和你的研究内容密切相关，而且是对别人观点的总结与思考。笔记可以是下面的内容：\n\n1. 论文中很棒的表达，可以在自己论文中引用。\n2. 除了上一点，把作者观点用自己的话表达出来。记录最重要的ideas，用标签或者标题的方式记下来，然后再解释一下。\n3. 不要只画画线不写笔记（输出很重要呀）。\n\n# 给笔记做上标签\n\n选择你喜欢的方式，只要能让你的笔记之后还能拿出来用。\n\n1. 有意识地整理笔记，标注上作者，出处等。\n2. 一张纸上写一份笔记。记笔记的时候可以专注于这个topic，分类起来也好分。\n3. 留些空档给第二次记录\n\n# 碎碎念\n\n按例来个碎碎念。我觉得就我而言，老师给我定好了接下去做的方向。我还是要梳理一下我在做的方向，**列出涉及到的方法、idea、概念之类**的。然后读文献，做笔记。做笔记的时候要注意把idea用自己的话总结出来（我就是那个最喜欢用不同颜色高亮文献的人）\n\n","slug":"如何做文献阅读笔记","published":1,"updated":"2021-04-11T14:51:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeagh6002h38t4enc57zy7","content":"<p>Google时发现的一篇文章，来自多伦多大学。翻译过来学习一下~</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/cover_picture/5.png\" alt=\"cover_pic\"></p>\n<span id=\"more\"></span>\n\n<p>原文地址：</p>\n<p><a href=\"https://advice.writing.utoronto.ca/researching/notes-from-research/\">Taking Notes from Research Reading | Writing Advice</a></p>\n<p>文章把记笔记分成了三个要点：</p>\n<blockquote>\n<ol>\n<li>有目标地读文献</li>\n<li>不用写太多</li>\n<li>给笔记做上标签</li>\n</ol>\n</blockquote>\n<h1 id=\"有目标地读文献\"><a href=\"#有目标地读文献\" class=\"headerlink\" title=\"有目标地读文献\"></a>有目标地读文献</h1><p>要有目的地去读文献，清楚自己需要记录什么样的idea，这样一来可以把相关的idea分出来。具体来说一下四点：</p>\n<ol>\n<li>对那你的领域（topic）有一个大致了解，如这个领域包括的思想和观点。</li>\n<li>把你需要了解的子领域列出来。</li>\n<li>选择你感兴趣的角度，形成你想要研究的问题。</li>\n<li>那些能够解决你问题的理论就是你要在文献中注意的内容。</li>\n</ol>\n<h1 id=\"不用写太多\"><a href=\"#不用写太多\" class=\"headerlink\" title=\"不用写太多\"></a>不用写太多</h1><p>笔记应该是自己思考的结果，而不是把别人的观点抄一遍。笔记应该是和你的研究内容密切相关，而且是对别人观点的总结与思考。笔记可以是下面的内容：</p>\n<ol>\n<li>论文中很棒的表达，可以在自己论文中引用。</li>\n<li>除了上一点，把作者观点用自己的话表达出来。记录最重要的ideas，用标签或者标题的方式记下来，然后再解释一下。</li>\n<li>不要只画画线不写笔记（输出很重要呀）。</li>\n</ol>\n<h1 id=\"给笔记做上标签\"><a href=\"#给笔记做上标签\" class=\"headerlink\" title=\"给笔记做上标签\"></a>给笔记做上标签</h1><p>选择你喜欢的方式，只要能让你的笔记之后还能拿出来用。</p>\n<ol>\n<li>有意识地整理笔记，标注上作者，出处等。</li>\n<li>一张纸上写一份笔记。记笔记的时候可以专注于这个topic，分类起来也好分。</li>\n<li>留些空档给第二次记录</li>\n</ol>\n<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>按例来个碎碎念。我觉得就我而言，老师给我定好了接下去做的方向。我还是要梳理一下我在做的方向，<strong>列出涉及到的方法、idea、概念之类</strong>的。然后读文献，做笔记。做笔记的时候要注意把idea用自己的话总结出来（我就是那个最喜欢用不同颜色高亮文献的人）</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>Google时发现的一篇文章，来自多伦多大学。翻译过来学习一下~</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/cover_picture/5.png\" alt=\"cover_pic\"></p>","more":"<p>原文地址：</p>\n<p><a href=\"https://advice.writing.utoronto.ca/researching/notes-from-research/\">Taking Notes from Research Reading | Writing Advice</a></p>\n<p>文章把记笔记分成了三个要点：</p>\n<blockquote>\n<ol>\n<li>有目标地读文献</li>\n<li>不用写太多</li>\n<li>给笔记做上标签</li>\n</ol>\n</blockquote>\n<h1 id=\"有目标地读文献\"><a href=\"#有目标地读文献\" class=\"headerlink\" title=\"有目标地读文献\"></a>有目标地读文献</h1><p>要有目的地去读文献，清楚自己需要记录什么样的idea，这样一来可以把相关的idea分出来。具体来说一下四点：</p>\n<ol>\n<li>对那你的领域（topic）有一个大致了解，如这个领域包括的思想和观点。</li>\n<li>把你需要了解的子领域列出来。</li>\n<li>选择你感兴趣的角度，形成你想要研究的问题。</li>\n<li>那些能够解决你问题的理论就是你要在文献中注意的内容。</li>\n</ol>\n<h1 id=\"不用写太多\"><a href=\"#不用写太多\" class=\"headerlink\" title=\"不用写太多\"></a>不用写太多</h1><p>笔记应该是自己思考的结果，而不是把别人的观点抄一遍。笔记应该是和你的研究内容密切相关，而且是对别人观点的总结与思考。笔记可以是下面的内容：</p>\n<ol>\n<li>论文中很棒的表达，可以在自己论文中引用。</li>\n<li>除了上一点，把作者观点用自己的话表达出来。记录最重要的ideas，用标签或者标题的方式记下来，然后再解释一下。</li>\n<li>不要只画画线不写笔记（输出很重要呀）。</li>\n</ol>\n<h1 id=\"给笔记做上标签\"><a href=\"#给笔记做上标签\" class=\"headerlink\" title=\"给笔记做上标签\"></a>给笔记做上标签</h1><p>选择你喜欢的方式，只要能让你的笔记之后还能拿出来用。</p>\n<ol>\n<li>有意识地整理笔记，标注上作者，出处等。</li>\n<li>一张纸上写一份笔记。记笔记的时候可以专注于这个topic，分类起来也好分。</li>\n<li>留些空档给第二次记录</li>\n</ol>\n<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>按例来个碎碎念。我觉得就我而言，老师给我定好了接下去做的方向。我还是要梳理一下我在做的方向，<strong>列出涉及到的方法、idea、概念之类</strong>的。然后读文献，做笔记。做笔记的时候要注意把idea用自己的话总结出来（我就是那个最喜欢用不同颜色高亮文献的人）</p>"},{"title":"小李的新年flag|新年|新学期|21岁|目标|随感","date":"2019-02-25T03:27:37.000Z","_content":"元旦也已经过去两个月了。小李再一次立下了flag。\n\n<!--more-->\n\n\n---\n\n\n## 新年\n之前看过一条微博，大意是人们喜欢新年，是因为有这样一个机会可以重新开始。是啊，重新开始！\n对我来说，写出具体的事情比一个目标要有效果得多。\n以及，不要赋予一件事太多的意义会比较好。\n### Goals\n1. 多看书\n这个排在第一。我觉得看书少限制了我的思想...\n2. 早睡早起、锻炼身体\n我的理想睡眠时间是23:30-6:30，好难呢但是至少保持在十二点前睡觉吧。\n身体健康比什么都重要。“只有健康的身体才能装下有趣的灵魂。”\n3. 学习（英语、日语、算法）\n英语打算再刷一遍六级，另外以看英文资料和与英语母语者交流为目标\n日语，想多学一门语言，以N3为目标激励自己学习吧\n算法。\n4. 论文\n本学期目标。\n5. ~~考研~~ 保研\n还是想多读点书啊。\n6. 博客\n多输出。\n7. 手账\n拼贴也好，手绘也好，Bullet Journal也好，坚持下去。\n8. 拍摄（合肥）\n想在毕业前拍一个合肥的小视频。毕竟是第一次离家，待了四年的地方。\n\n### To Do List\n#### 书单\n- [x] 《孤独六讲》\n- [ ] 《数学之美》\n- [ ] 《飘》\n- [ ] 《明朝那些事儿》\n- [ ] 《时间简史》\n- [ ] 《月亮与六便士》\n- [x] 《成为香奈儿》\n#### 影单\n- [x] 《流浪地球》（特效好；刘启好帅；很想见一见那么大的木星；活着真好）\n- [x] 《飞驰人生》（阿信唱歌最精彩；汽车零件特效好）\n- [x] 《这个杀手不太冷》\n- [x] 《星际穿越》\n\n#### 剧单\n- [x] 《我是大哥大》（沙雕剧；但是会很燃；全员超帅）\n- [x] 《刺客伍六七》（请收下这枚安利！一定要！）（“我今天就要带她走，我看谁敢拦我。”我爱上了阿七！！）\n- [x] 《3年A班》\n- [x] 《请回答1988》\n\n#### 其他\n~~ - [ ] 你好好备考就行。~~\n\n## 后记\n### 随感\n> 写一点想法在这里。\n\n1.一个人很难做到自己能力以外的事。\n2.人们的包容程度大于我的想象。\n3.没有捷径，只有积累。\n4.性格没有优劣，不管内向外向理性感性。\n5.过得开心就好。\n\n### 写在最后\n最后再祝一遍自己生日快乐~\n祝所有人新年快乐！","source":"_posts/小李的新年flag-新年-新学期-21岁-目标-随感.md","raw":"---\ntitle: 小李的新年flag|新年|新学期|21岁|目标|随感\ndate: 2019-02-25 11:27:37\ncategories: 生活Life\n---\n元旦也已经过去两个月了。小李再一次立下了flag。\n\n<!--more-->\n\n\n---\n\n\n## 新年\n之前看过一条微博，大意是人们喜欢新年，是因为有这样一个机会可以重新开始。是啊，重新开始！\n对我来说，写出具体的事情比一个目标要有效果得多。\n以及，不要赋予一件事太多的意义会比较好。\n### Goals\n1. 多看书\n这个排在第一。我觉得看书少限制了我的思想...\n2. 早睡早起、锻炼身体\n我的理想睡眠时间是23:30-6:30，好难呢但是至少保持在十二点前睡觉吧。\n身体健康比什么都重要。“只有健康的身体才能装下有趣的灵魂。”\n3. 学习（英语、日语、算法）\n英语打算再刷一遍六级，另外以看英文资料和与英语母语者交流为目标\n日语，想多学一门语言，以N3为目标激励自己学习吧\n算法。\n4. 论文\n本学期目标。\n5. ~~考研~~ 保研\n还是想多读点书啊。\n6. 博客\n多输出。\n7. 手账\n拼贴也好，手绘也好，Bullet Journal也好，坚持下去。\n8. 拍摄（合肥）\n想在毕业前拍一个合肥的小视频。毕竟是第一次离家，待了四年的地方。\n\n### To Do List\n#### 书单\n- [x] 《孤独六讲》\n- [ ] 《数学之美》\n- [ ] 《飘》\n- [ ] 《明朝那些事儿》\n- [ ] 《时间简史》\n- [ ] 《月亮与六便士》\n- [x] 《成为香奈儿》\n#### 影单\n- [x] 《流浪地球》（特效好；刘启好帅；很想见一见那么大的木星；活着真好）\n- [x] 《飞驰人生》（阿信唱歌最精彩；汽车零件特效好）\n- [x] 《这个杀手不太冷》\n- [x] 《星际穿越》\n\n#### 剧单\n- [x] 《我是大哥大》（沙雕剧；但是会很燃；全员超帅）\n- [x] 《刺客伍六七》（请收下这枚安利！一定要！）（“我今天就要带她走，我看谁敢拦我。”我爱上了阿七！！）\n- [x] 《3年A班》\n- [x] 《请回答1988》\n\n#### 其他\n~~ - [ ] 你好好备考就行。~~\n\n## 后记\n### 随感\n> 写一点想法在这里。\n\n1.一个人很难做到自己能力以外的事。\n2.人们的包容程度大于我的想象。\n3.没有捷径，只有积累。\n4.性格没有优劣，不管内向外向理性感性。\n5.过得开心就好。\n\n### 写在最后\n最后再祝一遍自己生日快乐~\n祝所有人新年快乐！","slug":"小李的新年flag-新年-新学期-21岁-目标-随感","published":1,"updated":"2019-02-25T03:27:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeagh7002l38t4947r8tny","content":"<p>元旦也已经过去两个月了。小李再一次立下了flag。</p>\n<span id=\"more\"></span>\n\n\n<hr>\n<h2 id=\"新年\"><a href=\"#新年\" class=\"headerlink\" title=\"新年\"></a>新年</h2><p>之前看过一条微博，大意是人们喜欢新年，是因为有这样一个机会可以重新开始。是啊，重新开始！<br>对我来说，写出具体的事情比一个目标要有效果得多。<br>以及，不要赋予一件事太多的意义会比较好。</p>\n<h3 id=\"Goals\"><a href=\"#Goals\" class=\"headerlink\" title=\"Goals\"></a>Goals</h3><ol>\n<li>多看书<br>这个排在第一。我觉得看书少限制了我的思想…</li>\n<li>早睡早起、锻炼身体<br>我的理想睡眠时间是23:30-6:30，好难呢但是至少保持在十二点前睡觉吧。<br>身体健康比什么都重要。“只有健康的身体才能装下有趣的灵魂。”</li>\n<li>学习（英语、日语、算法）<br>英语打算再刷一遍六级，另外以看英文资料和与英语母语者交流为目标<br>日语，想多学一门语言，以N3为目标激励自己学习吧<br>算法。</li>\n<li>论文<br>本学期目标。</li>\n<li><del>考研</del> 保研<br>还是想多读点书啊。</li>\n<li>博客<br>多输出。</li>\n<li>手账<br>拼贴也好，手绘也好，Bullet Journal也好，坚持下去。</li>\n<li>拍摄（合肥）<br>想在毕业前拍一个合肥的小视频。毕竟是第一次离家，待了四年的地方。</li>\n</ol>\n<h3 id=\"To-Do-List\"><a href=\"#To-Do-List\" class=\"headerlink\" title=\"To Do List\"></a>To Do List</h3><h4 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h4><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《孤独六讲》</li>\n<li><input disabled=\"\" type=\"checkbox\"> 《数学之美》</li>\n<li><input disabled=\"\" type=\"checkbox\"> 《飘》</li>\n<li><input disabled=\"\" type=\"checkbox\"> 《明朝那些事儿》</li>\n<li><input disabled=\"\" type=\"checkbox\"> 《时间简史》</li>\n<li><input disabled=\"\" type=\"checkbox\"> 《月亮与六便士》</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《成为香奈儿》<h4 id=\"影单\"><a href=\"#影单\" class=\"headerlink\" title=\"影单\"></a>影单</h4></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《流浪地球》（特效好；刘启好帅；很想见一见那么大的木星；活着真好）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《飞驰人生》（阿信唱歌最精彩；汽车零件特效好）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《这个杀手不太冷》</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《星际穿越》</li>\n</ul>\n<h4 id=\"剧单\"><a href=\"#剧单\" class=\"headerlink\" title=\"剧单\"></a>剧单</h4><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《我是大哥大》（沙雕剧；但是会很燃；全员超帅）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《刺客伍六七》（请收下这枚安利！一定要！）（“我今天就要带她走，我看谁敢拦我。”我爱上了阿七！！）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《3年A班》</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《请回答1988》</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><p>~~ - [ ] 你好好备考就行。~~</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><h3 id=\"随感\"><a href=\"#随感\" class=\"headerlink\" title=\"随感\"></a>随感</h3><blockquote>\n<p>写一点想法在这里。</p>\n</blockquote>\n<p>1.一个人很难做到自己能力以外的事。<br>2.人们的包容程度大于我的想象。<br>3.没有捷径，只有积累。<br>4.性格没有优劣，不管内向外向理性感性。<br>5.过得开心就好。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>最后再祝一遍自己生日快乐~<br>祝所有人新年快乐！</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>元旦也已经过去两个月了。小李再一次立下了flag。</p>","more":"<hr>\n<h2 id=\"新年\"><a href=\"#新年\" class=\"headerlink\" title=\"新年\"></a>新年</h2><p>之前看过一条微博，大意是人们喜欢新年，是因为有这样一个机会可以重新开始。是啊，重新开始！<br>对我来说，写出具体的事情比一个目标要有效果得多。<br>以及，不要赋予一件事太多的意义会比较好。</p>\n<h3 id=\"Goals\"><a href=\"#Goals\" class=\"headerlink\" title=\"Goals\"></a>Goals</h3><ol>\n<li>多看书<br>这个排在第一。我觉得看书少限制了我的思想…</li>\n<li>早睡早起、锻炼身体<br>我的理想睡眠时间是23:30-6:30，好难呢但是至少保持在十二点前睡觉吧。<br>身体健康比什么都重要。“只有健康的身体才能装下有趣的灵魂。”</li>\n<li>学习（英语、日语、算法）<br>英语打算再刷一遍六级，另外以看英文资料和与英语母语者交流为目标<br>日语，想多学一门语言，以N3为目标激励自己学习吧<br>算法。</li>\n<li>论文<br>本学期目标。</li>\n<li><del>考研</del> 保研<br>还是想多读点书啊。</li>\n<li>博客<br>多输出。</li>\n<li>手账<br>拼贴也好，手绘也好，Bullet Journal也好，坚持下去。</li>\n<li>拍摄（合肥）<br>想在毕业前拍一个合肥的小视频。毕竟是第一次离家，待了四年的地方。</li>\n</ol>\n<h3 id=\"To-Do-List\"><a href=\"#To-Do-List\" class=\"headerlink\" title=\"To Do List\"></a>To Do List</h3><h4 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h4><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《孤独六讲》</li>\n<li><input disabled=\"\" type=\"checkbox\"> 《数学之美》</li>\n<li><input disabled=\"\" type=\"checkbox\"> 《飘》</li>\n<li><input disabled=\"\" type=\"checkbox\"> 《明朝那些事儿》</li>\n<li><input disabled=\"\" type=\"checkbox\"> 《时间简史》</li>\n<li><input disabled=\"\" type=\"checkbox\"> 《月亮与六便士》</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《成为香奈儿》<h4 id=\"影单\"><a href=\"#影单\" class=\"headerlink\" title=\"影单\"></a>影单</h4></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《流浪地球》（特效好；刘启好帅；很想见一见那么大的木星；活着真好）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《飞驰人生》（阿信唱歌最精彩；汽车零件特效好）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《这个杀手不太冷》</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《星际穿越》</li>\n</ul>\n<h4 id=\"剧单\"><a href=\"#剧单\" class=\"headerlink\" title=\"剧单\"></a>剧单</h4><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《我是大哥大》（沙雕剧；但是会很燃；全员超帅）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《刺客伍六七》（请收下这枚安利！一定要！）（“我今天就要带她走，我看谁敢拦我。”我爱上了阿七！！）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《3年A班》</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 《请回答1988》</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><p>~~ - [ ] 你好好备考就行。~~</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><h3 id=\"随感\"><a href=\"#随感\" class=\"headerlink\" title=\"随感\"></a>随感</h3><blockquote>\n<p>写一点想法在这里。</p>\n</blockquote>\n<p>1.一个人很难做到自己能力以外的事。<br>2.人们的包容程度大于我的想象。<br>3.没有捷径，只有积累。<br>4.性格没有优劣，不管内向外向理性感性。<br>5.过得开心就好。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>最后再祝一遍自己生日快乐~<br>祝所有人新年快乐！</p>"},{"title":"小样本数据扩增总结","date":"2021-03-28T08:48:15.000Z","_content":"\n寒假的时候针对小样本扩增这一块内容收集了很多文献，也看了很多文献。第一次有点科研的感觉，在这里做个总结。\n![title_pic](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/1.png)\n\n<!--more-->\n\n随着机器学习（特别是深度学习）的发展，它的问题也逐渐凸显出来。深度学习一般需要大量的数据集，才能训练到效果较好的模型。近年来，对小样本的研究越来越多。一方面，不是所有领域都有**充足的样本**用来训练模型，比如医学领域。另一方面，基于大量数据得到的深度学习模型训练也需要**较高的代价**，如设备资源、训练时长等等，若能从少量样本中学习概念知识，能在一定程度减小代价。\n\n按照综述《**Generalizing from a Few Examples: A Survey on Few-Shot Learning**》。先给出**小样本学习（Few-Shot Learning, FSL）**的定义：\n\n> 属于机器学习的一类任务，区别在于FSL用于目标任务的信息较少（训练集数量少）。\n\n综述里对小样本学习从不同角度分成了三个类型：**1. 模型 2. 数据 3. 算法**。我这篇博客想要讨论的**数据扩增**，就属于从**数据**角度来解决小样本学习问题。\n\n而从数据角度而言，又可以分成三种类型：1. 从**训练集**中转换样本；2. 从**弱标签或无标签数据集**中转换样本；3. 从**相似数据集**中转换样本。这张图比较容易理解：\n\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323095705808.png\" alt=\"数据扩增以解决小样本问题\" style=\"zoom:80%;\" />\n\n另外我认为，**数据增强（Data Augmentation）**也可以分成这样两种方法:1. 从**基本图像处理**进行增强，如裁剪、旋转、变化颜色等；2. 从**特征**进行扩增，如使用GAN合成样本、映射到特征空间内增强（SMOTE）、神经风格迁移\n\n> 借鉴了[这篇文章](https://www.jiqizhixin.com/articles/2019-12-04-10)，也是分成了类似的两类，第一类是基于基本图像处理技术，第二类是**基于深度学习**。我觉得也写得很好，但是我感觉第二类这样叫不太准确，SMOTE方法应该是不算深度学习的。\n\n《A survey on Image Data Augmentation for Deep Learning》是关于**图像的数据增强**综述。这篇文章更详细地阐述了相关方法的分类：\n\n> The augmentations listed in this survey are **geometric transformations, color space transformations, kernel filters, mixing images, random erasing, feature space augmentation, adversarial training, GAN-based augmentation, neural style transfer, and meta-learning schemes**.\n\n接下来列出几篇做样本扩增的文献，主要是从训练集本身来合成新样本。下面四篇是综述中引用的文献：\n\n# Delta-encoder: an effective sample synthesis method for few-shot object recognition（IBM Research AI, NIPS 2018）\n\n基于**自动编码器**，学习能够用于合成**新类别**样本的模型。模型图：\n\n![delta-encoder架构](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323110113774.png)\n\n**(a)训练阶段**: $X^s$ 和$Y^s$是来自同一个可见类的随机一对样本; Δ-encoder学习重建得到$\\hat{X}^s$。 **(b)样本合成阶段** :$X^s$和$Y^s$是随机已知类中随机的一对样本，$Y^u$是新的未知类中的单个样本；Δ-encoder从新类中生成一个新的示例$\\hat{X}^u$。\n\n本文希望学习到不同样本之间的**可迁移的差异性**，然后用到新样本上去。实验也是通过N-way K-shot的方法进行。\n\n训练阶段需要10个epoch达到收敛，每个epoch在Nvidia Tesla K40m GPU上跑20s。（我感觉挺快的？）\n\n# Low-shot visual recognition by shrinking and hallucinating features（Facebook AI Research, CVPR 2017）\n\n和上一篇一样，期望学习到样本间**可迁移的差异性**。即学习到的样本变换信息，可以用到别的类别上去（但是这两种类别也比较相似，如不同种类的鸟。本文通过对每个类别做聚类，判断质心距离的方法评估相似性）。\n\n此外，本文希望学习到一个**生成器**（文中提到是多层感知器），学习到样本间可迁移的差异性用到新类别上去。关于差异性迁移，可以通过下图来理解：\n\n![image-20210323112338424](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323112338424.png)\n\n以第一行为例，左边两张图都是小灰鸟，右边两张图都是小蓝鸟，分别属于两个类别。左边小灰鸟一个是以天空为背景，一个是以树叶为背景，模型将学习到这个差异性。这个差异性能够迁移到小蓝鸟上，当我们有以天空为背景的小蓝鸟照片时，通过差异性的迁移，就能得到以树叶为背景的小蓝鸟照片。\n\nPS：我还挺喜欢这个迁移差异性的思想，感觉挺有意思的。不过我感觉“模型可以学习到差异性”这个说法，有点抽象。\n\n# One-Shot Learning of Scene Locations via Feature Trajectory Transfer(CVPR 2016)\n\n从一组图像上学习一个瞬态属性的特征轨迹，将轨迹转移到新的图像上生成某个属性（如晴天、阴天）在不同强度下对应的图像。图像举例：\n\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323144845585.png\" alt=\"数据集举例\" style=\"zoom:80%;\" />\n\n上图中，每一行表示一个照相机采集到的照片。对应的属性为sunny，在不同属性强度下的照片。\n\n本文希望从细粒度数据集中学习知识，然后基于新数据合成样本。文中提到，特征轨迹转移的方法基于两个假设：1. 通过图像的**特征表示**能够**预测其瞬态属性**；2. 这种瞬态属性与特征表示之间的**函数关系**能够建模为**特征空间中的轨迹**。\n\n![特征轨迹转移和合成图解](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323145600859.png)\n\n对于新图像，先用计算它**在属性空间中的表示**，得到一个对应的属性向量。迭代所有场景，**对每个属性**都学习到新样本的**特征轨迹转移**。最后，分别沿每个属性对应的转移轨迹预测对应的特征。最终对来自所有场景的预测值进行加权，得到合成图像。\n\n这篇我有点一知半解。看文章的公式，好像就用了一个线性模型来合成新样本。\n\n# Feature Space Transfer for Data Augmentation(CVPR 2018)\n\n同样是**特征轨迹**，这里的是**姿态**变化轨迹。用到**解纠缠**的思想，用两个编码器，将图像的**外观**和**姿态**两种属性分开来了。\n\n![特征空间转换示意图](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323150601178.png)\n\n上图所示，不同的图像特征向量，可以映射到外观空间中的同一点，映射到姿态空间中的不同点。\n\n本文的模型结构是下图：\n\n![FATTEN架构](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323150827500.png)\n\n\n\n# 碎碎念\n\n刚开始写这篇的时候，被老师叫去谈话了。这个突然就变成了我的课题- -\n\n加油吧！这个礼拜先写这么多，之后慢慢补充吧。","source":"_posts/小样本数据扩增总结.md","raw":"---\ntitle: 小样本数据扩增总结\ndate: 2021-03-28 16:48:15\ntags: \n- 小样本\n- 数据扩增\ncategories: ResearchLife\n---\n\n寒假的时候针对小样本扩增这一块内容收集了很多文献，也看了很多文献。第一次有点科研的感觉，在这里做个总结。\n![title_pic](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/1.png)\n\n<!--more-->\n\n随着机器学习（特别是深度学习）的发展，它的问题也逐渐凸显出来。深度学习一般需要大量的数据集，才能训练到效果较好的模型。近年来，对小样本的研究越来越多。一方面，不是所有领域都有**充足的样本**用来训练模型，比如医学领域。另一方面，基于大量数据得到的深度学习模型训练也需要**较高的代价**，如设备资源、训练时长等等，若能从少量样本中学习概念知识，能在一定程度减小代价。\n\n按照综述《**Generalizing from a Few Examples: A Survey on Few-Shot Learning**》。先给出**小样本学习（Few-Shot Learning, FSL）**的定义：\n\n> 属于机器学习的一类任务，区别在于FSL用于目标任务的信息较少（训练集数量少）。\n\n综述里对小样本学习从不同角度分成了三个类型：**1. 模型 2. 数据 3. 算法**。我这篇博客想要讨论的**数据扩增**，就属于从**数据**角度来解决小样本学习问题。\n\n而从数据角度而言，又可以分成三种类型：1. 从**训练集**中转换样本；2. 从**弱标签或无标签数据集**中转换样本；3. 从**相似数据集**中转换样本。这张图比较容易理解：\n\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323095705808.png\" alt=\"数据扩增以解决小样本问题\" style=\"zoom:80%;\" />\n\n另外我认为，**数据增强（Data Augmentation）**也可以分成这样两种方法:1. 从**基本图像处理**进行增强，如裁剪、旋转、变化颜色等；2. 从**特征**进行扩增，如使用GAN合成样本、映射到特征空间内增强（SMOTE）、神经风格迁移\n\n> 借鉴了[这篇文章](https://www.jiqizhixin.com/articles/2019-12-04-10)，也是分成了类似的两类，第一类是基于基本图像处理技术，第二类是**基于深度学习**。我觉得也写得很好，但是我感觉第二类这样叫不太准确，SMOTE方法应该是不算深度学习的。\n\n《A survey on Image Data Augmentation for Deep Learning》是关于**图像的数据增强**综述。这篇文章更详细地阐述了相关方法的分类：\n\n> The augmentations listed in this survey are **geometric transformations, color space transformations, kernel filters, mixing images, random erasing, feature space augmentation, adversarial training, GAN-based augmentation, neural style transfer, and meta-learning schemes**.\n\n接下来列出几篇做样本扩增的文献，主要是从训练集本身来合成新样本。下面四篇是综述中引用的文献：\n\n# Delta-encoder: an effective sample synthesis method for few-shot object recognition（IBM Research AI, NIPS 2018）\n\n基于**自动编码器**，学习能够用于合成**新类别**样本的模型。模型图：\n\n![delta-encoder架构](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323110113774.png)\n\n**(a)训练阶段**: $X^s$ 和$Y^s$是来自同一个可见类的随机一对样本; Δ-encoder学习重建得到$\\hat{X}^s$。 **(b)样本合成阶段** :$X^s$和$Y^s$是随机已知类中随机的一对样本，$Y^u$是新的未知类中的单个样本；Δ-encoder从新类中生成一个新的示例$\\hat{X}^u$。\n\n本文希望学习到不同样本之间的**可迁移的差异性**，然后用到新样本上去。实验也是通过N-way K-shot的方法进行。\n\n训练阶段需要10个epoch达到收敛，每个epoch在Nvidia Tesla K40m GPU上跑20s。（我感觉挺快的？）\n\n# Low-shot visual recognition by shrinking and hallucinating features（Facebook AI Research, CVPR 2017）\n\n和上一篇一样，期望学习到样本间**可迁移的差异性**。即学习到的样本变换信息，可以用到别的类别上去（但是这两种类别也比较相似，如不同种类的鸟。本文通过对每个类别做聚类，判断质心距离的方法评估相似性）。\n\n此外，本文希望学习到一个**生成器**（文中提到是多层感知器），学习到样本间可迁移的差异性用到新类别上去。关于差异性迁移，可以通过下图来理解：\n\n![image-20210323112338424](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323112338424.png)\n\n以第一行为例，左边两张图都是小灰鸟，右边两张图都是小蓝鸟，分别属于两个类别。左边小灰鸟一个是以天空为背景，一个是以树叶为背景，模型将学习到这个差异性。这个差异性能够迁移到小蓝鸟上，当我们有以天空为背景的小蓝鸟照片时，通过差异性的迁移，就能得到以树叶为背景的小蓝鸟照片。\n\nPS：我还挺喜欢这个迁移差异性的思想，感觉挺有意思的。不过我感觉“模型可以学习到差异性”这个说法，有点抽象。\n\n# One-Shot Learning of Scene Locations via Feature Trajectory Transfer(CVPR 2016)\n\n从一组图像上学习一个瞬态属性的特征轨迹，将轨迹转移到新的图像上生成某个属性（如晴天、阴天）在不同强度下对应的图像。图像举例：\n\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323144845585.png\" alt=\"数据集举例\" style=\"zoom:80%;\" />\n\n上图中，每一行表示一个照相机采集到的照片。对应的属性为sunny，在不同属性强度下的照片。\n\n本文希望从细粒度数据集中学习知识，然后基于新数据合成样本。文中提到，特征轨迹转移的方法基于两个假设：1. 通过图像的**特征表示**能够**预测其瞬态属性**；2. 这种瞬态属性与特征表示之间的**函数关系**能够建模为**特征空间中的轨迹**。\n\n![特征轨迹转移和合成图解](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323145600859.png)\n\n对于新图像，先用计算它**在属性空间中的表示**，得到一个对应的属性向量。迭代所有场景，**对每个属性**都学习到新样本的**特征轨迹转移**。最后，分别沿每个属性对应的转移轨迹预测对应的特征。最终对来自所有场景的预测值进行加权，得到合成图像。\n\n这篇我有点一知半解。看文章的公式，好像就用了一个线性模型来合成新样本。\n\n# Feature Space Transfer for Data Augmentation(CVPR 2018)\n\n同样是**特征轨迹**，这里的是**姿态**变化轨迹。用到**解纠缠**的思想，用两个编码器，将图像的**外观**和**姿态**两种属性分开来了。\n\n![特征空间转换示意图](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323150601178.png)\n\n上图所示，不同的图像特征向量，可以映射到外观空间中的同一点，映射到姿态空间中的不同点。\n\n本文的模型结构是下图：\n\n![FATTEN架构](https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323150827500.png)\n\n\n\n# 碎碎念\n\n刚开始写这篇的时候，被老师叫去谈话了。这个突然就变成了我的课题- -\n\n加油吧！这个礼拜先写这么多，之后慢慢补充吧。","slug":"小样本数据扩增总结","published":1,"updated":"2021-03-28T08:48:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeagh8002n38t46bsic2zm","content":"<p>寒假的时候针对小样本扩增这一块内容收集了很多文献，也看了很多文献。第一次有点科研的感觉，在这里做个总结。<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/1.png\" alt=\"title_pic\"></p>\n<span id=\"more\"></span>\n\n<p>随着机器学习（特别是深度学习）的发展，它的问题也逐渐凸显出来。深度学习一般需要大量的数据集，才能训练到效果较好的模型。近年来，对小样本的研究越来越多。一方面，不是所有领域都有<strong>充足的样本</strong>用来训练模型，比如医学领域。另一方面，基于大量数据得到的深度学习模型训练也需要<strong>较高的代价</strong>，如设备资源、训练时长等等，若能从少量样本中学习概念知识，能在一定程度减小代价。</p>\n<p>按照综述《<strong>Generalizing from a Few Examples: A Survey on Few-Shot Learning</strong>》。先给出<strong>小样本学习（Few-Shot Learning, FSL）</strong>的定义：</p>\n<blockquote>\n<p>属于机器学习的一类任务，区别在于FSL用于目标任务的信息较少（训练集数量少）。</p>\n</blockquote>\n<p>综述里对小样本学习从不同角度分成了三个类型：<strong>1. 模型 2. 数据 3. 算法</strong>。我这篇博客想要讨论的<strong>数据扩增</strong>，就属于从<strong>数据</strong>角度来解决小样本学习问题。</p>\n<p>而从数据角度而言，又可以分成三种类型：1. 从<strong>训练集</strong>中转换样本；2. 从<strong>弱标签或无标签数据集</strong>中转换样本；3. 从<strong>相似数据集</strong>中转换样本。这张图比较容易理解：</p>\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323095705808.png\" alt=\"数据扩增以解决小样本问题\" style=\"zoom:80%;\" />\n\n<p>另外我认为，<strong>数据增强（Data Augmentation）</strong>也可以分成这样两种方法:1. 从<strong>基本图像处理</strong>进行增强，如裁剪、旋转、变化颜色等；2. 从<strong>特征</strong>进行扩增，如使用GAN合成样本、映射到特征空间内增强（SMOTE）、神经风格迁移</p>\n<blockquote>\n<p>借鉴了<a href=\"https://www.jiqizhixin.com/articles/2019-12-04-10\">这篇文章</a>，也是分成了类似的两类，第一类是基于基本图像处理技术，第二类是<strong>基于深度学习</strong>。我觉得也写得很好，但是我感觉第二类这样叫不太准确，SMOTE方法应该是不算深度学习的。</p>\n</blockquote>\n<p>《A survey on Image Data Augmentation for Deep Learning》是关于<strong>图像的数据增强</strong>综述。这篇文章更详细地阐述了相关方法的分类：</p>\n<blockquote>\n<p>The augmentations listed in this survey are <strong>geometric transformations, color space transformations, kernel filters, mixing images, random erasing, feature space augmentation, adversarial training, GAN-based augmentation, neural style transfer, and meta-learning schemes</strong>.</p>\n</blockquote>\n<p>接下来列出几篇做样本扩增的文献，主要是从训练集本身来合成新样本。下面四篇是综述中引用的文献：</p>\n<h1 id=\"Delta-encoder-an-effective-sample-synthesis-method-for-few-shot-object-recognition（IBM-Research-AI-NIPS-2018）\"><a href=\"#Delta-encoder-an-effective-sample-synthesis-method-for-few-shot-object-recognition（IBM-Research-AI-NIPS-2018）\" class=\"headerlink\" title=\"Delta-encoder: an effective sample synthesis method for few-shot object recognition（IBM Research AI, NIPS 2018）\"></a>Delta-encoder: an effective sample synthesis method for few-shot object recognition（IBM Research AI, NIPS 2018）</h1><p>基于<strong>自动编码器</strong>，学习能够用于合成<strong>新类别</strong>样本的模型。模型图：</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323110113774.png\" alt=\"delta-encoder架构\"></p>\n<p><strong>(a)训练阶段</strong>: $X^s$ 和$Y^s$是来自同一个可见类的随机一对样本; Δ-encoder学习重建得到$\\hat{X}^s$。 <strong>(b)样本合成阶段</strong> :$X^s$和$Y^s$是随机已知类中随机的一对样本，$Y^u$是新的未知类中的单个样本；Δ-encoder从新类中生成一个新的示例$\\hat{X}^u$。</p>\n<p>本文希望学习到不同样本之间的<strong>可迁移的差异性</strong>，然后用到新样本上去。实验也是通过N-way K-shot的方法进行。</p>\n<p>训练阶段需要10个epoch达到收敛，每个epoch在Nvidia Tesla K40m GPU上跑20s。（我感觉挺快的？）</p>\n<h1 id=\"Low-shot-visual-recognition-by-shrinking-and-hallucinating-features（Facebook-AI-Research-CVPR-2017）\"><a href=\"#Low-shot-visual-recognition-by-shrinking-and-hallucinating-features（Facebook-AI-Research-CVPR-2017）\" class=\"headerlink\" title=\"Low-shot visual recognition by shrinking and hallucinating features（Facebook AI Research, CVPR 2017）\"></a>Low-shot visual recognition by shrinking and hallucinating features（Facebook AI Research, CVPR 2017）</h1><p>和上一篇一样，期望学习到样本间<strong>可迁移的差异性</strong>。即学习到的样本变换信息，可以用到别的类别上去（但是这两种类别也比较相似，如不同种类的鸟。本文通过对每个类别做聚类，判断质心距离的方法评估相似性）。</p>\n<p>此外，本文希望学习到一个<strong>生成器</strong>（文中提到是多层感知器），学习到样本间可迁移的差异性用到新类别上去。关于差异性迁移，可以通过下图来理解：</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323112338424.png\" alt=\"image-20210323112338424\"></p>\n<p>以第一行为例，左边两张图都是小灰鸟，右边两张图都是小蓝鸟，分别属于两个类别。左边小灰鸟一个是以天空为背景，一个是以树叶为背景，模型将学习到这个差异性。这个差异性能够迁移到小蓝鸟上，当我们有以天空为背景的小蓝鸟照片时，通过差异性的迁移，就能得到以树叶为背景的小蓝鸟照片。</p>\n<p>PS：我还挺喜欢这个迁移差异性的思想，感觉挺有意思的。不过我感觉“模型可以学习到差异性”这个说法，有点抽象。</p>\n<h1 id=\"One-Shot-Learning-of-Scene-Locations-via-Feature-Trajectory-Transfer-CVPR-2016\"><a href=\"#One-Shot-Learning-of-Scene-Locations-via-Feature-Trajectory-Transfer-CVPR-2016\" class=\"headerlink\" title=\"One-Shot Learning of Scene Locations via Feature Trajectory Transfer(CVPR 2016)\"></a>One-Shot Learning of Scene Locations via Feature Trajectory Transfer(CVPR 2016)</h1><p>从一组图像上学习一个瞬态属性的特征轨迹，将轨迹转移到新的图像上生成某个属性（如晴天、阴天）在不同强度下对应的图像。图像举例：</p>\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323144845585.png\" alt=\"数据集举例\" style=\"zoom:80%;\" />\n\n<p>上图中，每一行表示一个照相机采集到的照片。对应的属性为sunny，在不同属性强度下的照片。</p>\n<p>本文希望从细粒度数据集中学习知识，然后基于新数据合成样本。文中提到，特征轨迹转移的方法基于两个假设：1. 通过图像的<strong>特征表示</strong>能够<strong>预测其瞬态属性</strong>；2. 这种瞬态属性与特征表示之间的<strong>函数关系</strong>能够建模为<strong>特征空间中的轨迹</strong>。</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323145600859.png\" alt=\"特征轨迹转移和合成图解\"></p>\n<p>对于新图像，先用计算它<strong>在属性空间中的表示</strong>，得到一个对应的属性向量。迭代所有场景，<strong>对每个属性</strong>都学习到新样本的<strong>特征轨迹转移</strong>。最后，分别沿每个属性对应的转移轨迹预测对应的特征。最终对来自所有场景的预测值进行加权，得到合成图像。</p>\n<p>这篇我有点一知半解。看文章的公式，好像就用了一个线性模型来合成新样本。</p>\n<h1 id=\"Feature-Space-Transfer-for-Data-Augmentation-CVPR-2018\"><a href=\"#Feature-Space-Transfer-for-Data-Augmentation-CVPR-2018\" class=\"headerlink\" title=\"Feature Space Transfer for Data Augmentation(CVPR 2018)\"></a>Feature Space Transfer for Data Augmentation(CVPR 2018)</h1><p>同样是<strong>特征轨迹</strong>，这里的是<strong>姿态</strong>变化轨迹。用到<strong>解纠缠</strong>的思想，用两个编码器，将图像的<strong>外观</strong>和<strong>姿态</strong>两种属性分开来了。</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323150601178.png\" alt=\"特征空间转换示意图\"></p>\n<p>上图所示，不同的图像特征向量，可以映射到外观空间中的同一点，映射到姿态空间中的不同点。</p>\n<p>本文的模型结构是下图：</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323150827500.png\" alt=\"FATTEN架构\"></p>\n<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>刚开始写这篇的时候，被老师叫去谈话了。这个突然就变成了我的课题- -</p>\n<p>加油吧！这个礼拜先写这么多，之后慢慢补充吧。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>寒假的时候针对小样本扩增这一块内容收集了很多文献，也看了很多文献。第一次有点科研的感觉，在这里做个总结。<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/1.png\" alt=\"title_pic\"></p>","more":"<p>随着机器学习（特别是深度学习）的发展，它的问题也逐渐凸显出来。深度学习一般需要大量的数据集，才能训练到效果较好的模型。近年来，对小样本的研究越来越多。一方面，不是所有领域都有<strong>充足的样本</strong>用来训练模型，比如医学领域。另一方面，基于大量数据得到的深度学习模型训练也需要<strong>较高的代价</strong>，如设备资源、训练时长等等，若能从少量样本中学习概念知识，能在一定程度减小代价。</p>\n<p>按照综述《<strong>Generalizing from a Few Examples: A Survey on Few-Shot Learning</strong>》。先给出<strong>小样本学习（Few-Shot Learning, FSL）</strong>的定义：</p>\n<blockquote>\n<p>属于机器学习的一类任务，区别在于FSL用于目标任务的信息较少（训练集数量少）。</p>\n</blockquote>\n<p>综述里对小样本学习从不同角度分成了三个类型：<strong>1. 模型 2. 数据 3. 算法</strong>。我这篇博客想要讨论的<strong>数据扩增</strong>，就属于从<strong>数据</strong>角度来解决小样本学习问题。</p>\n<p>而从数据角度而言，又可以分成三种类型：1. 从<strong>训练集</strong>中转换样本；2. 从<strong>弱标签或无标签数据集</strong>中转换样本；3. 从<strong>相似数据集</strong>中转换样本。这张图比较容易理解：</p>\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323095705808.png\" alt=\"数据扩增以解决小样本问题\" style=\"zoom:80%;\" />\n\n<p>另外我认为，<strong>数据增强（Data Augmentation）</strong>也可以分成这样两种方法:1. 从<strong>基本图像处理</strong>进行增强，如裁剪、旋转、变化颜色等；2. 从<strong>特征</strong>进行扩增，如使用GAN合成样本、映射到特征空间内增强（SMOTE）、神经风格迁移</p>\n<blockquote>\n<p>借鉴了<a href=\"https://www.jiqizhixin.com/articles/2019-12-04-10\">这篇文章</a>，也是分成了类似的两类，第一类是基于基本图像处理技术，第二类是<strong>基于深度学习</strong>。我觉得也写得很好，但是我感觉第二类这样叫不太准确，SMOTE方法应该是不算深度学习的。</p>\n</blockquote>\n<p>《A survey on Image Data Augmentation for Deep Learning》是关于<strong>图像的数据增强</strong>综述。这篇文章更详细地阐述了相关方法的分类：</p>\n<blockquote>\n<p>The augmentations listed in this survey are <strong>geometric transformations, color space transformations, kernel filters, mixing images, random erasing, feature space augmentation, adversarial training, GAN-based augmentation, neural style transfer, and meta-learning schemes</strong>.</p>\n</blockquote>\n<p>接下来列出几篇做样本扩增的文献，主要是从训练集本身来合成新样本。下面四篇是综述中引用的文献：</p>\n<h1 id=\"Delta-encoder-an-effective-sample-synthesis-method-for-few-shot-object-recognition（IBM-Research-AI-NIPS-2018）\"><a href=\"#Delta-encoder-an-effective-sample-synthesis-method-for-few-shot-object-recognition（IBM-Research-AI-NIPS-2018）\" class=\"headerlink\" title=\"Delta-encoder: an effective sample synthesis method for few-shot object recognition（IBM Research AI, NIPS 2018）\"></a>Delta-encoder: an effective sample synthesis method for few-shot object recognition（IBM Research AI, NIPS 2018）</h1><p>基于<strong>自动编码器</strong>，学习能够用于合成<strong>新类别</strong>样本的模型。模型图：</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323110113774.png\" alt=\"delta-encoder架构\"></p>\n<p><strong>(a)训练阶段</strong>: $X^s$ 和$Y^s$是来自同一个可见类的随机一对样本; Δ-encoder学习重建得到$\\hat{X}^s$。 <strong>(b)样本合成阶段</strong> :$X^s$和$Y^s$是随机已知类中随机的一对样本，$Y^u$是新的未知类中的单个样本；Δ-encoder从新类中生成一个新的示例$\\hat{X}^u$。</p>\n<p>本文希望学习到不同样本之间的<strong>可迁移的差异性</strong>，然后用到新样本上去。实验也是通过N-way K-shot的方法进行。</p>\n<p>训练阶段需要10个epoch达到收敛，每个epoch在Nvidia Tesla K40m GPU上跑20s。（我感觉挺快的？）</p>\n<h1 id=\"Low-shot-visual-recognition-by-shrinking-and-hallucinating-features（Facebook-AI-Research-CVPR-2017）\"><a href=\"#Low-shot-visual-recognition-by-shrinking-and-hallucinating-features（Facebook-AI-Research-CVPR-2017）\" class=\"headerlink\" title=\"Low-shot visual recognition by shrinking and hallucinating features（Facebook AI Research, CVPR 2017）\"></a>Low-shot visual recognition by shrinking and hallucinating features（Facebook AI Research, CVPR 2017）</h1><p>和上一篇一样，期望学习到样本间<strong>可迁移的差异性</strong>。即学习到的样本变换信息，可以用到别的类别上去（但是这两种类别也比较相似，如不同种类的鸟。本文通过对每个类别做聚类，判断质心距离的方法评估相似性）。</p>\n<p>此外，本文希望学习到一个<strong>生成器</strong>（文中提到是多层感知器），学习到样本间可迁移的差异性用到新类别上去。关于差异性迁移，可以通过下图来理解：</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323112338424.png\" alt=\"image-20210323112338424\"></p>\n<p>以第一行为例，左边两张图都是小灰鸟，右边两张图都是小蓝鸟，分别属于两个类别。左边小灰鸟一个是以天空为背景，一个是以树叶为背景，模型将学习到这个差异性。这个差异性能够迁移到小蓝鸟上，当我们有以天空为背景的小蓝鸟照片时，通过差异性的迁移，就能得到以树叶为背景的小蓝鸟照片。</p>\n<p>PS：我还挺喜欢这个迁移差异性的思想，感觉挺有意思的。不过我感觉“模型可以学习到差异性”这个说法，有点抽象。</p>\n<h1 id=\"One-Shot-Learning-of-Scene-Locations-via-Feature-Trajectory-Transfer-CVPR-2016\"><a href=\"#One-Shot-Learning-of-Scene-Locations-via-Feature-Trajectory-Transfer-CVPR-2016\" class=\"headerlink\" title=\"One-Shot Learning of Scene Locations via Feature Trajectory Transfer(CVPR 2016)\"></a>One-Shot Learning of Scene Locations via Feature Trajectory Transfer(CVPR 2016)</h1><p>从一组图像上学习一个瞬态属性的特征轨迹，将轨迹转移到新的图像上生成某个属性（如晴天、阴天）在不同强度下对应的图像。图像举例：</p>\n<img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323144845585.png\" alt=\"数据集举例\" style=\"zoom:80%;\" />\n\n<p>上图中，每一行表示一个照相机采集到的照片。对应的属性为sunny，在不同属性强度下的照片。</p>\n<p>本文希望从细粒度数据集中学习知识，然后基于新数据合成样本。文中提到，特征轨迹转移的方法基于两个假设：1. 通过图像的<strong>特征表示</strong>能够<strong>预测其瞬态属性</strong>；2. 这种瞬态属性与特征表示之间的<strong>函数关系</strong>能够建模为<strong>特征空间中的轨迹</strong>。</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323145600859.png\" alt=\"特征轨迹转移和合成图解\"></p>\n<p>对于新图像，先用计算它<strong>在属性空间中的表示</strong>，得到一个对应的属性向量。迭代所有场景，<strong>对每个属性</strong>都学习到新样本的<strong>特征轨迹转移</strong>。最后，分别沿每个属性对应的转移轨迹预测对应的特征。最终对来自所有场景的预测值进行加权，得到合成图像。</p>\n<p>这篇我有点一知半解。看文章的公式，好像就用了一个线性模型来合成新样本。</p>\n<h1 id=\"Feature-Space-Transfer-for-Data-Augmentation-CVPR-2018\"><a href=\"#Feature-Space-Transfer-for-Data-Augmentation-CVPR-2018\" class=\"headerlink\" title=\"Feature Space Transfer for Data Augmentation(CVPR 2018)\"></a>Feature Space Transfer for Data Augmentation(CVPR 2018)</h1><p>同样是<strong>特征轨迹</strong>，这里的是<strong>姿态</strong>变化轨迹。用到<strong>解纠缠</strong>的思想，用两个编码器，将图像的<strong>外观</strong>和<strong>姿态</strong>两种属性分开来了。</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323150601178.png\" alt=\"特征空间转换示意图\"></p>\n<p>上图所示，不同的图像特征向量，可以映射到外观空间中的同一点，映射到姿态空间中的不同点。</p>\n<p>本文的模型结构是下图：</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/Research/small_samples_augmentation/image-20210323150827500.png\" alt=\"FATTEN架构\"></p>\n<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>刚开始写这篇的时候，被老师叫去谈话了。这个突然就变成了我的课题- -</p>\n<p>加油吧！这个礼拜先写这么多，之后慢慢补充吧。</p>"},{"title":"操作系统课设-1","date":"2019-06-20T02:56:35.000Z","_content":"\n准备了两天，实在的活没干，补充知识学了不少\n<!--more-->\n\n---\n\n## 预编译头（Visual Studio中的应用）\n\n### 是什么？为什么？\n\n预编译是一项编译源码并产生中间代码的技术，它能使编译速度提高。总的来说就是在开发Windows程序时，一个工程中的很多CPP文件都会用到相同的头文件。而这些头文件如果很大的话（比如说windows.h），就会让编译速度变得很慢，因为#include语句其实就是把整个头文件复制过来了。\n考虑到这个问题，有人就想到了将大家都要用到的头文件，在编译CPP文件之前就放在一起编译一下。这样就能很大地减少项目编译的时间。\n\n### 怎么用？\n\n在每个CPP中都要包括stdafx.h，stdafx.h中是大家都要用到的头文件（#include进来）。\nPS：stdafx.cpp包含stdafx.h。stdafx.cpp编译后得到的是.pch文件\n\n---\n\n## 报错（scanf is unsafe）\n\n将SDL选为“否”。这是VS的安全周期检查，将一些Warning直接变成了Error。\n\n---\n\n## 宏定义\n\n\\#define\n\\#ifdef\n\\#endif\n\n常见的预处理指令如下：\n\n\\#： 空指令，无任何效果\n\\#include： 包含一个源代码文件\n\\#define：定义宏\n\\#undef：取消已定义的宏\n\\#if：如果给定条件为真，则编译下面代码\n\\#ifdef：如果宏已经定义，则编译下面代码\n\\#ifndef：如果宏没有定义，则编译下面代码\n\\#elif：如果前面的#if给定条件不为真，当前条件为真，则编译下面代码\n\\#endif：结束一个#if……#else条件编译块\n\\#error：停止编译并显示错误信息\n\n**1.防止一个头文件被重复包含**\n```\n#ifndef COMDEF_H\n#define COMDEF_H\n// 头文件内容\n\n#endif\n```\n**2.为什么要用宏定义？**\n待补充。。。\n\n---\n\n## 程序、作业、进程\n\n程序是静态的，长期存在于电脑中的。它是一段代码，是计算机要执行的指令集合。\n作业是交给计算机要完成的任务。分成四个阶段：作业提交、收容、执行和完成。它包括了程序，另外还有数据和控制命令。\n进程则是操作系统中资源分配的基本单位，它是一段程序在一个数据集上的执行**过程**。一个作业分为一个或多个进程，一个程序可以由一个或多个进程完成，而一个进程也可以去执行一个或多个程序。\n\n---\n\n## 当Windows打开.exe文件时，都发生了什么？\n\n**第一个问题，exe是什么？**\n.exe就是源程序经过编译链接之后生成的可执行文件，是PE的一种文件形式。组成部分是机器指令和数据。由操作系统装载到内存中后，就可以运行了。\n**第二个问题，PE是什么？**\n.exe是一种文件类型，而PE是一种文件格式。\nPE文件格式封装了Windows操作系统加载可执行程序代码时所必需的一些信息。都什么信息呢？可以参考一下PE的文件内部结构。\n![PE文件结构][1]\n另外，详见这篇文章：[深入剖析PE文件][2]\n**第三个问题，简单讲讲如何加载exe文件。**\n（这里看的是[Windows2000的有关资料][3]，现在可能有点变化，但是我觉得应该也变得不大）\n点击.exe文件后，首先调用内核的CreateProcess()函数，创建进程。\n同时，调用NTCreateProcess()函数，系统内部创建一个进程内核对象。用于存放进程的统计信息，同时分配给他虚拟存储空间。\n接着，CreateProcess()会扫描文件头（就是PE文件格式中的有关内容），加载代码和数据段到内存当中。\n至此，进程创建完成。然后创建有关线程开始执行。第一个要找到的是**启动函数**，它在程序链接的时候就放到了程序开始的位置。启动函数会完成程序运行的初始化工作。\n在**启动函数**代码中会调用**进入点函数**，每一个线程有自己的进入点函数（eg. main函数）\n\n## 后记\n\n有点想法啦，接下来开始做点实在的！\n\n  [1]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/OS/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.jpg\n  [2]: https://blog.csdn.net/arau_sh/article/details/78625932\n  [3]: https://blog.csdn.net/H002399/article/details/46375481\n","source":"_posts/操作系统课设-1.md","raw":"---\ntitle: 操作系统课设-1\ndate: 2019-06-20 10:56:35\ncategories: 课程设计\nphoto: https://forlwq.oss-cn-hangzhou.aliyuncs.com/OS/7.jpg\n---\n\n准备了两天，实在的活没干，补充知识学了不少\n<!--more-->\n\n---\n\n## 预编译头（Visual Studio中的应用）\n\n### 是什么？为什么？\n\n预编译是一项编译源码并产生中间代码的技术，它能使编译速度提高。总的来说就是在开发Windows程序时，一个工程中的很多CPP文件都会用到相同的头文件。而这些头文件如果很大的话（比如说windows.h），就会让编译速度变得很慢，因为#include语句其实就是把整个头文件复制过来了。\n考虑到这个问题，有人就想到了将大家都要用到的头文件，在编译CPP文件之前就放在一起编译一下。这样就能很大地减少项目编译的时间。\n\n### 怎么用？\n\n在每个CPP中都要包括stdafx.h，stdafx.h中是大家都要用到的头文件（#include进来）。\nPS：stdafx.cpp包含stdafx.h。stdafx.cpp编译后得到的是.pch文件\n\n---\n\n## 报错（scanf is unsafe）\n\n将SDL选为“否”。这是VS的安全周期检查，将一些Warning直接变成了Error。\n\n---\n\n## 宏定义\n\n\\#define\n\\#ifdef\n\\#endif\n\n常见的预处理指令如下：\n\n\\#： 空指令，无任何效果\n\\#include： 包含一个源代码文件\n\\#define：定义宏\n\\#undef：取消已定义的宏\n\\#if：如果给定条件为真，则编译下面代码\n\\#ifdef：如果宏已经定义，则编译下面代码\n\\#ifndef：如果宏没有定义，则编译下面代码\n\\#elif：如果前面的#if给定条件不为真，当前条件为真，则编译下面代码\n\\#endif：结束一个#if……#else条件编译块\n\\#error：停止编译并显示错误信息\n\n**1.防止一个头文件被重复包含**\n```\n#ifndef COMDEF_H\n#define COMDEF_H\n// 头文件内容\n\n#endif\n```\n**2.为什么要用宏定义？**\n待补充。。。\n\n---\n\n## 程序、作业、进程\n\n程序是静态的，长期存在于电脑中的。它是一段代码，是计算机要执行的指令集合。\n作业是交给计算机要完成的任务。分成四个阶段：作业提交、收容、执行和完成。它包括了程序，另外还有数据和控制命令。\n进程则是操作系统中资源分配的基本单位，它是一段程序在一个数据集上的执行**过程**。一个作业分为一个或多个进程，一个程序可以由一个或多个进程完成，而一个进程也可以去执行一个或多个程序。\n\n---\n\n## 当Windows打开.exe文件时，都发生了什么？\n\n**第一个问题，exe是什么？**\n.exe就是源程序经过编译链接之后生成的可执行文件，是PE的一种文件形式。组成部分是机器指令和数据。由操作系统装载到内存中后，就可以运行了。\n**第二个问题，PE是什么？**\n.exe是一种文件类型，而PE是一种文件格式。\nPE文件格式封装了Windows操作系统加载可执行程序代码时所必需的一些信息。都什么信息呢？可以参考一下PE的文件内部结构。\n![PE文件结构][1]\n另外，详见这篇文章：[深入剖析PE文件][2]\n**第三个问题，简单讲讲如何加载exe文件。**\n（这里看的是[Windows2000的有关资料][3]，现在可能有点变化，但是我觉得应该也变得不大）\n点击.exe文件后，首先调用内核的CreateProcess()函数，创建进程。\n同时，调用NTCreateProcess()函数，系统内部创建一个进程内核对象。用于存放进程的统计信息，同时分配给他虚拟存储空间。\n接着，CreateProcess()会扫描文件头（就是PE文件格式中的有关内容），加载代码和数据段到内存当中。\n至此，进程创建完成。然后创建有关线程开始执行。第一个要找到的是**启动函数**，它在程序链接的时候就放到了程序开始的位置。启动函数会完成程序运行的初始化工作。\n在**启动函数**代码中会调用**进入点函数**，每一个线程有自己的进入点函数（eg. main函数）\n\n## 后记\n\n有点想法啦，接下来开始做点实在的！\n\n  [1]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/OS/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.jpg\n  [2]: https://blog.csdn.net/arau_sh/article/details/78625932\n  [3]: https://blog.csdn.net/H002399/article/details/46375481\n","slug":"操作系统课设-1","published":1,"updated":"2019-06-20T02:56:35.000Z","photos":["https://forlwq.oss-cn-hangzhou.aliyuncs.com/OS/7.jpg"],"comments":1,"layout":"post","link":"","_id":"cl1jeagh9002q38t4359gbz2n","content":"<p>准备了两天，实在的活没干，补充知识学了不少</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"预编译头（Visual-Studio中的应用）\"><a href=\"#预编译头（Visual-Studio中的应用）\" class=\"headerlink\" title=\"预编译头（Visual Studio中的应用）\"></a>预编译头（Visual Studio中的应用）</h2><h3 id=\"是什么？为什么？\"><a href=\"#是什么？为什么？\" class=\"headerlink\" title=\"是什么？为什么？\"></a>是什么？为什么？</h3><p>预编译是一项编译源码并产生中间代码的技术，它能使编译速度提高。总的来说就是在开发Windows程序时，一个工程中的很多CPP文件都会用到相同的头文件。而这些头文件如果很大的话（比如说windows.h），就会让编译速度变得很慢，因为#include语句其实就是把整个头文件复制过来了。<br>考虑到这个问题，有人就想到了将大家都要用到的头文件，在编译CPP文件之前就放在一起编译一下。这样就能很大地减少项目编译的时间。</p>\n<h3 id=\"怎么用？\"><a href=\"#怎么用？\" class=\"headerlink\" title=\"怎么用？\"></a>怎么用？</h3><p>在每个CPP中都要包括stdafx.h，stdafx.h中是大家都要用到的头文件（#include进来）。<br>PS：stdafx.cpp包含stdafx.h。stdafx.cpp编译后得到的是.pch文件</p>\n<hr>\n<h2 id=\"报错（scanf-is-unsafe）\"><a href=\"#报错（scanf-is-unsafe）\" class=\"headerlink\" title=\"报错（scanf is unsafe）\"></a>报错（scanf is unsafe）</h2><p>将SDL选为“否”。这是VS的安全周期检查，将一些Warning直接变成了Error。</p>\n<hr>\n<h2 id=\"宏定义\"><a href=\"#宏定义\" class=\"headerlink\" title=\"宏定义\"></a>宏定义</h2><p>#define<br>#ifdef<br>#endif</p>\n<p>常见的预处理指令如下：</p>\n<p>#： 空指令，无任何效果<br>#include： 包含一个源代码文件<br>#define：定义宏<br>#undef：取消已定义的宏<br>#if：如果给定条件为真，则编译下面代码<br>#ifdef：如果宏已经定义，则编译下面代码<br>#ifndef：如果宏没有定义，则编译下面代码<br>#elif：如果前面的#if给定条件不为真，当前条件为真，则编译下面代码<br>#endif：结束一个#if……#else条件编译块<br>#error：停止编译并显示错误信息</p>\n<p><strong>1.防止一个头文件被重复包含</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ifndef COMDEF_H</span><br><span class=\"line\">#define COMDEF_H</span><br><span class=\"line\">// 头文件内容</span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p><strong>2.为什么要用宏定义？</strong><br>待补充。。。</p>\n<hr>\n<h2 id=\"程序、作业、进程\"><a href=\"#程序、作业、进程\" class=\"headerlink\" title=\"程序、作业、进程\"></a>程序、作业、进程</h2><p>程序是静态的，长期存在于电脑中的。它是一段代码，是计算机要执行的指令集合。<br>作业是交给计算机要完成的任务。分成四个阶段：作业提交、收容、执行和完成。它包括了程序，另外还有数据和控制命令。<br>进程则是操作系统中资源分配的基本单位，它是一段程序在一个数据集上的执行<strong>过程</strong>。一个作业分为一个或多个进程，一个程序可以由一个或多个进程完成，而一个进程也可以去执行一个或多个程序。</p>\n<hr>\n<h2 id=\"当Windows打开-exe文件时，都发生了什么？\"><a href=\"#当Windows打开-exe文件时，都发生了什么？\" class=\"headerlink\" title=\"当Windows打开.exe文件时，都发生了什么？\"></a>当Windows打开.exe文件时，都发生了什么？</h2><p><strong>第一个问题，exe是什么？</strong><br>.exe就是源程序经过编译链接之后生成的可执行文件，是PE的一种文件形式。组成部分是机器指令和数据。由操作系统装载到内存中后，就可以运行了。<br><strong>第二个问题，PE是什么？</strong><br>.exe是一种文件类型，而PE是一种文件格式。<br>PE文件格式封装了Windows操作系统加载可执行程序代码时所必需的一些信息。都什么信息呢？可以参考一下PE的文件内部结构。<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/OS/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.jpg\" alt=\"PE文件结构\"><br>另外，详见这篇文章：<a href=\"https://blog.csdn.net/arau_sh/article/details/78625932\">深入剖析PE文件</a><br><strong>第三个问题，简单讲讲如何加载exe文件。</strong><br>（这里看的是<a href=\"https://blog.csdn.net/H002399/article/details/46375481\">Windows2000的有关资料</a>，现在可能有点变化，但是我觉得应该也变得不大）<br>点击.exe文件后，首先调用内核的CreateProcess()函数，创建进程。<br>同时，调用NTCreateProcess()函数，系统内部创建一个进程内核对象。用于存放进程的统计信息，同时分配给他虚拟存储空间。<br>接着，CreateProcess()会扫描文件头（就是PE文件格式中的有关内容），加载代码和数据段到内存当中。<br>至此，进程创建完成。然后创建有关线程开始执行。第一个要找到的是<strong>启动函数</strong>，它在程序链接的时候就放到了程序开始的位置。启动函数会完成程序运行的初始化工作。<br>在<strong>启动函数</strong>代码中会调用<strong>进入点函数</strong>，每一个线程有自己的进入点函数（eg. main函数）</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>有点想法啦，接下来开始做点实在的！</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>准备了两天，实在的活没干，补充知识学了不少</p>","more":"<hr>\n<h2 id=\"预编译头（Visual-Studio中的应用）\"><a href=\"#预编译头（Visual-Studio中的应用）\" class=\"headerlink\" title=\"预编译头（Visual Studio中的应用）\"></a>预编译头（Visual Studio中的应用）</h2><h3 id=\"是什么？为什么？\"><a href=\"#是什么？为什么？\" class=\"headerlink\" title=\"是什么？为什么？\"></a>是什么？为什么？</h3><p>预编译是一项编译源码并产生中间代码的技术，它能使编译速度提高。总的来说就是在开发Windows程序时，一个工程中的很多CPP文件都会用到相同的头文件。而这些头文件如果很大的话（比如说windows.h），就会让编译速度变得很慢，因为#include语句其实就是把整个头文件复制过来了。<br>考虑到这个问题，有人就想到了将大家都要用到的头文件，在编译CPP文件之前就放在一起编译一下。这样就能很大地减少项目编译的时间。</p>\n<h3 id=\"怎么用？\"><a href=\"#怎么用？\" class=\"headerlink\" title=\"怎么用？\"></a>怎么用？</h3><p>在每个CPP中都要包括stdafx.h，stdafx.h中是大家都要用到的头文件（#include进来）。<br>PS：stdafx.cpp包含stdafx.h。stdafx.cpp编译后得到的是.pch文件</p>\n<hr>\n<h2 id=\"报错（scanf-is-unsafe）\"><a href=\"#报错（scanf-is-unsafe）\" class=\"headerlink\" title=\"报错（scanf is unsafe）\"></a>报错（scanf is unsafe）</h2><p>将SDL选为“否”。这是VS的安全周期检查，将一些Warning直接变成了Error。</p>\n<hr>\n<h2 id=\"宏定义\"><a href=\"#宏定义\" class=\"headerlink\" title=\"宏定义\"></a>宏定义</h2><p>#define<br>#ifdef<br>#endif</p>\n<p>常见的预处理指令如下：</p>\n<p>#： 空指令，无任何效果<br>#include： 包含一个源代码文件<br>#define：定义宏<br>#undef：取消已定义的宏<br>#if：如果给定条件为真，则编译下面代码<br>#ifdef：如果宏已经定义，则编译下面代码<br>#ifndef：如果宏没有定义，则编译下面代码<br>#elif：如果前面的#if给定条件不为真，当前条件为真，则编译下面代码<br>#endif：结束一个#if……#else条件编译块<br>#error：停止编译并显示错误信息</p>\n<p><strong>1.防止一个头文件被重复包含</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ifndef COMDEF_H</span><br><span class=\"line\">#define COMDEF_H</span><br><span class=\"line\">// 头文件内容</span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p><strong>2.为什么要用宏定义？</strong><br>待补充。。。</p>\n<hr>\n<h2 id=\"程序、作业、进程\"><a href=\"#程序、作业、进程\" class=\"headerlink\" title=\"程序、作业、进程\"></a>程序、作业、进程</h2><p>程序是静态的，长期存在于电脑中的。它是一段代码，是计算机要执行的指令集合。<br>作业是交给计算机要完成的任务。分成四个阶段：作业提交、收容、执行和完成。它包括了程序，另外还有数据和控制命令。<br>进程则是操作系统中资源分配的基本单位，它是一段程序在一个数据集上的执行<strong>过程</strong>。一个作业分为一个或多个进程，一个程序可以由一个或多个进程完成，而一个进程也可以去执行一个或多个程序。</p>\n<hr>\n<h2 id=\"当Windows打开-exe文件时，都发生了什么？\"><a href=\"#当Windows打开-exe文件时，都发生了什么？\" class=\"headerlink\" title=\"当Windows打开.exe文件时，都发生了什么？\"></a>当Windows打开.exe文件时，都发生了什么？</h2><p><strong>第一个问题，exe是什么？</strong><br>.exe就是源程序经过编译链接之后生成的可执行文件，是PE的一种文件形式。组成部分是机器指令和数据。由操作系统装载到内存中后，就可以运行了。<br><strong>第二个问题，PE是什么？</strong><br>.exe是一种文件类型，而PE是一种文件格式。<br>PE文件格式封装了Windows操作系统加载可执行程序代码时所必需的一些信息。都什么信息呢？可以参考一下PE的文件内部结构。<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/OS/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.jpg\" alt=\"PE文件结构\"><br>另外，详见这篇文章：<a href=\"https://blog.csdn.net/arau_sh/article/details/78625932\">深入剖析PE文件</a><br><strong>第三个问题，简单讲讲如何加载exe文件。</strong><br>（这里看的是<a href=\"https://blog.csdn.net/H002399/article/details/46375481\">Windows2000的有关资料</a>，现在可能有点变化，但是我觉得应该也变得不大）<br>点击.exe文件后，首先调用内核的CreateProcess()函数，创建进程。<br>同时，调用NTCreateProcess()函数，系统内部创建一个进程内核对象。用于存放进程的统计信息，同时分配给他虚拟存储空间。<br>接着，CreateProcess()会扫描文件头（就是PE文件格式中的有关内容），加载代码和数据段到内存当中。<br>至此，进程创建完成。然后创建有关线程开始执行。第一个要找到的是<strong>启动函数</strong>，它在程序链接的时候就放到了程序开始的位置。启动函数会完成程序运行的初始化工作。<br>在<strong>启动函数</strong>代码中会调用<strong>进入点函数</strong>，每一个线程有自己的进入点函数（eg. main函数）</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>有点想法啦，接下来开始做点实在的！</p>"},{"title":"最大匹配算法与隐马尔科夫模型|中文分词|NLP","date":"2019-04-26T07:45:03.000Z","_content":"\n简单谈谈两种算法在中文分词中的实现与比较。\n<!--more-->\n\n---\n\n ~~季更博主居然更博啦！~~\n\n上学期上了自然语言理解这门课，最后两个实验一个是做写词机器人，另一个是中文分词。前者用了LSTM模型，虽参考了[MC胖虎][1]但效果并不好，就不多说了。\n本文就对中文分词的两种算法做个总结，分别是最大匹配算法和隐马尔科夫模型。\n\n## 最大匹配算法\n\n### 主要思想\n\n最大匹配算法分为正向和逆向两种。区别主要在于对句子的切分方向。前者从前向后，后者从后向前。\n总的来讲，基于现有的词典，设置最大分词长度，从前向后（或从后向前）切分句子。见流程图：\n![最大匹配算法流程图][2]\n\n接着来谈谈正向和逆向的区别\n> 对中文分词而言，一般逆向比正向效果好。\n\n但两种都有其局限性，于是有了双向匹配算法：分别进行正向和逆向切分，根据一定原则选择合适的切分方法。\n原则（参考[中文分词基础-新浪博客][3]）：\n\n> **1.颗粒度越大越好**：单词的字数越多，所能表示的含义越确切。如：“公安局长”可以分为“公安 局长”、“公安局长”、“公安局长”都算对，但是要用于语义分析，则“公安局长”的分词结果最好（当然前提是所使用的词典中有这个词）\n**2.非字典词和单字字典词越少越好**\n**3.总体词数越少越好**\n\n我实现了逆向匹配算法，代码比较简单，需要的话请留言。\n\n## 隐马尔可夫模型\n\n<center>![HMM][4]</center>\n\n隐马尔科夫模型（HMM）是一种统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。\n它是一个五元组：状态值集合，观察值集合，转移概率矩阵，发射概率矩阵和初始状态分布。\n在中文分词问题中，\n**状态值集合**：为（B,M,E,S），分别表示词首、词中、词尾和单独成词。\n**观察值集合**：待处理文本。\n**初始状态分布**：语料库中每个句子第一个字所处状态的概率。\n**转移概率矩阵**：某个字所处的某状态转移到下一个字对应的状态的概率。\n**发射概率矩阵**：表示语料库中所有字对应某个状态的概率。\n同时，使用**Viterbi算法**求解**最优路径**，即得到分词结果。\nViterbi算法是一种**动态规划**算法，它的主要思路是：\n1. 根据待处理文本s的第一个字，初始化**weight\\[4\\][N]**（N为s的长度，weight[4][N]表示4行N列的数组）。具体而言，weight[m][n]的含义是**第n个字对应状态m的概率**。\n2. 同时，为求解最优路径，我们再设置一个**path\\[4\\][n]**（N为s的长度，path[4][N]表示4行N列的数组）。具体而言，path[m][n]的含义是当前字的weight[m][n]取最大时，它的前一个字的状态。path数组为我们后续分词提供便捷。\n\n由第一个字的概率向后计算得到每一个字对应状态下的概率即weight[m][k]。\n计算过程代码如下（参考[HMM用于中文分词-简书][5]）：\n```\n    //i表示句子的第i个字\n    for(int j=0;j<4;j++)\n    {\n        for(int k=0;k<4;k++)\n        {\n            //找到第i个字为状态j时，第i-1个字转移到第i个字概率最大的\n            //即i-1取不同状态k时，求得最大的temp，作为weight[j][i]\n            //并记录i-1的状态k作为path[j][i]\n            temp=weight[k][i-1]+TransProb[k][j]+EmitProb[j][sentence[i]];       //weight的计算公式\n            if(temp>weight[j][i])\n            {\n                weight[j][i]=temp;\n                path[j][i]=k;\n            }\n        }\n    }\n```\n\n**Points**\n1. 需要词典和语料进行训练，是有监督的学习\n2. 对于词典中没有的词，在对文本进行分词时的计算要注意。\n\n### 隐马尔可夫模型的其他应用\n\n语音识别等\n\n### 一些补充\n\n读了吴军的《数学之美》，书中的第五章就是讲的隐马尔科夫模型。Vertibi算法是一个解码的功能，在分词中也就是求得weight矩阵并逆向分析得到分词结果（即Path）。\n他在书里的补充部分还提到了鲍姆-韦尔奇算法，用来计算模型参数，在我们这个分词应用中还没有用上，这个我也没有太弄懂。\n\n## 最大匹配算法与隐马尔可夫模型比较\n\n前者优点在于易于实现，而对于一些未登录词的识别效果不佳。\n后者优点在于能较好地识别未登录词，但是计算量大。\n两个正好相反~\n下面是个演示，可以看出对一些~~奇怪的~~词语，隐马尔科夫模型分词效果会比较好。\n\n![CompareImg][6]\n\n## One More Thing\n\n1. Python中文读的问题。字典是通过老师给的新闻语料创建的。涉及一个读入问题和一个除杂问题。我觉得中文处理还挺麻烦的。\n一个是文件转为无BOM的utf-8，一个是中文字符范围，一个是正则表达式。\n（1）转为无BOM的UTF-8用NotePad就可以。\n（2）网上就能查到\n（3）利用正则和中文字符范围可以除杂\n\n## 后记\n\n时隔不知道几个月，再把这篇草稿翻出来。很多知识忘了，又重新学了一遍，算法还是得常看呐。旧文凑更啦~ o(\\*￣▽￣\\*)ブ\n深度学习，神经网络这一类的东西都给我一种不靠谱的感觉。再比如说，模型比较起来结果很明显的隐马尔可夫模型会好一些，但是为什么呢？\n我也怀疑是因为我自己没有动手搭建过的原因，给我一种很玄幻的感觉。\n\n\n<font color = #f4606c>Anyway,那么下一个目标是自己动手搭建神经网络。</font>\n\n<img src=\"http://www.webpagefx.com/tools/emoji-cheat-sheet/graphics/emojis/kissing.png\" height=\"30\" width=\"30\" align=\"left\">\n\n\n\n  [1]: https://github.com/hjptriplebee/Chinese_poem_generator\n  [2]: http://forlwq.oss-cn-hangzhou.aliyuncs.com/MaximumMatch.png\n  [3]: http://blog.sina.com.cn/s/blog_53daccf401011t74.html\n  [4]: http://forlwq.oss-cn-hangzhou.aliyuncs.com/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB.jpg\n  [5]: https://www.jianshu.com/p/0eee07a5bf38\n  [6]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/fen-ci.jpg\n\n","source":"_posts/最大匹配算法与隐马尔科夫模型-中文分词-NLP.md","raw":"---\ntitle: 最大匹配算法与隐马尔科夫模型|中文分词|NLP\ndate: 2019-04-26 15:45:03\ncategories: \n---\n\n简单谈谈两种算法在中文分词中的实现与比较。\n<!--more-->\n\n---\n\n ~~季更博主居然更博啦！~~\n\n上学期上了自然语言理解这门课，最后两个实验一个是做写词机器人，另一个是中文分词。前者用了LSTM模型，虽参考了[MC胖虎][1]但效果并不好，就不多说了。\n本文就对中文分词的两种算法做个总结，分别是最大匹配算法和隐马尔科夫模型。\n\n## 最大匹配算法\n\n### 主要思想\n\n最大匹配算法分为正向和逆向两种。区别主要在于对句子的切分方向。前者从前向后，后者从后向前。\n总的来讲，基于现有的词典，设置最大分词长度，从前向后（或从后向前）切分句子。见流程图：\n![最大匹配算法流程图][2]\n\n接着来谈谈正向和逆向的区别\n> 对中文分词而言，一般逆向比正向效果好。\n\n但两种都有其局限性，于是有了双向匹配算法：分别进行正向和逆向切分，根据一定原则选择合适的切分方法。\n原则（参考[中文分词基础-新浪博客][3]）：\n\n> **1.颗粒度越大越好**：单词的字数越多，所能表示的含义越确切。如：“公安局长”可以分为“公安 局长”、“公安局长”、“公安局长”都算对，但是要用于语义分析，则“公安局长”的分词结果最好（当然前提是所使用的词典中有这个词）\n**2.非字典词和单字字典词越少越好**\n**3.总体词数越少越好**\n\n我实现了逆向匹配算法，代码比较简单，需要的话请留言。\n\n## 隐马尔可夫模型\n\n<center>![HMM][4]</center>\n\n隐马尔科夫模型（HMM）是一种统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。\n它是一个五元组：状态值集合，观察值集合，转移概率矩阵，发射概率矩阵和初始状态分布。\n在中文分词问题中，\n**状态值集合**：为（B,M,E,S），分别表示词首、词中、词尾和单独成词。\n**观察值集合**：待处理文本。\n**初始状态分布**：语料库中每个句子第一个字所处状态的概率。\n**转移概率矩阵**：某个字所处的某状态转移到下一个字对应的状态的概率。\n**发射概率矩阵**：表示语料库中所有字对应某个状态的概率。\n同时，使用**Viterbi算法**求解**最优路径**，即得到分词结果。\nViterbi算法是一种**动态规划**算法，它的主要思路是：\n1. 根据待处理文本s的第一个字，初始化**weight\\[4\\][N]**（N为s的长度，weight[4][N]表示4行N列的数组）。具体而言，weight[m][n]的含义是**第n个字对应状态m的概率**。\n2. 同时，为求解最优路径，我们再设置一个**path\\[4\\][n]**（N为s的长度，path[4][N]表示4行N列的数组）。具体而言，path[m][n]的含义是当前字的weight[m][n]取最大时，它的前一个字的状态。path数组为我们后续分词提供便捷。\n\n由第一个字的概率向后计算得到每一个字对应状态下的概率即weight[m][k]。\n计算过程代码如下（参考[HMM用于中文分词-简书][5]）：\n```\n    //i表示句子的第i个字\n    for(int j=0;j<4;j++)\n    {\n        for(int k=0;k<4;k++)\n        {\n            //找到第i个字为状态j时，第i-1个字转移到第i个字概率最大的\n            //即i-1取不同状态k时，求得最大的temp，作为weight[j][i]\n            //并记录i-1的状态k作为path[j][i]\n            temp=weight[k][i-1]+TransProb[k][j]+EmitProb[j][sentence[i]];       //weight的计算公式\n            if(temp>weight[j][i])\n            {\n                weight[j][i]=temp;\n                path[j][i]=k;\n            }\n        }\n    }\n```\n\n**Points**\n1. 需要词典和语料进行训练，是有监督的学习\n2. 对于词典中没有的词，在对文本进行分词时的计算要注意。\n\n### 隐马尔可夫模型的其他应用\n\n语音识别等\n\n### 一些补充\n\n读了吴军的《数学之美》，书中的第五章就是讲的隐马尔科夫模型。Vertibi算法是一个解码的功能，在分词中也就是求得weight矩阵并逆向分析得到分词结果（即Path）。\n他在书里的补充部分还提到了鲍姆-韦尔奇算法，用来计算模型参数，在我们这个分词应用中还没有用上，这个我也没有太弄懂。\n\n## 最大匹配算法与隐马尔可夫模型比较\n\n前者优点在于易于实现，而对于一些未登录词的识别效果不佳。\n后者优点在于能较好地识别未登录词，但是计算量大。\n两个正好相反~\n下面是个演示，可以看出对一些~~奇怪的~~词语，隐马尔科夫模型分词效果会比较好。\n\n![CompareImg][6]\n\n## One More Thing\n\n1. Python中文读的问题。字典是通过老师给的新闻语料创建的。涉及一个读入问题和一个除杂问题。我觉得中文处理还挺麻烦的。\n一个是文件转为无BOM的utf-8，一个是中文字符范围，一个是正则表达式。\n（1）转为无BOM的UTF-8用NotePad就可以。\n（2）网上就能查到\n（3）利用正则和中文字符范围可以除杂\n\n## 后记\n\n时隔不知道几个月，再把这篇草稿翻出来。很多知识忘了，又重新学了一遍，算法还是得常看呐。旧文凑更啦~ o(\\*￣▽￣\\*)ブ\n深度学习，神经网络这一类的东西都给我一种不靠谱的感觉。再比如说，模型比较起来结果很明显的隐马尔可夫模型会好一些，但是为什么呢？\n我也怀疑是因为我自己没有动手搭建过的原因，给我一种很玄幻的感觉。\n\n\n<font color = #f4606c>Anyway,那么下一个目标是自己动手搭建神经网络。</font>\n\n<img src=\"http://www.webpagefx.com/tools/emoji-cheat-sheet/graphics/emojis/kissing.png\" height=\"30\" width=\"30\" align=\"left\">\n\n\n\n  [1]: https://github.com/hjptriplebee/Chinese_poem_generator\n  [2]: http://forlwq.oss-cn-hangzhou.aliyuncs.com/MaximumMatch.png\n  [3]: http://blog.sina.com.cn/s/blog_53daccf401011t74.html\n  [4]: http://forlwq.oss-cn-hangzhou.aliyuncs.com/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB.jpg\n  [5]: https://www.jianshu.com/p/0eee07a5bf38\n  [6]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/fen-ci.jpg\n\n","slug":"最大匹配算法与隐马尔科夫模型-中文分词-NLP","published":1,"updated":"2019-04-26T07:45:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeagh9002u38t45iv8hfwc","content":"<p>简单谈谈两种算法在中文分词中的实现与比较。</p>\n<span id=\"more\"></span>\n\n<hr>\n<p> <del>季更博主居然更博啦！</del></p>\n<p>上学期上了自然语言理解这门课，最后两个实验一个是做写词机器人，另一个是中文分词。前者用了LSTM模型，虽参考了<a href=\"https://github.com/hjptriplebee/Chinese_poem_generator\">MC胖虎</a>但效果并不好，就不多说了。<br>本文就对中文分词的两种算法做个总结，分别是最大匹配算法和隐马尔科夫模型。</p>\n<h2 id=\"最大匹配算法\"><a href=\"#最大匹配算法\" class=\"headerlink\" title=\"最大匹配算法\"></a>最大匹配算法</h2><h3 id=\"主要思想\"><a href=\"#主要思想\" class=\"headerlink\" title=\"主要思想\"></a>主要思想</h3><p>最大匹配算法分为正向和逆向两种。区别主要在于对句子的切分方向。前者从前向后，后者从后向前。<br>总的来讲，基于现有的词典，设置最大分词长度，从前向后（或从后向前）切分句子。见流程图：<br><img src=\"http://forlwq.oss-cn-hangzhou.aliyuncs.com/MaximumMatch.png\" alt=\"最大匹配算法流程图\"></p>\n<p>接着来谈谈正向和逆向的区别</p>\n<blockquote>\n<p>对中文分词而言，一般逆向比正向效果好。</p>\n</blockquote>\n<p>但两种都有其局限性，于是有了双向匹配算法：分别进行正向和逆向切分，根据一定原则选择合适的切分方法。<br>原则（参考<a href=\"http://blog.sina.com.cn/s/blog_53daccf401011t74.html\">中文分词基础-新浪博客</a>）：</p>\n<blockquote>\n<p><strong>1.颗粒度越大越好</strong>：单词的字数越多，所能表示的含义越确切。如：“公安局长”可以分为“公安 局长”、“公安局长”、“公安局长”都算对，但是要用于语义分析，则“公安局长”的分词结果最好（当然前提是所使用的词典中有这个词）<br><strong>2.非字典词和单字字典词越少越好</strong><br><strong>3.总体词数越少越好</strong></p>\n</blockquote>\n<p>我实现了逆向匹配算法，代码比较简单，需要的话请留言。</p>\n<h2 id=\"隐马尔可夫模型\"><a href=\"#隐马尔可夫模型\" class=\"headerlink\" title=\"隐马尔可夫模型\"></a>隐马尔可夫模型</h2><center>![HMM][4]</center>\n\n<p>隐马尔科夫模型（HMM）是一种统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。<br>它是一个五元组：状态值集合，观察值集合，转移概率矩阵，发射概率矩阵和初始状态分布。<br>在中文分词问题中，<br><strong>状态值集合</strong>：为（B,M,E,S），分别表示词首、词中、词尾和单独成词。<br><strong>观察值集合</strong>：待处理文本。<br><strong>初始状态分布</strong>：语料库中每个句子第一个字所处状态的概率。<br><strong>转移概率矩阵</strong>：某个字所处的某状态转移到下一个字对应的状态的概率。<br><strong>发射概率矩阵</strong>：表示语料库中所有字对应某个状态的概率。<br>同时，使用<strong>Viterbi算法</strong>求解<strong>最优路径</strong>，即得到分词结果。<br>Viterbi算法是一种<strong>动态规划</strong>算法，它的主要思路是：</p>\n<ol>\n<li>根据待处理文本s的第一个字，初始化<strong>weight[4][N]<strong>（N为s的长度，weight[4][N]表示4行N列的数组）。具体而言，weight[m][n]的含义是</strong>第n个字对应状态m的概率</strong>。</li>\n<li>同时，为求解最优路径，我们再设置一个**path[4][n]**（N为s的长度，path[4][N]表示4行N列的数组）。具体而言，path[m][n]的含义是当前字的weight[m][n]取最大时，它的前一个字的状态。path数组为我们后续分词提供便捷。</li>\n</ol>\n<p>由第一个字的概率向后计算得到每一个字对应状态下的概率即weight[m][k]。<br>计算过程代码如下（参考<a href=\"https://www.jianshu.com/p/0eee07a5bf38\">HMM用于中文分词-简书</a>）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//i表示句子的第i个字</span><br><span class=\"line\">for(int j=0;j&lt;4;j++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(int k=0;k&lt;4;k++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //找到第i个字为状态j时，第i-1个字转移到第i个字概率最大的</span><br><span class=\"line\">        //即i-1取不同状态k时，求得最大的temp，作为weight[j][i]</span><br><span class=\"line\">        //并记录i-1的状态k作为path[j][i]</span><br><span class=\"line\">        temp=weight[k][i-1]+TransProb[k][j]+EmitProb[j][sentence[i]];       //weight的计算公式</span><br><span class=\"line\">        if(temp&gt;weight[j][i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            weight[j][i]=temp;</span><br><span class=\"line\">            path[j][i]=k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Points</strong></p>\n<ol>\n<li>需要词典和语料进行训练，是有监督的学习</li>\n<li>对于词典中没有的词，在对文本进行分词时的计算要注意。</li>\n</ol>\n<h3 id=\"隐马尔可夫模型的其他应用\"><a href=\"#隐马尔可夫模型的其他应用\" class=\"headerlink\" title=\"隐马尔可夫模型的其他应用\"></a>隐马尔可夫模型的其他应用</h3><p>语音识别等</p>\n<h3 id=\"一些补充\"><a href=\"#一些补充\" class=\"headerlink\" title=\"一些补充\"></a>一些补充</h3><p>读了吴军的《数学之美》，书中的第五章就是讲的隐马尔科夫模型。Vertibi算法是一个解码的功能，在分词中也就是求得weight矩阵并逆向分析得到分词结果（即Path）。<br>他在书里的补充部分还提到了鲍姆-韦尔奇算法，用来计算模型参数，在我们这个分词应用中还没有用上，这个我也没有太弄懂。</p>\n<h2 id=\"最大匹配算法与隐马尔可夫模型比较\"><a href=\"#最大匹配算法与隐马尔可夫模型比较\" class=\"headerlink\" title=\"最大匹配算法与隐马尔可夫模型比较\"></a>最大匹配算法与隐马尔可夫模型比较</h2><p>前者优点在于易于实现，而对于一些未登录词的识别效果不佳。<br>后者优点在于能较好地识别未登录词，但是计算量大。<br>两个正好相反~<br>下面是个演示，可以看出对一些<del>奇怪的</del>词语，隐马尔科夫模型分词效果会比较好。</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/fen-ci.jpg\" alt=\"CompareImg\"></p>\n<h2 id=\"One-More-Thing\"><a href=\"#One-More-Thing\" class=\"headerlink\" title=\"One More Thing\"></a>One More Thing</h2><ol>\n<li>Python中文读的问题。字典是通过老师给的新闻语料创建的。涉及一个读入问题和一个除杂问题。我觉得中文处理还挺麻烦的。<br>一个是文件转为无BOM的utf-8，一个是中文字符范围，一个是正则表达式。<br>（1）转为无BOM的UTF-8用NotePad就可以。<br>（2）网上就能查到<br>（3）利用正则和中文字符范围可以除杂</li>\n</ol>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>时隔不知道几个月，再把这篇草稿翻出来。很多知识忘了，又重新学了一遍，算法还是得常看呐。旧文凑更啦~ o(*￣▽￣*)ブ<br>深度学习，神经网络这一类的东西都给我一种不靠谱的感觉。再比如说，模型比较起来结果很明显的隐马尔可夫模型会好一些，但是为什么呢？<br>我也怀疑是因为我自己没有动手搭建过的原因，给我一种很玄幻的感觉。</p>\n<p><font color = #f4606c>Anyway,那么下一个目标是自己动手搭建神经网络。</font></p>\n<img src=\"http://www.webpagefx.com/tools/emoji-cheat-sheet/graphics/emojis/kissing.png\" height=\"30\" width=\"30\" align=\"left\">\n\n\n\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>简单谈谈两种算法在中文分词中的实现与比较。</p>","more":"<hr>\n<p> <del>季更博主居然更博啦！</del></p>\n<p>上学期上了自然语言理解这门课，最后两个实验一个是做写词机器人，另一个是中文分词。前者用了LSTM模型，虽参考了<a href=\"https://github.com/hjptriplebee/Chinese_poem_generator\">MC胖虎</a>但效果并不好，就不多说了。<br>本文就对中文分词的两种算法做个总结，分别是最大匹配算法和隐马尔科夫模型。</p>\n<h2 id=\"最大匹配算法\"><a href=\"#最大匹配算法\" class=\"headerlink\" title=\"最大匹配算法\"></a>最大匹配算法</h2><h3 id=\"主要思想\"><a href=\"#主要思想\" class=\"headerlink\" title=\"主要思想\"></a>主要思想</h3><p>最大匹配算法分为正向和逆向两种。区别主要在于对句子的切分方向。前者从前向后，后者从后向前。<br>总的来讲，基于现有的词典，设置最大分词长度，从前向后（或从后向前）切分句子。见流程图：<br><img src=\"http://forlwq.oss-cn-hangzhou.aliyuncs.com/MaximumMatch.png\" alt=\"最大匹配算法流程图\"></p>\n<p>接着来谈谈正向和逆向的区别</p>\n<blockquote>\n<p>对中文分词而言，一般逆向比正向效果好。</p>\n</blockquote>\n<p>但两种都有其局限性，于是有了双向匹配算法：分别进行正向和逆向切分，根据一定原则选择合适的切分方法。<br>原则（参考<a href=\"http://blog.sina.com.cn/s/blog_53daccf401011t74.html\">中文分词基础-新浪博客</a>）：</p>\n<blockquote>\n<p><strong>1.颗粒度越大越好</strong>：单词的字数越多，所能表示的含义越确切。如：“公安局长”可以分为“公安 局长”、“公安局长”、“公安局长”都算对，但是要用于语义分析，则“公安局长”的分词结果最好（当然前提是所使用的词典中有这个词）<br><strong>2.非字典词和单字字典词越少越好</strong><br><strong>3.总体词数越少越好</strong></p>\n</blockquote>\n<p>我实现了逆向匹配算法，代码比较简单，需要的话请留言。</p>\n<h2 id=\"隐马尔可夫模型\"><a href=\"#隐马尔可夫模型\" class=\"headerlink\" title=\"隐马尔可夫模型\"></a>隐马尔可夫模型</h2><center>![HMM][4]</center>\n\n<p>隐马尔科夫模型（HMM）是一种统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。<br>它是一个五元组：状态值集合，观察值集合，转移概率矩阵，发射概率矩阵和初始状态分布。<br>在中文分词问题中，<br><strong>状态值集合</strong>：为（B,M,E,S），分别表示词首、词中、词尾和单独成词。<br><strong>观察值集合</strong>：待处理文本。<br><strong>初始状态分布</strong>：语料库中每个句子第一个字所处状态的概率。<br><strong>转移概率矩阵</strong>：某个字所处的某状态转移到下一个字对应的状态的概率。<br><strong>发射概率矩阵</strong>：表示语料库中所有字对应某个状态的概率。<br>同时，使用<strong>Viterbi算法</strong>求解<strong>最优路径</strong>，即得到分词结果。<br>Viterbi算法是一种<strong>动态规划</strong>算法，它的主要思路是：</p>\n<ol>\n<li>根据待处理文本s的第一个字，初始化<strong>weight[4][N]<strong>（N为s的长度，weight[4][N]表示4行N列的数组）。具体而言，weight[m][n]的含义是</strong>第n个字对应状态m的概率</strong>。</li>\n<li>同时，为求解最优路径，我们再设置一个**path[4][n]**（N为s的长度，path[4][N]表示4行N列的数组）。具体而言，path[m][n]的含义是当前字的weight[m][n]取最大时，它的前一个字的状态。path数组为我们后续分词提供便捷。</li>\n</ol>\n<p>由第一个字的概率向后计算得到每一个字对应状态下的概率即weight[m][k]。<br>计算过程代码如下（参考<a href=\"https://www.jianshu.com/p/0eee07a5bf38\">HMM用于中文分词-简书</a>）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//i表示句子的第i个字</span><br><span class=\"line\">for(int j=0;j&lt;4;j++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(int k=0;k&lt;4;k++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //找到第i个字为状态j时，第i-1个字转移到第i个字概率最大的</span><br><span class=\"line\">        //即i-1取不同状态k时，求得最大的temp，作为weight[j][i]</span><br><span class=\"line\">        //并记录i-1的状态k作为path[j][i]</span><br><span class=\"line\">        temp=weight[k][i-1]+TransProb[k][j]+EmitProb[j][sentence[i]];       //weight的计算公式</span><br><span class=\"line\">        if(temp&gt;weight[j][i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            weight[j][i]=temp;</span><br><span class=\"line\">            path[j][i]=k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Points</strong></p>\n<ol>\n<li>需要词典和语料进行训练，是有监督的学习</li>\n<li>对于词典中没有的词，在对文本进行分词时的计算要注意。</li>\n</ol>\n<h3 id=\"隐马尔可夫模型的其他应用\"><a href=\"#隐马尔可夫模型的其他应用\" class=\"headerlink\" title=\"隐马尔可夫模型的其他应用\"></a>隐马尔可夫模型的其他应用</h3><p>语音识别等</p>\n<h3 id=\"一些补充\"><a href=\"#一些补充\" class=\"headerlink\" title=\"一些补充\"></a>一些补充</h3><p>读了吴军的《数学之美》，书中的第五章就是讲的隐马尔科夫模型。Vertibi算法是一个解码的功能，在分词中也就是求得weight矩阵并逆向分析得到分词结果（即Path）。<br>他在书里的补充部分还提到了鲍姆-韦尔奇算法，用来计算模型参数，在我们这个分词应用中还没有用上，这个我也没有太弄懂。</p>\n<h2 id=\"最大匹配算法与隐马尔可夫模型比较\"><a href=\"#最大匹配算法与隐马尔可夫模型比较\" class=\"headerlink\" title=\"最大匹配算法与隐马尔可夫模型比较\"></a>最大匹配算法与隐马尔可夫模型比较</h2><p>前者优点在于易于实现，而对于一些未登录词的识别效果不佳。<br>后者优点在于能较好地识别未登录词，但是计算量大。<br>两个正好相反~<br>下面是个演示，可以看出对一些<del>奇怪的</del>词语，隐马尔科夫模型分词效果会比较好。</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/fen-ci.jpg\" alt=\"CompareImg\"></p>\n<h2 id=\"One-More-Thing\"><a href=\"#One-More-Thing\" class=\"headerlink\" title=\"One More Thing\"></a>One More Thing</h2><ol>\n<li>Python中文读的问题。字典是通过老师给的新闻语料创建的。涉及一个读入问题和一个除杂问题。我觉得中文处理还挺麻烦的。<br>一个是文件转为无BOM的utf-8，一个是中文字符范围，一个是正则表达式。<br>（1）转为无BOM的UTF-8用NotePad就可以。<br>（2）网上就能查到<br>（3）利用正则和中文字符范围可以除杂</li>\n</ol>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>时隔不知道几个月，再把这篇草稿翻出来。很多知识忘了，又重新学了一遍，算法还是得常看呐。旧文凑更啦~ o(*￣▽￣*)ブ<br>深度学习，神经网络这一类的东西都给我一种不靠谱的感觉。再比如说，模型比较起来结果很明显的隐马尔可夫模型会好一些，但是为什么呢？<br>我也怀疑是因为我自己没有动手搭建过的原因，给我一种很玄幻的感觉。</p>\n<p><font color = #f4606c>Anyway,那么下一个目标是自己动手搭建神经网络。</font></p>\n<img src=\"http://www.webpagefx.com/tools/emoji-cheat-sheet/graphics/emojis/kissing.png\" height=\"30\" width=\"30\" align=\"left\">"},{"title":"研究生生活的第一周","date":"2020-09-27T15:54:49.000Z","_content":"\n希望能把这一专栏坚持到毕业，不指望写很多，但也算一个记录吧~\n\n<!--more-->\n\n## 报道与新同学\n\n18号从杭州来到北京。来之前非常焦虑：我能过好研究生三年吗？我能跟上研究生的难度吗？我能像周围同学做得一样好或者更好吗？我能承受得住研究生的压力吗？还有，我的深度学习作业该怎么办？\n来了之后，情况得到了好转。和新同学交流，与男朋友见面，投入深度学习实验中，导师也没有布置任务。我慢慢地安稳下来了。现在感觉自己心态调整过来了，可以慢慢加油努力起来了~\n\n## 一周课程\n\n这一周可以说，上课都很不在状态，总是飘来飘去的，脑袋里想些乱七八糟的事情。没课的时候就待在寝室或者去教室，复习数学课（结果到了周四退课了！爽！）\n嗯，还是有些没目标，抓不清主次。\n\n## 还没拥有被讨厌的勇气\n\n这段时间看了《被讨厌的勇气》这本书，书中有很多内容对我来说很受用。先在这里做一些笔记，以时常提醒自己：认清自己做某件事情的真实原因——为了逃避而偷懒？为了缓解焦虑而打游戏？因为害怕自己被否定就不去尝试？下面是一些摘抄。\n\n> 简单地说就是害怕向前迈进或者是不想真正地努力。不愿为了改变自我而牺牲目前所享受的乐趣——比如玩乐或休闲时间。也就是拿不出改变生活方式的“勇气”，即使有些不满或者不自由，也还是更愿意维持现状。\n\n> 如果过去决定一切而过去又无法改变的话，那么活在今天的我们对人生也将会束手无策。结果会如何呢？那就可能会陷入对世界绝望、对人生厌弃的虚无主义或悲观主义之中。\n\n书中有一句话：“他们什么都不做就断定自己不行或是现实无法改变。”我觉得就是让我对号入座了。在开始做一件事情之前，就先把自己否认了。再找到各种原因，为自己推脱。希望接下来两周能把这本书看完。\n\n## 导师与我的工位与师姐\n\n周四见到了导师，导师和我们聊了聊，也给我们安排了工位。\n我告诉导师，我觉得现在很没有方向，不知道自己应该做什么。导师告诉我不要着急，刚开始都是这样的，很多人第一学期都没有什么工作做出来。\n周五第一次到实验室，坐到我的工位上，有种很快乐的感觉！是我的小天地！虽然没有做什么，但是和师姐聊了会天。暂且称她丹丹师姐吧~师姐她人很好，告诉我现在可以干什么，实验室的一些规矩又是怎么样的。丹丹师姐跟我说可以去王晋东的主页上找一些代码跑跑，看看论文。也叫我不用太拘束在师姐的论文上，她们的工作可能也不是那么好。另外，提醒我要赶在老师前面做事，因为老师手下的学生太多了。\n还想提提另一个师姐，和我一个本科学校的。真的超可爱！人又很好！暂且叫她小王师姐吧~\n\n## 快乐周末\n\n周五见到了男友，周六玩了一整天，真的很开心。\n去南锣鼓巷拍了很多好看的照片~日行三万步(●ˇ∀ˇ●)\n周日就在寝室度过啦，疯狂游戏！但是连跪...\n\n## 最后的碎碎念\n\n突然就变成流水账了！\n总的来说，这一周没有进入状态，刚开学又加上放了八个月的假，也是能理解。下一周开始，加油吧！（诶等等，这周我周一周二上完课就没事了( •̀ ω •́ )y\n咳，下周想要做的事！\n\n- [ ] 读完2篇论文，精读一篇，泛读一篇。\n- [x] 去找mk玩。\n- [ ] 看《统计学习基础》，编写至少一个代码。\n- [x] 刷leetcode，至少2题。\n- [x] 看《被讨厌的勇气》。\n- [ ] 去一次舞室。\n\n\n\n研究生生活就这样突然开始啦！还没有适应，还没有方向，慢慢来，但一定要去做~❤","source":"_posts/研究生生活的第一周.md","raw":"---\ntitle: 研究生生活的第一周\ndate: 2020-09-27 23:54:49\ncategories: ResearchLife\n---\n\n希望能把这一专栏坚持到毕业，不指望写很多，但也算一个记录吧~\n\n<!--more-->\n\n## 报道与新同学\n\n18号从杭州来到北京。来之前非常焦虑：我能过好研究生三年吗？我能跟上研究生的难度吗？我能像周围同学做得一样好或者更好吗？我能承受得住研究生的压力吗？还有，我的深度学习作业该怎么办？\n来了之后，情况得到了好转。和新同学交流，与男朋友见面，投入深度学习实验中，导师也没有布置任务。我慢慢地安稳下来了。现在感觉自己心态调整过来了，可以慢慢加油努力起来了~\n\n## 一周课程\n\n这一周可以说，上课都很不在状态，总是飘来飘去的，脑袋里想些乱七八糟的事情。没课的时候就待在寝室或者去教室，复习数学课（结果到了周四退课了！爽！）\n嗯，还是有些没目标，抓不清主次。\n\n## 还没拥有被讨厌的勇气\n\n这段时间看了《被讨厌的勇气》这本书，书中有很多内容对我来说很受用。先在这里做一些笔记，以时常提醒自己：认清自己做某件事情的真实原因——为了逃避而偷懒？为了缓解焦虑而打游戏？因为害怕自己被否定就不去尝试？下面是一些摘抄。\n\n> 简单地说就是害怕向前迈进或者是不想真正地努力。不愿为了改变自我而牺牲目前所享受的乐趣——比如玩乐或休闲时间。也就是拿不出改变生活方式的“勇气”，即使有些不满或者不自由，也还是更愿意维持现状。\n\n> 如果过去决定一切而过去又无法改变的话，那么活在今天的我们对人生也将会束手无策。结果会如何呢？那就可能会陷入对世界绝望、对人生厌弃的虚无主义或悲观主义之中。\n\n书中有一句话：“他们什么都不做就断定自己不行或是现实无法改变。”我觉得就是让我对号入座了。在开始做一件事情之前，就先把自己否认了。再找到各种原因，为自己推脱。希望接下来两周能把这本书看完。\n\n## 导师与我的工位与师姐\n\n周四见到了导师，导师和我们聊了聊，也给我们安排了工位。\n我告诉导师，我觉得现在很没有方向，不知道自己应该做什么。导师告诉我不要着急，刚开始都是这样的，很多人第一学期都没有什么工作做出来。\n周五第一次到实验室，坐到我的工位上，有种很快乐的感觉！是我的小天地！虽然没有做什么，但是和师姐聊了会天。暂且称她丹丹师姐吧~师姐她人很好，告诉我现在可以干什么，实验室的一些规矩又是怎么样的。丹丹师姐跟我说可以去王晋东的主页上找一些代码跑跑，看看论文。也叫我不用太拘束在师姐的论文上，她们的工作可能也不是那么好。另外，提醒我要赶在老师前面做事，因为老师手下的学生太多了。\n还想提提另一个师姐，和我一个本科学校的。真的超可爱！人又很好！暂且叫她小王师姐吧~\n\n## 快乐周末\n\n周五见到了男友，周六玩了一整天，真的很开心。\n去南锣鼓巷拍了很多好看的照片~日行三万步(●ˇ∀ˇ●)\n周日就在寝室度过啦，疯狂游戏！但是连跪...\n\n## 最后的碎碎念\n\n突然就变成流水账了！\n总的来说，这一周没有进入状态，刚开学又加上放了八个月的假，也是能理解。下一周开始，加油吧！（诶等等，这周我周一周二上完课就没事了( •̀ ω •́ )y\n咳，下周想要做的事！\n\n- [ ] 读完2篇论文，精读一篇，泛读一篇。\n- [x] 去找mk玩。\n- [ ] 看《统计学习基础》，编写至少一个代码。\n- [x] 刷leetcode，至少2题。\n- [x] 看《被讨厌的勇气》。\n- [ ] 去一次舞室。\n\n\n\n研究生生活就这样突然开始啦！还没有适应，还没有方向，慢慢来，但一定要去做~❤","slug":"研究生生活的第一周","published":1,"updated":"2020-09-27T15:54:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaghb002x38t46tos9s1z","content":"<p>希望能把这一专栏坚持到毕业，不指望写很多，但也算一个记录吧~</p>\n<span id=\"more\"></span>\n\n<h2 id=\"报道与新同学\"><a href=\"#报道与新同学\" class=\"headerlink\" title=\"报道与新同学\"></a>报道与新同学</h2><p>18号从杭州来到北京。来之前非常焦虑：我能过好研究生三年吗？我能跟上研究生的难度吗？我能像周围同学做得一样好或者更好吗？我能承受得住研究生的压力吗？还有，我的深度学习作业该怎么办？<br>来了之后，情况得到了好转。和新同学交流，与男朋友见面，投入深度学习实验中，导师也没有布置任务。我慢慢地安稳下来了。现在感觉自己心态调整过来了，可以慢慢加油努力起来了~</p>\n<h2 id=\"一周课程\"><a href=\"#一周课程\" class=\"headerlink\" title=\"一周课程\"></a>一周课程</h2><p>这一周可以说，上课都很不在状态，总是飘来飘去的，脑袋里想些乱七八糟的事情。没课的时候就待在寝室或者去教室，复习数学课（结果到了周四退课了！爽！）<br>嗯，还是有些没目标，抓不清主次。</p>\n<h2 id=\"还没拥有被讨厌的勇气\"><a href=\"#还没拥有被讨厌的勇气\" class=\"headerlink\" title=\"还没拥有被讨厌的勇气\"></a>还没拥有被讨厌的勇气</h2><p>这段时间看了《被讨厌的勇气》这本书，书中有很多内容对我来说很受用。先在这里做一些笔记，以时常提醒自己：认清自己做某件事情的真实原因——为了逃避而偷懒？为了缓解焦虑而打游戏？因为害怕自己被否定就不去尝试？下面是一些摘抄。</p>\n<blockquote>\n<p>简单地说就是害怕向前迈进或者是不想真正地努力。不愿为了改变自我而牺牲目前所享受的乐趣——比如玩乐或休闲时间。也就是拿不出改变生活方式的“勇气”，即使有些不满或者不自由，也还是更愿意维持现状。</p>\n</blockquote>\n<blockquote>\n<p>如果过去决定一切而过去又无法改变的话，那么活在今天的我们对人生也将会束手无策。结果会如何呢？那就可能会陷入对世界绝望、对人生厌弃的虚无主义或悲观主义之中。</p>\n</blockquote>\n<p>书中有一句话：“他们什么都不做就断定自己不行或是现实无法改变。”我觉得就是让我对号入座了。在开始做一件事情之前，就先把自己否认了。再找到各种原因，为自己推脱。希望接下来两周能把这本书看完。</p>\n<h2 id=\"导师与我的工位与师姐\"><a href=\"#导师与我的工位与师姐\" class=\"headerlink\" title=\"导师与我的工位与师姐\"></a>导师与我的工位与师姐</h2><p>周四见到了导师，导师和我们聊了聊，也给我们安排了工位。<br>我告诉导师，我觉得现在很没有方向，不知道自己应该做什么。导师告诉我不要着急，刚开始都是这样的，很多人第一学期都没有什么工作做出来。<br>周五第一次到实验室，坐到我的工位上，有种很快乐的感觉！是我的小天地！虽然没有做什么，但是和师姐聊了会天。暂且称她丹丹师姐吧<del>师姐她人很好，告诉我现在可以干什么，实验室的一些规矩又是怎么样的。丹丹师姐跟我说可以去王晋东的主页上找一些代码跑跑，看看论文。也叫我不用太拘束在师姐的论文上，她们的工作可能也不是那么好。另外，提醒我要赶在老师前面做事，因为老师手下的学生太多了。<br>还想提提另一个师姐，和我一个本科学校的。真的超可爱！人又很好！暂且叫她小王师姐吧</del></p>\n<h2 id=\"快乐周末\"><a href=\"#快乐周末\" class=\"headerlink\" title=\"快乐周末\"></a>快乐周末</h2><p>周五见到了男友，周六玩了一整天，真的很开心。<br>去南锣鼓巷拍了很多好看的照片~日行三万步(●ˇ∀ˇ●)<br>周日就在寝室度过啦，疯狂游戏！但是连跪…</p>\n<h2 id=\"最后的碎碎念\"><a href=\"#最后的碎碎念\" class=\"headerlink\" title=\"最后的碎碎念\"></a>最后的碎碎念</h2><p>突然就变成流水账了！<br>总的来说，这一周没有进入状态，刚开学又加上放了八个月的假，也是能理解。下一周开始，加油吧！（诶等等，这周我周一周二上完课就没事了( •̀ ω •́ )y<br>咳，下周想要做的事！</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 读完2篇论文，精读一篇，泛读一篇。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 去找mk玩。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 看《统计学习基础》，编写至少一个代码。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 刷leetcode，至少2题。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 看《被讨厌的勇气》。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 去一次舞室。</li>\n</ul>\n<p>研究生生活就这样突然开始啦！还没有适应，还没有方向，慢慢来，但一定要去做~❤</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>希望能把这一专栏坚持到毕业，不指望写很多，但也算一个记录吧~</p>","more":"<h2 id=\"报道与新同学\"><a href=\"#报道与新同学\" class=\"headerlink\" title=\"报道与新同学\"></a>报道与新同学</h2><p>18号从杭州来到北京。来之前非常焦虑：我能过好研究生三年吗？我能跟上研究生的难度吗？我能像周围同学做得一样好或者更好吗？我能承受得住研究生的压力吗？还有，我的深度学习作业该怎么办？<br>来了之后，情况得到了好转。和新同学交流，与男朋友见面，投入深度学习实验中，导师也没有布置任务。我慢慢地安稳下来了。现在感觉自己心态调整过来了，可以慢慢加油努力起来了~</p>\n<h2 id=\"一周课程\"><a href=\"#一周课程\" class=\"headerlink\" title=\"一周课程\"></a>一周课程</h2><p>这一周可以说，上课都很不在状态，总是飘来飘去的，脑袋里想些乱七八糟的事情。没课的时候就待在寝室或者去教室，复习数学课（结果到了周四退课了！爽！）<br>嗯，还是有些没目标，抓不清主次。</p>\n<h2 id=\"还没拥有被讨厌的勇气\"><a href=\"#还没拥有被讨厌的勇气\" class=\"headerlink\" title=\"还没拥有被讨厌的勇气\"></a>还没拥有被讨厌的勇气</h2><p>这段时间看了《被讨厌的勇气》这本书，书中有很多内容对我来说很受用。先在这里做一些笔记，以时常提醒自己：认清自己做某件事情的真实原因——为了逃避而偷懒？为了缓解焦虑而打游戏？因为害怕自己被否定就不去尝试？下面是一些摘抄。</p>\n<blockquote>\n<p>简单地说就是害怕向前迈进或者是不想真正地努力。不愿为了改变自我而牺牲目前所享受的乐趣——比如玩乐或休闲时间。也就是拿不出改变生活方式的“勇气”，即使有些不满或者不自由，也还是更愿意维持现状。</p>\n</blockquote>\n<blockquote>\n<p>如果过去决定一切而过去又无法改变的话，那么活在今天的我们对人生也将会束手无策。结果会如何呢？那就可能会陷入对世界绝望、对人生厌弃的虚无主义或悲观主义之中。</p>\n</blockquote>\n<p>书中有一句话：“他们什么都不做就断定自己不行或是现实无法改变。”我觉得就是让我对号入座了。在开始做一件事情之前，就先把自己否认了。再找到各种原因，为自己推脱。希望接下来两周能把这本书看完。</p>\n<h2 id=\"导师与我的工位与师姐\"><a href=\"#导师与我的工位与师姐\" class=\"headerlink\" title=\"导师与我的工位与师姐\"></a>导师与我的工位与师姐</h2><p>周四见到了导师，导师和我们聊了聊，也给我们安排了工位。<br>我告诉导师，我觉得现在很没有方向，不知道自己应该做什么。导师告诉我不要着急，刚开始都是这样的，很多人第一学期都没有什么工作做出来。<br>周五第一次到实验室，坐到我的工位上，有种很快乐的感觉！是我的小天地！虽然没有做什么，但是和师姐聊了会天。暂且称她丹丹师姐吧<del>师姐她人很好，告诉我现在可以干什么，实验室的一些规矩又是怎么样的。丹丹师姐跟我说可以去王晋东的主页上找一些代码跑跑，看看论文。也叫我不用太拘束在师姐的论文上，她们的工作可能也不是那么好。另外，提醒我要赶在老师前面做事，因为老师手下的学生太多了。<br>还想提提另一个师姐，和我一个本科学校的。真的超可爱！人又很好！暂且叫她小王师姐吧</del></p>\n<h2 id=\"快乐周末\"><a href=\"#快乐周末\" class=\"headerlink\" title=\"快乐周末\"></a>快乐周末</h2><p>周五见到了男友，周六玩了一整天，真的很开心。<br>去南锣鼓巷拍了很多好看的照片~日行三万步(●ˇ∀ˇ●)<br>周日就在寝室度过啦，疯狂游戏！但是连跪…</p>\n<h2 id=\"最后的碎碎念\"><a href=\"#最后的碎碎念\" class=\"headerlink\" title=\"最后的碎碎念\"></a>最后的碎碎念</h2><p>突然就变成流水账了！<br>总的来说，这一周没有进入状态，刚开学又加上放了八个月的假，也是能理解。下一周开始，加油吧！（诶等等，这周我周一周二上完课就没事了( •̀ ω •́ )y<br>咳，下周想要做的事！</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 读完2篇论文，精读一篇，泛读一篇。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 去找mk玩。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 看《统计学习基础》，编写至少一个代码。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 刷leetcode，至少2题。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 看《被讨厌的勇气》。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 去一次舞室。</li>\n</ul>\n<p>研究生生活就这样突然开始啦！还没有适应，还没有方向，慢慢来，但一定要去做~❤</p>"},{"title":"研究生生活的第二周","date":"2020-10-04T16:29:01.000Z","_content":"\n第二周，学习，玩耍~\n\n<!--more-->\n\n## leetcode刷题\n\n**Something New!**\n\nzip()函数\n参数为几个可迭代对象，zip函数将每个对象中的对应元素打包成元组，然后合并成一个列表并返回。\n当参数包括*操作符时，可以将元组或其他可迭代对象解压为多个列表。\n举个例子（From [菜鸟教程][1]）\n```python\n>>>a = [1,2,3]\n>>> b = [4,5,6]\n>>> c = [4,5,6,7,8]\n>>> zipped = zip(a,b)     # 打包为元组的列表\n[(1, 4), (2, 5), (3, 6)]\n>>> zip(a,c)              # 元素个数与最短的列表一致\n[(1, 4), (2, 5), (3, 6)]\n>>> zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式\n[(1, 2, 3), (4, 5, 6)]\n```\n\ncount()函数\nlen()和count()是python的内置函数。可以直接对列表、元组等对象使用，如：\n\n```python\n>>> l = [1,2,3,3]\n>>> len(l)\n4\n>>> l.count(3)\n2\n```\n\nCounter对象\n使用前要import，创建Counter对象时，传入的参数是一个可迭代对象，或者用字典的形式来初始化。\n\n```python\nfrom collections import Counter\n```\n\n只做了两道简单的数组题。一个是数组转置，一个是求主要元素。\n第一道题比较巧妙的方法。利用python的zip函数，将行向量和列向量互换。（我自己就简单地二重循环）\n第二道题不错的参考思路。先进行排序，只要那当前数和索引加了一半长度之后的数比较，是不是主要元素就行。或者，先去重得到每一个元素，然后用count()函数，计算每一个元素对应出现的次数。（我自己是用了Counter，速度不错，但是占用的内存空间比较大了。）\n\n## 上课\n\n这周虽然只有两天课，但是有状态很多。的确是需要点时间来适应。不足之处在于，上课是好好听了，可是不会复盘！\n复盘是件很痛苦的事情，但是不做的话，我上课学到的东西很快就要忘记...得安排上！\n\n## 出去玩\n\n打扮了两个小时，又乘了一个半小时地铁，见面，很开心。\n不知道该怎么和别人讲述我们之间的故事，所有语言都失去了力量。\n\n## 碎碎念\n\n想看论文，但是没看多少！\n想去舞室，但是给自己找“我还没有好看衣服”的借口！\n这周出去玩，分了很多心思出去，下周多多学习呀~还是得集中起注意力来才行。\n\n## ToDoList\n\n- [ ] 论文：精读一篇，泛读一篇\n- [ ] leetcode刷题：至少4道\n- [ ] 看《统计学习方法》，完成一个模型代码\n- [ ] 运动：至少两天\n- [ ] 一周课程复习（机器学习、复杂网络基础、矩阵分析、最优化、机器视觉、算法）\n\n  [1]: https://www.runoob.com/python/python-func-zip.html\n","source":"_posts/研究生生活的第二周.md","raw":"---\ntitle: 研究生生活的第二周\ndate: 2020-10-05 00:29:01\ncategories: ResearchLife\ntags:\n---\n\n第二周，学习，玩耍~\n\n<!--more-->\n\n## leetcode刷题\n\n**Something New!**\n\nzip()函数\n参数为几个可迭代对象，zip函数将每个对象中的对应元素打包成元组，然后合并成一个列表并返回。\n当参数包括*操作符时，可以将元组或其他可迭代对象解压为多个列表。\n举个例子（From [菜鸟教程][1]）\n```python\n>>>a = [1,2,3]\n>>> b = [4,5,6]\n>>> c = [4,5,6,7,8]\n>>> zipped = zip(a,b)     # 打包为元组的列表\n[(1, 4), (2, 5), (3, 6)]\n>>> zip(a,c)              # 元素个数与最短的列表一致\n[(1, 4), (2, 5), (3, 6)]\n>>> zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式\n[(1, 2, 3), (4, 5, 6)]\n```\n\ncount()函数\nlen()和count()是python的内置函数。可以直接对列表、元组等对象使用，如：\n\n```python\n>>> l = [1,2,3,3]\n>>> len(l)\n4\n>>> l.count(3)\n2\n```\n\nCounter对象\n使用前要import，创建Counter对象时，传入的参数是一个可迭代对象，或者用字典的形式来初始化。\n\n```python\nfrom collections import Counter\n```\n\n只做了两道简单的数组题。一个是数组转置，一个是求主要元素。\n第一道题比较巧妙的方法。利用python的zip函数，将行向量和列向量互换。（我自己就简单地二重循环）\n第二道题不错的参考思路。先进行排序，只要那当前数和索引加了一半长度之后的数比较，是不是主要元素就行。或者，先去重得到每一个元素，然后用count()函数，计算每一个元素对应出现的次数。（我自己是用了Counter，速度不错，但是占用的内存空间比较大了。）\n\n## 上课\n\n这周虽然只有两天课，但是有状态很多。的确是需要点时间来适应。不足之处在于，上课是好好听了，可是不会复盘！\n复盘是件很痛苦的事情，但是不做的话，我上课学到的东西很快就要忘记...得安排上！\n\n## 出去玩\n\n打扮了两个小时，又乘了一个半小时地铁，见面，很开心。\n不知道该怎么和别人讲述我们之间的故事，所有语言都失去了力量。\n\n## 碎碎念\n\n想看论文，但是没看多少！\n想去舞室，但是给自己找“我还没有好看衣服”的借口！\n这周出去玩，分了很多心思出去，下周多多学习呀~还是得集中起注意力来才行。\n\n## ToDoList\n\n- [ ] 论文：精读一篇，泛读一篇\n- [ ] leetcode刷题：至少4道\n- [ ] 看《统计学习方法》，完成一个模型代码\n- [ ] 运动：至少两天\n- [ ] 一周课程复习（机器学习、复杂网络基础、矩阵分析、最优化、机器视觉、算法）\n\n  [1]: https://www.runoob.com/python/python-func-zip.html\n","slug":"研究生生活的第二周","published":1,"updated":"2020-10-04T16:29:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaghc003038t4c0dr6z0o","content":"<p>第二周，学习，玩耍~</p>\n<span id=\"more\"></span>\n\n<h2 id=\"leetcode刷题\"><a href=\"#leetcode刷题\" class=\"headerlink\" title=\"leetcode刷题\"></a>leetcode刷题</h2><p><strong>Something New!</strong></p>\n<p>zip()函数<br>参数为几个可迭代对象，zip函数将每个对象中的对应元素打包成元组，然后合并成一个列表并返回。<br>当参数包括*操作符时，可以将元组或其他可迭代对象解压为多个列表。<br>举个例子（From <a href=\"https://www.runoob.com/python/python-func-zip.html\">菜鸟教程</a>）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>zipped = <span class=\"built_in\">zip</span>(a,b)     <span class=\"comment\"># 打包为元组的列表</span></span><br><span class=\"line\">[(<span class=\"number\">1</span>, <span class=\"number\">4</span>), (<span class=\"number\">2</span>, <span class=\"number\">5</span>), (<span class=\"number\">3</span>, <span class=\"number\">6</span>)]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">zip</span>(a,c)              <span class=\"comment\"># 元素个数与最短的列表一致</span></span><br><span class=\"line\">[(<span class=\"number\">1</span>, <span class=\"number\">4</span>), (<span class=\"number\">2</span>, <span class=\"number\">5</span>), (<span class=\"number\">3</span>, <span class=\"number\">6</span>)]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">zip</span>(*zipped)          <span class=\"comment\"># 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span></span><br><span class=\"line\">[(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>), (<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)]</span><br></pre></td></tr></table></figure>\n\n<p>count()函数<br>len()和count()是python的内置函数。可以直接对列表、元组等对象使用，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>l = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">len</span>(l)</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>l.count(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>Counter对象<br>使用前要import，创建Counter对象时，传入的参数是一个可迭代对象，或者用字典的形式来初始化。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br></pre></td></tr></table></figure>\n\n<p>只做了两道简单的数组题。一个是数组转置，一个是求主要元素。<br>第一道题比较巧妙的方法。利用python的zip函数，将行向量和列向量互换。（我自己就简单地二重循环）<br>第二道题不错的参考思路。先进行排序，只要那当前数和索引加了一半长度之后的数比较，是不是主要元素就行。或者，先去重得到每一个元素，然后用count()函数，计算每一个元素对应出现的次数。（我自己是用了Counter，速度不错，但是占用的内存空间比较大了。）</p>\n<h2 id=\"上课\"><a href=\"#上课\" class=\"headerlink\" title=\"上课\"></a>上课</h2><p>这周虽然只有两天课，但是有状态很多。的确是需要点时间来适应。不足之处在于，上课是好好听了，可是不会复盘！<br>复盘是件很痛苦的事情，但是不做的话，我上课学到的东西很快就要忘记…得安排上！</p>\n<h2 id=\"出去玩\"><a href=\"#出去玩\" class=\"headerlink\" title=\"出去玩\"></a>出去玩</h2><p>打扮了两个小时，又乘了一个半小时地铁，见面，很开心。<br>不知道该怎么和别人讲述我们之间的故事，所有语言都失去了力量。</p>\n<h2 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h2><p>想看论文，但是没看多少！<br>想去舞室，但是给自己找“我还没有好看衣服”的借口！<br>这周出去玩，分了很多心思出去，下周多多学习呀~还是得集中起注意力来才行。</p>\n<h2 id=\"ToDoList\"><a href=\"#ToDoList\" class=\"headerlink\" title=\"ToDoList\"></a>ToDoList</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 论文：精读一篇，泛读一篇</li>\n<li><input disabled=\"\" type=\"checkbox\"> leetcode刷题：至少4道</li>\n<li><input disabled=\"\" type=\"checkbox\"> 看《统计学习方法》，完成一个模型代码</li>\n<li><input disabled=\"\" type=\"checkbox\"> 运动：至少两天</li>\n<li><input disabled=\"\" type=\"checkbox\"> 一周课程复习（机器学习、复杂网络基础、矩阵分析、最优化、机器视觉、算法）</li>\n</ul>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>第二周，学习，玩耍~</p>","more":"<h2 id=\"leetcode刷题\"><a href=\"#leetcode刷题\" class=\"headerlink\" title=\"leetcode刷题\"></a>leetcode刷题</h2><p><strong>Something New!</strong></p>\n<p>zip()函数<br>参数为几个可迭代对象，zip函数将每个对象中的对应元素打包成元组，然后合并成一个列表并返回。<br>当参数包括*操作符时，可以将元组或其他可迭代对象解压为多个列表。<br>举个例子（From <a href=\"https://www.runoob.com/python/python-func-zip.html\">菜鸟教程</a>）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>zipped = <span class=\"built_in\">zip</span>(a,b)     <span class=\"comment\"># 打包为元组的列表</span></span><br><span class=\"line\">[(<span class=\"number\">1</span>, <span class=\"number\">4</span>), (<span class=\"number\">2</span>, <span class=\"number\">5</span>), (<span class=\"number\">3</span>, <span class=\"number\">6</span>)]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">zip</span>(a,c)              <span class=\"comment\"># 元素个数与最短的列表一致</span></span><br><span class=\"line\">[(<span class=\"number\">1</span>, <span class=\"number\">4</span>), (<span class=\"number\">2</span>, <span class=\"number\">5</span>), (<span class=\"number\">3</span>, <span class=\"number\">6</span>)]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">zip</span>(*zipped)          <span class=\"comment\"># 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span></span><br><span class=\"line\">[(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>), (<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)]</span><br></pre></td></tr></table></figure>\n\n<p>count()函数<br>len()和count()是python的内置函数。可以直接对列表、元组等对象使用，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>l = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">len</span>(l)</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>l.count(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>Counter对象<br>使用前要import，创建Counter对象时，传入的参数是一个可迭代对象，或者用字典的形式来初始化。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br></pre></td></tr></table></figure>\n\n<p>只做了两道简单的数组题。一个是数组转置，一个是求主要元素。<br>第一道题比较巧妙的方法。利用python的zip函数，将行向量和列向量互换。（我自己就简单地二重循环）<br>第二道题不错的参考思路。先进行排序，只要那当前数和索引加了一半长度之后的数比较，是不是主要元素就行。或者，先去重得到每一个元素，然后用count()函数，计算每一个元素对应出现的次数。（我自己是用了Counter，速度不错，但是占用的内存空间比较大了。）</p>\n<h2 id=\"上课\"><a href=\"#上课\" class=\"headerlink\" title=\"上课\"></a>上课</h2><p>这周虽然只有两天课，但是有状态很多。的确是需要点时间来适应。不足之处在于，上课是好好听了，可是不会复盘！<br>复盘是件很痛苦的事情，但是不做的话，我上课学到的东西很快就要忘记…得安排上！</p>\n<h2 id=\"出去玩\"><a href=\"#出去玩\" class=\"headerlink\" title=\"出去玩\"></a>出去玩</h2><p>打扮了两个小时，又乘了一个半小时地铁，见面，很开心。<br>不知道该怎么和别人讲述我们之间的故事，所有语言都失去了力量。</p>\n<h2 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h2><p>想看论文，但是没看多少！<br>想去舞室，但是给自己找“我还没有好看衣服”的借口！<br>这周出去玩，分了很多心思出去，下周多多学习呀~还是得集中起注意力来才行。</p>\n<h2 id=\"ToDoList\"><a href=\"#ToDoList\" class=\"headerlink\" title=\"ToDoList\"></a>ToDoList</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 论文：精读一篇，泛读一篇</li>\n<li><input disabled=\"\" type=\"checkbox\"> leetcode刷题：至少4道</li>\n<li><input disabled=\"\" type=\"checkbox\"> 看《统计学习方法》，完成一个模型代码</li>\n<li><input disabled=\"\" type=\"checkbox\"> 运动：至少两天</li>\n<li><input disabled=\"\" type=\"checkbox\"> 一周课程复习（机器学习、复杂网络基础、矩阵分析、最优化、机器视觉、算法）</li>\n</ul>"},{"title":"Hello World!     --第一篇文章","date":"2018-04-15T09:07:00.000Z","_content":"第一篇博文 :-D 来唠唠嗑~\n <!-- more -->\n ---\n我，大二计科专业学生一名，爱好多，技术渣。\n**要学的东西还很多**，希望自己能一步一个脚印地走好。\n想要把这个博客来**记录生活**。不想被越来越多的琐事捆绑，不想机械地生活。\n还想通过这个博客可以**多写作多输出**。只有输入没有输出的努力，多半是徒劳。\n\n### __加油吧，愿看到这篇文章的人能一起进步！__\n\n---------------\n\n个人博客搭建这件事，也是一拖再拖。真的开始做的时候，简单的一件事我也花了一整天，遇到了各种各样的问题，最后完成的时候也是真的开心。\n\n一些碎碎念：\n> 0. 刚刚开始写博客，总觉得写的文字很无聊...        \n> 1. Markdown真好玩！\n> 2. 无头苍蝇本蝇","source":"_posts/第一篇文章.md","raw":"---\ntitle: Hello World!     --第一篇文章\ndate: 2018-04-15 17:07:00\ncategories: 杂七杂八Unclassified\nphoto: https://forlwq.oss-cn-hangzhou.aliyuncs.com/13.png\n---\n第一篇博文 :-D 来唠唠嗑~\n <!-- more -->\n ---\n我，大二计科专业学生一名，爱好多，技术渣。\n**要学的东西还很多**，希望自己能一步一个脚印地走好。\n想要把这个博客来**记录生活**。不想被越来越多的琐事捆绑，不想机械地生活。\n还想通过这个博客可以**多写作多输出**。只有输入没有输出的努力，多半是徒劳。\n\n### __加油吧，愿看到这篇文章的人能一起进步！__\n\n---------------\n\n个人博客搭建这件事，也是一拖再拖。真的开始做的时候，简单的一件事我也花了一整天，遇到了各种各样的问题，最后完成的时候也是真的开心。\n\n一些碎碎念：\n> 0. 刚刚开始写博客，总觉得写的文字很无聊...        \n> 1. Markdown真好玩！\n> 2. 无头苍蝇本蝇","slug":"第一篇文章","published":1,"updated":"2018-04-15T09:07:00.000Z","photos":["https://forlwq.oss-cn-hangzhou.aliyuncs.com/13.png"],"comments":1,"layout":"post","link":"","_id":"cl1jeaghc003438t4esnj3t60","content":"<p>第一篇博文 :-D 来唠唠嗑~<br> <span id=\"more\"></span></p>\n<hr>\n<p>我，大二计科专业学生一名，爱好多，技术渣。<br><strong>要学的东西还很多</strong>，希望自己能一步一个脚印地走好。<br>想要把这个博客来<strong>记录生活</strong>。不想被越来越多的琐事捆绑，不想机械地生活。<br>还想通过这个博客可以<strong>多写作多输出</strong>。只有输入没有输出的努力，多半是徒劳。</p>\n<h3 id=\"加油吧，愿看到这篇文章的人能一起进步！\"><a href=\"#加油吧，愿看到这篇文章的人能一起进步！\" class=\"headerlink\" title=\"加油吧，愿看到这篇文章的人能一起进步！\"></a><strong>加油吧，愿看到这篇文章的人能一起进步！</strong></h3><hr>\n<p>个人博客搭建这件事，也是一拖再拖。真的开始做的时候，简单的一件事我也花了一整天，遇到了各种各样的问题，最后完成的时候也是真的开心。</p>\n<p>一些碎碎念：</p>\n<blockquote>\n<ol start=\"0\">\n<li>刚刚开始写博客，总觉得写的文字很无聊…        </li>\n<li>Markdown真好玩！</li>\n<li>无头苍蝇本蝇</li>\n</ol>\n</blockquote>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>第一篇博文 :-D 来唠唠嗑~<br>","more":"</p>\n<hr>\n<p>我，大二计科专业学生一名，爱好多，技术渣。<br><strong>要学的东西还很多</strong>，希望自己能一步一个脚印地走好。<br>想要把这个博客来<strong>记录生活</strong>。不想被越来越多的琐事捆绑，不想机械地生活。<br>还想通过这个博客可以<strong>多写作多输出</strong>。只有输入没有输出的努力，多半是徒劳。</p>\n<h3 id=\"加油吧，愿看到这篇文章的人能一起进步！\"><a href=\"#加油吧，愿看到这篇文章的人能一起进步！\" class=\"headerlink\" title=\"加油吧，愿看到这篇文章的人能一起进步！\"></a><strong>加油吧，愿看到这篇文章的人能一起进步！</strong></h3><hr>\n<p>个人博客搭建这件事，也是一拖再拖。真的开始做的时候，简单的一件事我也花了一整天，遇到了各种各样的问题，最后完成的时候也是真的开心。</p>\n<p>一些碎碎念：</p>\n<blockquote>\n<ol start=\"0\">\n<li>刚刚开始写博客，总觉得写的文字很无聊…        </li>\n<li>Markdown真好玩！</li>\n<li>无头苍蝇本蝇</li>\n</ol>\n</blockquote>"},{"title":"组会笔记","date":"2020-07-09T12:26:31.000Z","_content":"\n记录一下我研究生期间的组会。\n\n<!--more-->\n\n## 组会200709\n\n### 开题\n做网络其实要花很多时间的。\n差的结果也要放上去。\n对于课题，可以做小的改进，先跑跑结果看看。\n\n### 论文分享\n**非线性优化**\n优化的目标函数是非线性的。具体方法有：牛顿法、高斯-牛顿法、LM法\n\n**欧拉角**\n用来确定定点转动某一物体的一组角参量，章动角，旋进角，自转角。\n放到实际的飞机飞行（万向节）例子更好理解：章动角->桶滚，旋进角->偏向，自转角->俯仰\n这篇文章讲的很好：[如何通俗地解释欧拉角-知乎][1]\n\n**端到端end-to-end**\n端到端模型：一起扔进去，得到一个结果。\n参考这篇最高赞答案：[什么是 end-to-end 神经网络？][2]\n\n**看论文的时候**\n1. 时不时地问自己：目的是什么？为什么要这样？\n2. 看摘要：这篇论文在做什么？\n3. 看表格：这篇论文用的什么数据？在分类还是干嘛？\n4. 以课题和结果为导向，选择性地看论文：对我的课题有帮助吗？有借鉴性的地方吗？\n\n### 其他\n老师真的好凶...我害怕了。\n\n\n## 其他备忘录\n\n1. 对自己的课题和工作要有规划。就像交论文有各种ddl一样。\n\n\n  [1]: https://www.zhihu.com/question/47736315\n  [2]: https://www.zhihu.com/question/51435499","source":"_posts/组会笔记.md","raw":"---\ntitle: 组会笔记\ndate: 2020-07-09 20:26:31\ncategories: 研究生生活\n---\n\n记录一下我研究生期间的组会。\n\n<!--more-->\n\n## 组会200709\n\n### 开题\n做网络其实要花很多时间的。\n差的结果也要放上去。\n对于课题，可以做小的改进，先跑跑结果看看。\n\n### 论文分享\n**非线性优化**\n优化的目标函数是非线性的。具体方法有：牛顿法、高斯-牛顿法、LM法\n\n**欧拉角**\n用来确定定点转动某一物体的一组角参量，章动角，旋进角，自转角。\n放到实际的飞机飞行（万向节）例子更好理解：章动角->桶滚，旋进角->偏向，自转角->俯仰\n这篇文章讲的很好：[如何通俗地解释欧拉角-知乎][1]\n\n**端到端end-to-end**\n端到端模型：一起扔进去，得到一个结果。\n参考这篇最高赞答案：[什么是 end-to-end 神经网络？][2]\n\n**看论文的时候**\n1. 时不时地问自己：目的是什么？为什么要这样？\n2. 看摘要：这篇论文在做什么？\n3. 看表格：这篇论文用的什么数据？在分类还是干嘛？\n4. 以课题和结果为导向，选择性地看论文：对我的课题有帮助吗？有借鉴性的地方吗？\n\n### 其他\n老师真的好凶...我害怕了。\n\n\n## 其他备忘录\n\n1. 对自己的课题和工作要有规划。就像交论文有各种ddl一样。\n\n\n  [1]: https://www.zhihu.com/question/47736315\n  [2]: https://www.zhihu.com/question/51435499","slug":"组会笔记","published":1,"updated":"2020-07-09T12:26:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaghd003738t498x5g338","content":"<p>记录一下我研究生期间的组会。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"组会200709\"><a href=\"#组会200709\" class=\"headerlink\" title=\"组会200709\"></a>组会200709</h2><h3 id=\"开题\"><a href=\"#开题\" class=\"headerlink\" title=\"开题\"></a>开题</h3><p>做网络其实要花很多时间的。<br>差的结果也要放上去。<br>对于课题，可以做小的改进，先跑跑结果看看。</p>\n<h3 id=\"论文分享\"><a href=\"#论文分享\" class=\"headerlink\" title=\"论文分享\"></a>论文分享</h3><p><strong>非线性优化</strong><br>优化的目标函数是非线性的。具体方法有：牛顿法、高斯-牛顿法、LM法</p>\n<p><strong>欧拉角</strong><br>用来确定定点转动某一物体的一组角参量，章动角，旋进角，自转角。<br>放到实际的飞机飞行（万向节）例子更好理解：章动角-&gt;桶滚，旋进角-&gt;偏向，自转角-&gt;俯仰<br>这篇文章讲的很好：<a href=\"https://www.zhihu.com/question/47736315\">如何通俗地解释欧拉角-知乎</a></p>\n<p><strong>端到端end-to-end</strong><br>端到端模型：一起扔进去，得到一个结果。<br>参考这篇最高赞答案：<a href=\"https://www.zhihu.com/question/51435499\">什么是 end-to-end 神经网络？</a></p>\n<p><strong>看论文的时候</strong></p>\n<ol>\n<li>时不时地问自己：目的是什么？为什么要这样？</li>\n<li>看摘要：这篇论文在做什么？</li>\n<li>看表格：这篇论文用的什么数据？在分类还是干嘛？</li>\n<li>以课题和结果为导向，选择性地看论文：对我的课题有帮助吗？有借鉴性的地方吗？</li>\n</ol>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>老师真的好凶…我害怕了。</p>\n<h2 id=\"其他备忘录\"><a href=\"#其他备忘录\" class=\"headerlink\" title=\"其他备忘录\"></a>其他备忘录</h2><ol>\n<li>对自己的课题和工作要有规划。就像交论文有各种ddl一样。</li>\n</ol>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>记录一下我研究生期间的组会。</p>","more":"<h2 id=\"组会200709\"><a href=\"#组会200709\" class=\"headerlink\" title=\"组会200709\"></a>组会200709</h2><h3 id=\"开题\"><a href=\"#开题\" class=\"headerlink\" title=\"开题\"></a>开题</h3><p>做网络其实要花很多时间的。<br>差的结果也要放上去。<br>对于课题，可以做小的改进，先跑跑结果看看。</p>\n<h3 id=\"论文分享\"><a href=\"#论文分享\" class=\"headerlink\" title=\"论文分享\"></a>论文分享</h3><p><strong>非线性优化</strong><br>优化的目标函数是非线性的。具体方法有：牛顿法、高斯-牛顿法、LM法</p>\n<p><strong>欧拉角</strong><br>用来确定定点转动某一物体的一组角参量，章动角，旋进角，自转角。<br>放到实际的飞机飞行（万向节）例子更好理解：章动角-&gt;桶滚，旋进角-&gt;偏向，自转角-&gt;俯仰<br>这篇文章讲的很好：<a href=\"https://www.zhihu.com/question/47736315\">如何通俗地解释欧拉角-知乎</a></p>\n<p><strong>端到端end-to-end</strong><br>端到端模型：一起扔进去，得到一个结果。<br>参考这篇最高赞答案：<a href=\"https://www.zhihu.com/question/51435499\">什么是 end-to-end 神经网络？</a></p>\n<p><strong>看论文的时候</strong></p>\n<ol>\n<li>时不时地问自己：目的是什么？为什么要这样？</li>\n<li>看摘要：这篇论文在做什么？</li>\n<li>看表格：这篇论文用的什么数据？在分类还是干嘛？</li>\n<li>以课题和结果为导向，选择性地看论文：对我的课题有帮助吗？有借鉴性的地方吗？</li>\n</ol>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>老师真的好凶…我害怕了。</p>\n<h2 id=\"其他备忘录\"><a href=\"#其他备忘录\" class=\"headerlink\" title=\"其他备忘录\"></a>其他备忘录</h2><ol>\n<li>对自己的课题和工作要有规划。就像交论文有各种ddl一样。</li>\n</ol>"},{"title":"编译原理之LR(1)分析","date":"2018-06-19T14:44:01.000Z","_content":"\n\n\n简单讲讲LR(1)分析法。如果有不对的地方，还请指出！\n<!--more-->\n---\n>LR(1)分析法是一种自下而上的文法分析法，L表示从左到右扫描输入串，R表示构造一个最右推到的逆过程，(1)则表示每次“展望”一个字符，即多向前检查一个字符。\nLR(1)可以确定多数程序语言的“移进”或“归约”。\n\n\n\nLR分析法的适用范围更广，包括了能用LL(1)分析的所有文法。\n它用一个状态联系了历史、现在与未来。在栈顶的状态概括了整个栈的内容。\n本文主要阐述LR(1)分析法，作为基础的LR(0)和SLR(1)不详细展开。\n\n## **几个概念**\n\n 1. 分析表\n 2. 动作(ACTION)表和状态转换(GOTO)表\n 3. 有效项目\n 4. LR(1)项目[A→α·β,a]\n\n### __分析表__\n \n分析表是LR分析器的核心。LR分析器通过对照这张表分析栈顶状态和输入字符串的字符应采取的下一步动作。如图：\n\n![LRTable][1]\n\n### __ACTION表和GOTO表__\n分析表包括两部分：ACTION和GOTO。前者规定状态面对某一终结符采取的动作，后者规定状态面对某一非终结符时的下一状态是什么。\nACTION动作表包括了四个动作：移进、归约、接受、出错\n\n### __有效项目__\n项目A→α·β对活前缀γα是有效的，是指存在规范推导：\nS' => γAω => γαβω\n要注意的是第一**规范推导**，第二**活前缀**。\n\n举个栗子~\n存在文法G(S')：\n>(1) S'→E\n(2) E→aB|bB\n(3) A→cA|d\n(4) B→cB|d\n\n对E→c·B有:S'=>E=>bB=>bcB    \n则E→c·B对活前缀bc是有效的\n对B→·cB有:S'=>E=>bB=>bcB=>bccB \n则B→·cB对活前缀bc是有效的\n对谁有效看项目·前的非终结符与用项目推导前的字符串结合的那个字符串。\n### __LR(1)项目[A→α·β,a]__\nA→α·β是一个LR(0)项目，而a则为向前搜索串，在LR(1)分析中长度为1。\nPS：向前搜索符只对归约项目有意义，而对其他项目来说是用于产生下一个项目的向前搜索符。\n\n\n## **构造分析表**\n第一步构造项目集族，第二步通过项目集族构造分析表。\n有以下文法：\n> (0)S'->S\n(1)S->BB\n(2)B->aB\n(3)B->b\n\n**构造项目集族：**从第一个式子(即拓广文法中的S'->S)开始构造\n共用到两个函数：**CLOSURE(I)**和**GO(I,X)**\n\n前者由项目集中每一个项目生成一个完整项目集。[A->α·Bβ,a]其中B->ξ是一个产生式，对于FIRST(β)中的每一个终结符b，如果[B->·ξ,b]原来不在项目集中，则把它加进去。\n>eg. I0有[S'->·S,#],而产生式1有S->BB，因此[S->·BB,a/b]∈I0.\n以此类推。\n\n后者由一个项目集生成另一个项目集。GO(I,X)=CLOSURE(J),\nJ={任何形如[A->αX·β,a]的项目|[A->α·Xβ,a]∈I}    \n意思就是，I中项目遇到符号X，移进产生新项目，该项目属于J\n>eg. 即[S'->·S,#]∈I0，遇到S移进，得到[S'->S·,#]∈I1\n\n关于向前搜索符，CLOSURE函数得到的与FIRST集，GO函数得到的与前一个项目的向前搜索符有关。\n**构造分析表：**\n1.**ACTION：**项目[A->α·aβ,b]属于Ik且GO(Ik,a)=Ij，a为终结符，则置ACTION[k,a]为sj，即“把状态j和符号a移进栈”\n通俗而言，Ik中项目遇到终结符a，转到Ij，则ACTION[k,a]为sj\n2.**归约：**项目[A->α·,a]属于Ij，则置ACTION[k,a]为rj，即“用产生式A->α归约”（A->α为第j个产生式）\n3.**GOTO：**若GO(Ik,A)=Ij，则置GOTO[k,A]=j\n4.**接受：**若项目[S'->S,#]属于Ik，则置ACTION[k,#]为acc，即“接受”\n\n## **代码思想**##\n分析表state，非终结符vn，终结符vt，项目集族I，FIRST集first，产生式集grammar等均为全局变量\n项目集族，分析表，产生式集用二维字符串数组表示，非终结符和终结符用以为字符数组表示，FIRST集用二维字符数组表示\n其他设置一些辅助变量\n\n核心组成为CLOSURE(I),GO(I,X),总控程序，confirst()\n**CLOSURE(k):**传入参数i为项目集编号，从第一个项目开始循环遍历，若·后为非终结符，生成有效项目，如果项目集Ik中不存在该产生式的有效项目，则添加其至Ik；否则，继续操作下一个项目\n**GO(k,X):**传入参数k为项目集编号，X为字符；从Ik的第一个项目开始遍历。若·后为X，移进生成有效项目，若其不存在在项目集族I中，则作为新项目集的第一个有效项目；否则，进入下一个循环\n**在GO函数中生成分析表：**若X为终结符，由Ik找到Ij，则置state[k,X]=\"sj\"\n若X为非终结符，由Ik找到Ij，则置state[k,X]=\"j\"\n若Ik中只有一个项目，即是归约项，向前搜索符为b，置state[k,b]=\"rj\"(j为该项目对应的第j个产生式)\n**总控程序：**设置字符栈，状态栈，获得输入字符串。依次对字符串每一个字符操作，输入串字符X和状态栈顶状态k，在分析表中得到下一步操作。“sj”表示推入状态j，推入字符X；“rj”表示将字符栈顶字符按产生式j：A->αβ归约，状态栈推出αβ数量，再推入state[k,A]所对应的状态；\n**confirst：**见LL(1)分析法\n\n## **后记**##\n### **代码存在的一些问题**\n1. GO函数生成新项目集时，判断是否已存在的地方有问题。怎么样才能又快又准确地判断？\n项目不存在于现有的项目集族中，才添加\n我的想法是每次只扫描项目集的第一个项目，若相等则已存在。因为除I0外，第一个一定是由别的项目集生成的，而且向前搜索字符顺序固定，所以只要考虑第一个就可以了。\n这样就存在一个问题：I0含S->·A,**a/b**，而I1只含S->·A,**a**，GO(I0,A)和GO(I1,A)第一个都是S->A·,a用上述方法判断为两者相等，而其实是不一样的。\n当文法为二义性文法时会出现此类情况，这就是问题2了。\n2. 二义性问题\n\n### **碎碎念**####\nLR(1)分析一开始想自己用有效项目的推导写，结果绕来绕去，写了两天都没写出来。\nCLOUSRE和GO函数的想法很好，半天就能写出来。前者求出一个完整项目集，后者生成下一个项目集，分两步求。希望可以举一反三，应用此类思想。\n编译原理对我来说有难度，学得不好。写这篇博文也是为了能把知识点串起来，可是掌握得不好，写得不太清晰。\n\n### **参考资料**####\n编译原理（第3版） 陈火旺等人编\n编译原理老师PPT \n\n  [1]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/LRtable.jpg","source":"_posts/编译原理之LR-1-分析.md","raw":"---\ntitle: 编译原理之LR(1)分析\ndate: 2018-06-19 22:44:01\ncategories: 编译原理CompilerPrinciple\n---\n\n\n\n简单讲讲LR(1)分析法。如果有不对的地方，还请指出！\n<!--more-->\n---\n>LR(1)分析法是一种自下而上的文法分析法，L表示从左到右扫描输入串，R表示构造一个最右推到的逆过程，(1)则表示每次“展望”一个字符，即多向前检查一个字符。\nLR(1)可以确定多数程序语言的“移进”或“归约”。\n\n\n\nLR分析法的适用范围更广，包括了能用LL(1)分析的所有文法。\n它用一个状态联系了历史、现在与未来。在栈顶的状态概括了整个栈的内容。\n本文主要阐述LR(1)分析法，作为基础的LR(0)和SLR(1)不详细展开。\n\n## **几个概念**\n\n 1. 分析表\n 2. 动作(ACTION)表和状态转换(GOTO)表\n 3. 有效项目\n 4. LR(1)项目[A→α·β,a]\n\n### __分析表__\n \n分析表是LR分析器的核心。LR分析器通过对照这张表分析栈顶状态和输入字符串的字符应采取的下一步动作。如图：\n\n![LRTable][1]\n\n### __ACTION表和GOTO表__\n分析表包括两部分：ACTION和GOTO。前者规定状态面对某一终结符采取的动作，后者规定状态面对某一非终结符时的下一状态是什么。\nACTION动作表包括了四个动作：移进、归约、接受、出错\n\n### __有效项目__\n项目A→α·β对活前缀γα是有效的，是指存在规范推导：\nS' => γAω => γαβω\n要注意的是第一**规范推导**，第二**活前缀**。\n\n举个栗子~\n存在文法G(S')：\n>(1) S'→E\n(2) E→aB|bB\n(3) A→cA|d\n(4) B→cB|d\n\n对E→c·B有:S'=>E=>bB=>bcB    \n则E→c·B对活前缀bc是有效的\n对B→·cB有:S'=>E=>bB=>bcB=>bccB \n则B→·cB对活前缀bc是有效的\n对谁有效看项目·前的非终结符与用项目推导前的字符串结合的那个字符串。\n### __LR(1)项目[A→α·β,a]__\nA→α·β是一个LR(0)项目，而a则为向前搜索串，在LR(1)分析中长度为1。\nPS：向前搜索符只对归约项目有意义，而对其他项目来说是用于产生下一个项目的向前搜索符。\n\n\n## **构造分析表**\n第一步构造项目集族，第二步通过项目集族构造分析表。\n有以下文法：\n> (0)S'->S\n(1)S->BB\n(2)B->aB\n(3)B->b\n\n**构造项目集族：**从第一个式子(即拓广文法中的S'->S)开始构造\n共用到两个函数：**CLOSURE(I)**和**GO(I,X)**\n\n前者由项目集中每一个项目生成一个完整项目集。[A->α·Bβ,a]其中B->ξ是一个产生式，对于FIRST(β)中的每一个终结符b，如果[B->·ξ,b]原来不在项目集中，则把它加进去。\n>eg. I0有[S'->·S,#],而产生式1有S->BB，因此[S->·BB,a/b]∈I0.\n以此类推。\n\n后者由一个项目集生成另一个项目集。GO(I,X)=CLOSURE(J),\nJ={任何形如[A->αX·β,a]的项目|[A->α·Xβ,a]∈I}    \n意思就是，I中项目遇到符号X，移进产生新项目，该项目属于J\n>eg. 即[S'->·S,#]∈I0，遇到S移进，得到[S'->S·,#]∈I1\n\n关于向前搜索符，CLOSURE函数得到的与FIRST集，GO函数得到的与前一个项目的向前搜索符有关。\n**构造分析表：**\n1.**ACTION：**项目[A->α·aβ,b]属于Ik且GO(Ik,a)=Ij，a为终结符，则置ACTION[k,a]为sj，即“把状态j和符号a移进栈”\n通俗而言，Ik中项目遇到终结符a，转到Ij，则ACTION[k,a]为sj\n2.**归约：**项目[A->α·,a]属于Ij，则置ACTION[k,a]为rj，即“用产生式A->α归约”（A->α为第j个产生式）\n3.**GOTO：**若GO(Ik,A)=Ij，则置GOTO[k,A]=j\n4.**接受：**若项目[S'->S,#]属于Ik，则置ACTION[k,#]为acc，即“接受”\n\n## **代码思想**##\n分析表state，非终结符vn，终结符vt，项目集族I，FIRST集first，产生式集grammar等均为全局变量\n项目集族，分析表，产生式集用二维字符串数组表示，非终结符和终结符用以为字符数组表示，FIRST集用二维字符数组表示\n其他设置一些辅助变量\n\n核心组成为CLOSURE(I),GO(I,X),总控程序，confirst()\n**CLOSURE(k):**传入参数i为项目集编号，从第一个项目开始循环遍历，若·后为非终结符，生成有效项目，如果项目集Ik中不存在该产生式的有效项目，则添加其至Ik；否则，继续操作下一个项目\n**GO(k,X):**传入参数k为项目集编号，X为字符；从Ik的第一个项目开始遍历。若·后为X，移进生成有效项目，若其不存在在项目集族I中，则作为新项目集的第一个有效项目；否则，进入下一个循环\n**在GO函数中生成分析表：**若X为终结符，由Ik找到Ij，则置state[k,X]=\"sj\"\n若X为非终结符，由Ik找到Ij，则置state[k,X]=\"j\"\n若Ik中只有一个项目，即是归约项，向前搜索符为b，置state[k,b]=\"rj\"(j为该项目对应的第j个产生式)\n**总控程序：**设置字符栈，状态栈，获得输入字符串。依次对字符串每一个字符操作，输入串字符X和状态栈顶状态k，在分析表中得到下一步操作。“sj”表示推入状态j，推入字符X；“rj”表示将字符栈顶字符按产生式j：A->αβ归约，状态栈推出αβ数量，再推入state[k,A]所对应的状态；\n**confirst：**见LL(1)分析法\n\n## **后记**##\n### **代码存在的一些问题**\n1. GO函数生成新项目集时，判断是否已存在的地方有问题。怎么样才能又快又准确地判断？\n项目不存在于现有的项目集族中，才添加\n我的想法是每次只扫描项目集的第一个项目，若相等则已存在。因为除I0外，第一个一定是由别的项目集生成的，而且向前搜索字符顺序固定，所以只要考虑第一个就可以了。\n这样就存在一个问题：I0含S->·A,**a/b**，而I1只含S->·A,**a**，GO(I0,A)和GO(I1,A)第一个都是S->A·,a用上述方法判断为两者相等，而其实是不一样的。\n当文法为二义性文法时会出现此类情况，这就是问题2了。\n2. 二义性问题\n\n### **碎碎念**####\nLR(1)分析一开始想自己用有效项目的推导写，结果绕来绕去，写了两天都没写出来。\nCLOUSRE和GO函数的想法很好，半天就能写出来。前者求出一个完整项目集，后者生成下一个项目集，分两步求。希望可以举一反三，应用此类思想。\n编译原理对我来说有难度，学得不好。写这篇博文也是为了能把知识点串起来，可是掌握得不好，写得不太清晰。\n\n### **参考资料**####\n编译原理（第3版） 陈火旺等人编\n编译原理老师PPT \n\n  [1]: https://forlwq.oss-cn-hangzhou.aliyuncs.com/LRtable.jpg","slug":"编译原理之LR-1-分析","published":1,"updated":"2018-06-19T14:44:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaghe003938t4bsklhkaj","content":"<p>简单讲讲LR(1)分析法。如果有不对的地方，还请指出！</p>\n<span id=\"more\"></span>\n<hr>\n<blockquote>\n<p>LR(1)分析法是一种自下而上的文法分析法，L表示从左到右扫描输入串，R表示构造一个最右推到的逆过程，(1)则表示每次“展望”一个字符，即多向前检查一个字符。<br>LR(1)可以确定多数程序语言的“移进”或“归约”。</p>\n</blockquote>\n<p>LR分析法的适用范围更广，包括了能用LL(1)分析的所有文法。<br>它用一个状态联系了历史、现在与未来。在栈顶的状态概括了整个栈的内容。<br>本文主要阐述LR(1)分析法，作为基础的LR(0)和SLR(1)不详细展开。</p>\n<h2 id=\"几个概念\"><a href=\"#几个概念\" class=\"headerlink\" title=\"几个概念\"></a><strong>几个概念</strong></h2><ol>\n<li>分析表</li>\n<li>动作(ACTION)表和状态转换(GOTO)表</li>\n<li>有效项目</li>\n<li>LR(1)项目[A→α·β,a]</li>\n</ol>\n<h3 id=\"分析表\"><a href=\"#分析表\" class=\"headerlink\" title=\"分析表\"></a><strong>分析表</strong></h3><p>分析表是LR分析器的核心。LR分析器通过对照这张表分析栈顶状态和输入字符串的字符应采取的下一步动作。如图：</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/LRtable.jpg\" alt=\"LRTable\"></p>\n<h3 id=\"ACTION表和GOTO表\"><a href=\"#ACTION表和GOTO表\" class=\"headerlink\" title=\"ACTION表和GOTO表\"></a><strong>ACTION表和GOTO表</strong></h3><p>分析表包括两部分：ACTION和GOTO。前者规定状态面对某一终结符采取的动作，后者规定状态面对某一非终结符时的下一状态是什么。<br>ACTION动作表包括了四个动作：移进、归约、接受、出错</p>\n<h3 id=\"有效项目\"><a href=\"#有效项目\" class=\"headerlink\" title=\"有效项目\"></a><strong>有效项目</strong></h3><p>项目A→α·β对活前缀γα是有效的，是指存在规范推导：<br>S’ =&gt; γAω =&gt; γαβω<br>要注意的是第一<strong>规范推导</strong>，第二<strong>活前缀</strong>。</p>\n<p>举个栗子~<br>存在文法G(S’)：</p>\n<blockquote>\n<p>(1) S’→E<br>(2) E→aB|bB<br>(3) A→cA|d<br>(4) B→cB|d</p>\n</blockquote>\n<p>对E→c·B有:S’=&gt;E=&gt;bB=&gt;bcB<br>则E→c·B对活前缀bc是有效的<br>对B→·cB有:S’=&gt;E=&gt;bB=&gt;bcB=&gt;bccB<br>则B→·cB对活前缀bc是有效的<br>对谁有效看项目·前的非终结符与用项目推导前的字符串结合的那个字符串。</p>\n<h3 id=\"LR-1-项目-A→α·β-a\"><a href=\"#LR-1-项目-A→α·β-a\" class=\"headerlink\" title=\"LR(1)项目[A→α·β,a]\"></a><strong>LR(1)项目[A→α·β,a]</strong></h3><p>A→α·β是一个LR(0)项目，而a则为向前搜索串，在LR(1)分析中长度为1。<br>PS：向前搜索符只对归约项目有意义，而对其他项目来说是用于产生下一个项目的向前搜索符。</p>\n<h2 id=\"构造分析表\"><a href=\"#构造分析表\" class=\"headerlink\" title=\"构造分析表\"></a><strong>构造分析表</strong></h2><p>第一步构造项目集族，第二步通过项目集族构造分析表。<br>有以下文法：</p>\n<blockquote>\n<p>(0)S’-&gt;S<br>(1)S-&gt;BB<br>(2)B-&gt;aB<br>(3)B-&gt;b</p>\n</blockquote>\n<p><strong>构造项目集族：</strong>从第一个式子(即拓广文法中的S’-&gt;S)开始构造<br>共用到两个函数：<strong>CLOSURE(I)<strong>和</strong>GO(I,X)</strong></p>\n<p>前者由项目集中每一个项目生成一个完整项目集。[A-&gt;α·Bβ,a]其中B-&gt;ξ是一个产生式，对于FIRST(β)中的每一个终结符b，如果[B-&gt;·ξ,b]原来不在项目集中，则把它加进去。</p>\n<blockquote>\n<p>eg. I0有[S’-&gt;·S,#],而产生式1有S-&gt;BB，因此[S-&gt;·BB,a/b]∈I0.<br>以此类推。</p>\n</blockquote>\n<p>后者由一个项目集生成另一个项目集。GO(I,X)=CLOSURE(J),<br>J={任何形如[A-&gt;αX·β,a]的项目|[A-&gt;α·Xβ,a]∈I}<br>意思就是，I中项目遇到符号X，移进产生新项目，该项目属于J</p>\n<blockquote>\n<p>eg. 即[S’-&gt;·S,#]∈I0，遇到S移进，得到[S’-&gt;S·,#]∈I1</p>\n</blockquote>\n<p>关于向前搜索符，CLOSURE函数得到的与FIRST集，GO函数得到的与前一个项目的向前搜索符有关。<br><strong>构造分析表：</strong><br>1.<strong>ACTION：</strong>项目[A-&gt;α·aβ,b]属于Ik且GO(Ik,a)=Ij，a为终结符，则置ACTION[k,a]为sj，即“把状态j和符号a移进栈”<br>通俗而言，Ik中项目遇到终结符a，转到Ij，则ACTION[k,a]为sj<br>2.<strong>归约：</strong>项目[A-&gt;α·,a]属于Ij，则置ACTION[k,a]为rj，即“用产生式A-&gt;α归约”（A-&gt;α为第j个产生式）<br>3.<strong>GOTO：</strong>若GO(Ik,A)=Ij，则置GOTO[k,A]=j<br>4.<strong>接受：</strong>若项目[S’-&gt;S,#]属于Ik，则置ACTION[k,#]为acc，即“接受”</p>\n<h2 id=\"代码思想\"><a href=\"#代码思想\" class=\"headerlink\" title=\"代码思想##\"></a><strong>代码思想</strong>##</h2><p>分析表state，非终结符vn，终结符vt，项目集族I，FIRST集first，产生式集grammar等均为全局变量<br>项目集族，分析表，产生式集用二维字符串数组表示，非终结符和终结符用以为字符数组表示，FIRST集用二维字符数组表示<br>其他设置一些辅助变量</p>\n<p>核心组成为CLOSURE(I),GO(I,X),总控程序，confirst()<br>**CLOSURE(k):**传入参数i为项目集编号，从第一个项目开始循环遍历，若·后为非终结符，生成有效项目，如果项目集Ik中不存在该产生式的有效项目，则添加其至Ik；否则，继续操作下一个项目<br>**GO(k,X):**传入参数k为项目集编号，X为字符；从Ik的第一个项目开始遍历。若·后为X，移进生成有效项目，若其不存在在项目集族I中，则作为新项目集的第一个有效项目；否则，进入下一个循环<br><strong>在GO函数中生成分析表：</strong>若X为终结符，由Ik找到Ij，则置state[k,X]=”sj”<br>若X为非终结符，由Ik找到Ij，则置state[k,X]=”j”<br>若Ik中只有一个项目，即是归约项，向前搜索符为b，置state[k,b]=”rj”(j为该项目对应的第j个产生式)<br><strong>总控程序：</strong>设置字符栈，状态栈，获得输入字符串。依次对字符串每一个字符操作，输入串字符X和状态栈顶状态k，在分析表中得到下一步操作。“sj”表示推入状态j，推入字符X；“rj”表示将字符栈顶字符按产生式j：A-&gt;αβ归约，状态栈推出αβ数量，再推入state[k,A]所对应的状态；<br><strong>confirst：</strong>见LL(1)分析法</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记##\"></a><strong>后记</strong>##</h2><h3 id=\"代码存在的一些问题\"><a href=\"#代码存在的一些问题\" class=\"headerlink\" title=\"代码存在的一些问题\"></a><strong>代码存在的一些问题</strong></h3><ol>\n<li>GO函数生成新项目集时，判断是否已存在的地方有问题。怎么样才能又快又准确地判断？<br>项目不存在于现有的项目集族中，才添加<br>我的想法是每次只扫描项目集的第一个项目，若相等则已存在。因为除I0外，第一个一定是由别的项目集生成的，而且向前搜索字符顺序固定，所以只要考虑第一个就可以了。<br>这样就存在一个问题：I0含S-&gt;·A,<strong>a/b</strong>，而I1只含S-&gt;·A,<strong>a</strong>，GO(I0,A)和GO(I1,A)第一个都是S-&gt;A·,a用上述方法判断为两者相等，而其实是不一样的。<br>当文法为二义性文法时会出现此类情况，这就是问题2了。</li>\n<li>二义性问题</li>\n</ol>\n<h3 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念####\"></a><strong>碎碎念</strong>####</h3><p>LR(1)分析一开始想自己用有效项目的推导写，结果绕来绕去，写了两天都没写出来。<br>CLOUSRE和GO函数的想法很好，半天就能写出来。前者求出一个完整项目集，后者生成下一个项目集，分两步求。希望可以举一反三，应用此类思想。<br>编译原理对我来说有难度，学得不好。写这篇博文也是为了能把知识点串起来，可是掌握得不好，写得不太清晰。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料####\"></a><strong>参考资料</strong>####</h3><p>编译原理（第3版） 陈火旺等人编<br>编译原理老师PPT </p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>简单讲讲LR(1)分析法。如果有不对的地方，还请指出！</p>","more":"<hr>\n<blockquote>\n<p>LR(1)分析法是一种自下而上的文法分析法，L表示从左到右扫描输入串，R表示构造一个最右推到的逆过程，(1)则表示每次“展望”一个字符，即多向前检查一个字符。<br>LR(1)可以确定多数程序语言的“移进”或“归约”。</p>\n</blockquote>\n<p>LR分析法的适用范围更广，包括了能用LL(1)分析的所有文法。<br>它用一个状态联系了历史、现在与未来。在栈顶的状态概括了整个栈的内容。<br>本文主要阐述LR(1)分析法，作为基础的LR(0)和SLR(1)不详细展开。</p>\n<h2 id=\"几个概念\"><a href=\"#几个概念\" class=\"headerlink\" title=\"几个概念\"></a><strong>几个概念</strong></h2><ol>\n<li>分析表</li>\n<li>动作(ACTION)表和状态转换(GOTO)表</li>\n<li>有效项目</li>\n<li>LR(1)项目[A→α·β,a]</li>\n</ol>\n<h3 id=\"分析表\"><a href=\"#分析表\" class=\"headerlink\" title=\"分析表\"></a><strong>分析表</strong></h3><p>分析表是LR分析器的核心。LR分析器通过对照这张表分析栈顶状态和输入字符串的字符应采取的下一步动作。如图：</p>\n<p><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/LRtable.jpg\" alt=\"LRTable\"></p>\n<h3 id=\"ACTION表和GOTO表\"><a href=\"#ACTION表和GOTO表\" class=\"headerlink\" title=\"ACTION表和GOTO表\"></a><strong>ACTION表和GOTO表</strong></h3><p>分析表包括两部分：ACTION和GOTO。前者规定状态面对某一终结符采取的动作，后者规定状态面对某一非终结符时的下一状态是什么。<br>ACTION动作表包括了四个动作：移进、归约、接受、出错</p>\n<h3 id=\"有效项目\"><a href=\"#有效项目\" class=\"headerlink\" title=\"有效项目\"></a><strong>有效项目</strong></h3><p>项目A→α·β对活前缀γα是有效的，是指存在规范推导：<br>S’ =&gt; γAω =&gt; γαβω<br>要注意的是第一<strong>规范推导</strong>，第二<strong>活前缀</strong>。</p>\n<p>举个栗子~<br>存在文法G(S’)：</p>\n<blockquote>\n<p>(1) S’→E<br>(2) E→aB|bB<br>(3) A→cA|d<br>(4) B→cB|d</p>\n</blockquote>\n<p>对E→c·B有:S’=&gt;E=&gt;bB=&gt;bcB<br>则E→c·B对活前缀bc是有效的<br>对B→·cB有:S’=&gt;E=&gt;bB=&gt;bcB=&gt;bccB<br>则B→·cB对活前缀bc是有效的<br>对谁有效看项目·前的非终结符与用项目推导前的字符串结合的那个字符串。</p>\n<h3 id=\"LR-1-项目-A→α·β-a\"><a href=\"#LR-1-项目-A→α·β-a\" class=\"headerlink\" title=\"LR(1)项目[A→α·β,a]\"></a><strong>LR(1)项目[A→α·β,a]</strong></h3><p>A→α·β是一个LR(0)项目，而a则为向前搜索串，在LR(1)分析中长度为1。<br>PS：向前搜索符只对归约项目有意义，而对其他项目来说是用于产生下一个项目的向前搜索符。</p>\n<h2 id=\"构造分析表\"><a href=\"#构造分析表\" class=\"headerlink\" title=\"构造分析表\"></a><strong>构造分析表</strong></h2><p>第一步构造项目集族，第二步通过项目集族构造分析表。<br>有以下文法：</p>\n<blockquote>\n<p>(0)S’-&gt;S<br>(1)S-&gt;BB<br>(2)B-&gt;aB<br>(3)B-&gt;b</p>\n</blockquote>\n<p><strong>构造项目集族：</strong>从第一个式子(即拓广文法中的S’-&gt;S)开始构造<br>共用到两个函数：<strong>CLOSURE(I)<strong>和</strong>GO(I,X)</strong></p>\n<p>前者由项目集中每一个项目生成一个完整项目集。[A-&gt;α·Bβ,a]其中B-&gt;ξ是一个产生式，对于FIRST(β)中的每一个终结符b，如果[B-&gt;·ξ,b]原来不在项目集中，则把它加进去。</p>\n<blockquote>\n<p>eg. I0有[S’-&gt;·S,#],而产生式1有S-&gt;BB，因此[S-&gt;·BB,a/b]∈I0.<br>以此类推。</p>\n</blockquote>\n<p>后者由一个项目集生成另一个项目集。GO(I,X)=CLOSURE(J),<br>J={任何形如[A-&gt;αX·β,a]的项目|[A-&gt;α·Xβ,a]∈I}<br>意思就是，I中项目遇到符号X，移进产生新项目，该项目属于J</p>\n<blockquote>\n<p>eg. 即[S’-&gt;·S,#]∈I0，遇到S移进，得到[S’-&gt;S·,#]∈I1</p>\n</blockquote>\n<p>关于向前搜索符，CLOSURE函数得到的与FIRST集，GO函数得到的与前一个项目的向前搜索符有关。<br><strong>构造分析表：</strong><br>1.<strong>ACTION：</strong>项目[A-&gt;α·aβ,b]属于Ik且GO(Ik,a)=Ij，a为终结符，则置ACTION[k,a]为sj，即“把状态j和符号a移进栈”<br>通俗而言，Ik中项目遇到终结符a，转到Ij，则ACTION[k,a]为sj<br>2.<strong>归约：</strong>项目[A-&gt;α·,a]属于Ij，则置ACTION[k,a]为rj，即“用产生式A-&gt;α归约”（A-&gt;α为第j个产生式）<br>3.<strong>GOTO：</strong>若GO(Ik,A)=Ij，则置GOTO[k,A]=j<br>4.<strong>接受：</strong>若项目[S’-&gt;S,#]属于Ik，则置ACTION[k,#]为acc，即“接受”</p>\n<h2 id=\"代码思想\"><a href=\"#代码思想\" class=\"headerlink\" title=\"代码思想##\"></a><strong>代码思想</strong>##</h2><p>分析表state，非终结符vn，终结符vt，项目集族I，FIRST集first，产生式集grammar等均为全局变量<br>项目集族，分析表，产生式集用二维字符串数组表示，非终结符和终结符用以为字符数组表示，FIRST集用二维字符数组表示<br>其他设置一些辅助变量</p>\n<p>核心组成为CLOSURE(I),GO(I,X),总控程序，confirst()<br>**CLOSURE(k):**传入参数i为项目集编号，从第一个项目开始循环遍历，若·后为非终结符，生成有效项目，如果项目集Ik中不存在该产生式的有效项目，则添加其至Ik；否则，继续操作下一个项目<br>**GO(k,X):**传入参数k为项目集编号，X为字符；从Ik的第一个项目开始遍历。若·后为X，移进生成有效项目，若其不存在在项目集族I中，则作为新项目集的第一个有效项目；否则，进入下一个循环<br><strong>在GO函数中生成分析表：</strong>若X为终结符，由Ik找到Ij，则置state[k,X]=”sj”<br>若X为非终结符，由Ik找到Ij，则置state[k,X]=”j”<br>若Ik中只有一个项目，即是归约项，向前搜索符为b，置state[k,b]=”rj”(j为该项目对应的第j个产生式)<br><strong>总控程序：</strong>设置字符栈，状态栈，获得输入字符串。依次对字符串每一个字符操作，输入串字符X和状态栈顶状态k，在分析表中得到下一步操作。“sj”表示推入状态j，推入字符X；“rj”表示将字符栈顶字符按产生式j：A-&gt;αβ归约，状态栈推出αβ数量，再推入state[k,A]所对应的状态；<br><strong>confirst：</strong>见LL(1)分析法</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记##\"></a><strong>后记</strong>##</h2><h3 id=\"代码存在的一些问题\"><a href=\"#代码存在的一些问题\" class=\"headerlink\" title=\"代码存在的一些问题\"></a><strong>代码存在的一些问题</strong></h3><ol>\n<li>GO函数生成新项目集时，判断是否已存在的地方有问题。怎么样才能又快又准确地判断？<br>项目不存在于现有的项目集族中，才添加<br>我的想法是每次只扫描项目集的第一个项目，若相等则已存在。因为除I0外，第一个一定是由别的项目集生成的，而且向前搜索字符顺序固定，所以只要考虑第一个就可以了。<br>这样就存在一个问题：I0含S-&gt;·A,<strong>a/b</strong>，而I1只含S-&gt;·A,<strong>a</strong>，GO(I0,A)和GO(I1,A)第一个都是S-&gt;A·,a用上述方法判断为两者相等，而其实是不一样的。<br>当文法为二义性文法时会出现此类情况，这就是问题2了。</li>\n<li>二义性问题</li>\n</ol>\n<h3 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念####\"></a><strong>碎碎念</strong>####</h3><p>LR(1)分析一开始想自己用有效项目的推导写，结果绕来绕去，写了两天都没写出来。<br>CLOUSRE和GO函数的想法很好，半天就能写出来。前者求出一个完整项目集，后者生成下一个项目集，分两步求。希望可以举一反三，应用此类思想。<br>编译原理对我来说有难度，学得不好。写这篇博文也是为了能把知识点串起来，可是掌握得不好，写得不太清晰。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料####\"></a><strong>参考资料</strong>####</h3><p>编译原理（第3版） 陈火旺等人编<br>编译原理老师PPT </p>"},{"title":"脚本学习","date":"2018-12-06T10:22:00.000Z","_content":"脚本真的太方便了！！！\n<!--more-->\n---\n## 批处理给文件命名。\n> 1.jpg 2.jpg 3.jpg...\n\n首先要解决如何一行输出一个文件名，dir/w 只能一行输出三个，dir/b可以。\n```\n    dir/b\n```\n用PowerShell中要在前面加cmd /r\n``` \n    cmd /r dir/b\n```\n使用效果如图：\n![此处输入图片的描述][1]\n具体步骤如下：\n1.输入所有文件名到excel文件中\n```\n    cmd /r dir/b >rename.xls\n```\n2.A列单元格中按序存放所有文件名，在B列单元格中输入对应的要转成的文件名，如1.jpg...（用填充）\n3.在C列单元格中输入公式（再用填充）\n```\n=\"ren \"&A1&\" \"&B1\n```\n4.复制C列到.txt文件中，再将txt后缀名改成bat\n5.记得把bat文件放到那个目录下，运行bat文件就行了~\n> PS1：PowerShell不能直接使用dir/w，会显示找不到方法的错误。在Stack Overflow上找到了解决办法（[ClickHere][2]\nPS2：Stack Overflow上说用ls命令可以（[ClickHere][3]）。这是Linux下的方法。（两个区别在于Windows下的dir命令是批处理方法，Linux下的ls命令不是\nPS3：Stack Overflow大法好！\n\n\n  [1]: http://forlwq.oss-cn-hangzhou.aliyuncs.com/script-1.png\n  [2]: https://stackoverflow.com/questions/1479663/how-do-i-do-dir-s-b-in-powershell/39459273\n  [3]: https://stackoverflow.com/questions/42224181/exact-bash-equivalent-for-cmd-dir-b","source":"_posts/脚本学习.md","raw":"---\ntitle: 脚本学习\ndate: 2018-12-06 18:22\ncategories: 学习LearnSomething\n---\n脚本真的太方便了！！！\n<!--more-->\n---\n## 批处理给文件命名。\n> 1.jpg 2.jpg 3.jpg...\n\n首先要解决如何一行输出一个文件名，dir/w 只能一行输出三个，dir/b可以。\n```\n    dir/b\n```\n用PowerShell中要在前面加cmd /r\n``` \n    cmd /r dir/b\n```\n使用效果如图：\n![此处输入图片的描述][1]\n具体步骤如下：\n1.输入所有文件名到excel文件中\n```\n    cmd /r dir/b >rename.xls\n```\n2.A列单元格中按序存放所有文件名，在B列单元格中输入对应的要转成的文件名，如1.jpg...（用填充）\n3.在C列单元格中输入公式（再用填充）\n```\n=\"ren \"&A1&\" \"&B1\n```\n4.复制C列到.txt文件中，再将txt后缀名改成bat\n5.记得把bat文件放到那个目录下，运行bat文件就行了~\n> PS1：PowerShell不能直接使用dir/w，会显示找不到方法的错误。在Stack Overflow上找到了解决办法（[ClickHere][2]\nPS2：Stack Overflow上说用ls命令可以（[ClickHere][3]）。这是Linux下的方法。（两个区别在于Windows下的dir命令是批处理方法，Linux下的ls命令不是\nPS3：Stack Overflow大法好！\n\n\n  [1]: http://forlwq.oss-cn-hangzhou.aliyuncs.com/script-1.png\n  [2]: https://stackoverflow.com/questions/1479663/how-do-i-do-dir-s-b-in-powershell/39459273\n  [3]: https://stackoverflow.com/questions/42224181/exact-bash-equivalent-for-cmd-dir-b","slug":"脚本学习","published":1,"updated":"2018-12-06T10:22:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaghe003c38t49yywhnh1","content":"<p>脚本真的太方便了！！！</p>\n<span id=\"more\"></span>\n<hr>\n<h2 id=\"批处理给文件命名。\"><a href=\"#批处理给文件命名。\" class=\"headerlink\" title=\"批处理给文件命名。\"></a>批处理给文件命名。</h2><blockquote>\n<p>1.jpg 2.jpg 3.jpg…</p>\n</blockquote>\n<p>首先要解决如何一行输出一个文件名，dir/w 只能一行输出三个，dir/b可以。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir/b</span><br></pre></td></tr></table></figure>\n<p>用PowerShell中要在前面加cmd /r</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmd /r dir/b</span><br></pre></td></tr></table></figure>\n<p>使用效果如图：<br><img src=\"http://forlwq.oss-cn-hangzhou.aliyuncs.com/script-1.png\" alt=\"此处输入图片的描述\"><br>具体步骤如下：<br>1.输入所有文件名到excel文件中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmd /r dir/b &gt;rename.xls</span><br></pre></td></tr></table></figure>\n<p>2.A列单元格中按序存放所有文件名，在B列单元格中输入对应的要转成的文件名，如1.jpg…（用填充）<br>3.在C列单元格中输入公式（再用填充）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&quot;ren &quot;&amp;A1&amp;&quot; &quot;&amp;B1</span><br></pre></td></tr></table></figure>\n<p>4.复制C列到.txt文件中，再将txt后缀名改成bat<br>5.记得把bat文件放到那个目录下，运行bat文件就行了~</p>\n<blockquote>\n<p>PS1：PowerShell不能直接使用dir/w，会显示找不到方法的错误。在Stack Overflow上找到了解决办法（<a href=\"https://stackoverflow.com/questions/1479663/how-do-i-do-dir-s-b-in-powershell/39459273\">ClickHere</a><br>PS2：Stack Overflow上说用ls命令可以（<a href=\"https://stackoverflow.com/questions/42224181/exact-bash-equivalent-for-cmd-dir-b\">ClickHere</a>）。这是Linux下的方法。（两个区别在于Windows下的dir命令是批处理方法，Linux下的ls命令不是<br>PS3：Stack Overflow大法好！</p>\n</blockquote>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>脚本真的太方便了！！！</p>","more":"<hr>\n<h2 id=\"批处理给文件命名。\"><a href=\"#批处理给文件命名。\" class=\"headerlink\" title=\"批处理给文件命名。\"></a>批处理给文件命名。</h2><blockquote>\n<p>1.jpg 2.jpg 3.jpg…</p>\n</blockquote>\n<p>首先要解决如何一行输出一个文件名，dir/w 只能一行输出三个，dir/b可以。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir/b</span><br></pre></td></tr></table></figure>\n<p>用PowerShell中要在前面加cmd /r</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmd /r dir/b</span><br></pre></td></tr></table></figure>\n<p>使用效果如图：<br><img src=\"http://forlwq.oss-cn-hangzhou.aliyuncs.com/script-1.png\" alt=\"此处输入图片的描述\"><br>具体步骤如下：<br>1.输入所有文件名到excel文件中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmd /r dir/b &gt;rename.xls</span><br></pre></td></tr></table></figure>\n<p>2.A列单元格中按序存放所有文件名，在B列单元格中输入对应的要转成的文件名，如1.jpg…（用填充）<br>3.在C列单元格中输入公式（再用填充）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&quot;ren &quot;&amp;A1&amp;&quot; &quot;&amp;B1</span><br></pre></td></tr></table></figure>\n<p>4.复制C列到.txt文件中，再将txt后缀名改成bat<br>5.记得把bat文件放到那个目录下，运行bat文件就行了~</p>\n<blockquote>\n<p>PS1：PowerShell不能直接使用dir/w，会显示找不到方法的错误。在Stack Overflow上找到了解决办法（<a href=\"https://stackoverflow.com/questions/1479663/how-do-i-do-dir-s-b-in-powershell/39459273\">ClickHere</a><br>PS2：Stack Overflow上说用ls命令可以（<a href=\"https://stackoverflow.com/questions/42224181/exact-bash-equivalent-for-cmd-dir-b\">ClickHere</a>）。这是Linux下的方法。（两个区别在于Windows下的dir命令是批处理方法，Linux下的ls命令不是<br>PS3：Stack Overflow大法好！</p>\n</blockquote>"},{"title":"随感0428","date":"2019-04-28T02:11:31.000Z","_content":"<div align=\"right\">\n    <font size=2 color=#999999>Photo by NASA on Unsplash</font>\n</div>\n\n生活可以是很无奈的。\n\n但是人也因此变得强大。你看人类，完全没有能力改变时间的流逝，改变死亡的绝对，也完全没有能力探知无穷的真理。渺小而无助的，出现在这个孤独的蓝色星球上。\n\n他们却依然认真地生活，做着自己该做的事。既没有崩溃与放弃，也没有杞人忧天，让自己短暂的一生挥洒出最灿烂的光。\n\nLive in the moment.\n","source":"_posts/随感0428.md","raw":"---\ntitle: 随感0428\ndate: 2019-04-28 10:11:31\ncategories: 生活Life\nphoto: http://forlwq.oss-cn-hangzhou.aliyuncs.com/nasa-63032-unsplash.jpg\n---\n<div align=\"right\">\n    <font size=2 color=#999999>Photo by NASA on Unsplash</font>\n</div>\n\n生活可以是很无奈的。\n\n但是人也因此变得强大。你看人类，完全没有能力改变时间的流逝，改变死亡的绝对，也完全没有能力探知无穷的真理。渺小而无助的，出现在这个孤独的蓝色星球上。\n\n他们却依然认真地生活，做着自己该做的事。既没有崩溃与放弃，也没有杞人忧天，让自己短暂的一生挥洒出最灿烂的光。\n\nLive in the moment.\n","slug":"随感0428","published":1,"updated":"2019-04-28T02:11:31.000Z","photos":["http://forlwq.oss-cn-hangzhou.aliyuncs.com/nasa-63032-unsplash.jpg"],"comments":1,"layout":"post","link":"","_id":"cl1jeaghf003f38t4d8rsdzd0","content":"<div align=\"right\">\n    <font size=2 color=#999999>Photo by NASA on Unsplash</font>\n</div>\n\n<p>生活可以是很无奈的。</p>\n<p>但是人也因此变得强大。你看人类，完全没有能力改变时间的流逝，改变死亡的绝对，也完全没有能力探知无穷的真理。渺小而无助的，出现在这个孤独的蓝色星球上。</p>\n<p>他们却依然认真地生活，做着自己该做的事。既没有崩溃与放弃，也没有杞人忧天，让自己短暂的一生挥洒出最灿烂的光。</p>\n<p>Live in the moment.</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"","more":"<div align=\"right\">\n    <font size=2 color=#999999>Photo by NASA on Unsplash</font>\n</div>\n\n<p>生活可以是很无奈的。</p>\n<p>但是人也因此变得强大。你看人类，完全没有能力改变时间的流逝，改变死亡的绝对，也完全没有能力探知无穷的真理。渺小而无助的，出现在这个孤独的蓝色星球上。</p>\n<p>他们却依然认真地生活，做着自己该做的事。既没有崩溃与放弃，也没有杞人忧天，让自己短暂的一生挥洒出最灿烂的光。</p>\n<p>Live in the moment.</p>\n"},{"title":"随感0609","date":"2019-06-10T12:33:43.000Z","_content":"\n三年前的今天，我做完了最后一份高三试卷。\n\n<!--more-->\n\n---\n\n这三年之中，我时不时地会想起高考。真的心有不甘。\n没有一个人会想到我数学只考了95。跟大学同学聊起来的时候，还有人问：“你们满分是150吗？”跟高中同学聊起来的时候，也会说：“你怎么才这么点？”每个人都说数学考砸了，可是没有一个考得比我差的。\n虽然每次聊起来都是嘻嘻哈哈的，我却始终不甘心，一直以来也试图去找一个答案：“为什么？”\n不知不觉三年了，这一次，我尝试着去回答自己。这些是我的思考，如果对你也有帮助，那就更好了。\n## “其实我从来没有真正地相信自己。”\n我说我要上浙大，可是我不敢真的说出口。想着放在心里，等到实现的那一天，或者说等待奇迹。\n我不是打心底地相信自己能。比起相信自己，我似乎更相信奇迹。甚至到了考试那天也是如此。我选择了相信奇迹，相信运气，而不是沉下心来，脚踏实地。\n其实呢没有什么奇迹，也不该赖着好运。可以相信和依赖的，只有我自己。\n班主任一天到晚和我们说着“踏实”，可惜了我到现在才理解“踏实”二字的含义。\n\n## “我的目标是努力”\n上了高三之后的每一天，我几乎都在努力。我因为失意而自怜，也因为得意而自喜。\n慢慢地，努力变成我的目标，却不去想努力能带给我什么，也忘了努力只是我实现目标的一个方式而已。\n每天重复的努力，最后变成了自我感动。却不肯承认自己有问题。拿着“我已经那么努力了，失败了也没有关系”做借口。\n\n## “我不知道自己想要什么”\n我不知道自己是个什么样的人，也不清楚自己的实力在哪。\n我只是去做别人叫我去做的事情。或者说，我只是去做，大家都在做的事情。又或者说，我只是去做，在我看来最方便的事情。\n于是，我选择了最好走的路。为一点小成就而沾沾自喜。选择了别人叫我走的路，有时候又因为心中萌生的那种自我觉醒而感到迷茫。选择了大家都在走的路，同样的，有时候因为那种突然的自我觉醒而感到迷茫。\n好像写跑了，而且这也太真实了。这里更多地体现在我的大学生活里。\n\n## 后记\n“命运偷走如果，只留下结果。”\n没有那么多如果，只有后悔吧。\n写下这篇，希望自己不挂念过去，不去想那么多如果。过去的过不去了，未来也已经来了。踏踏实实地，做好眼前的事情。\n自我觉醒是很难得的，萌生难得，发现难得，维持最难得。\n\n对了，我最近有了一个更明确的目标，或者说是梦想。\n\n这一次，不去相信奇迹，不去依靠运气，不去活成别人的期待。哪怕还是一场自我感动，我错也错得心甘情愿。\n","source":"_posts/随感0609.md","raw":"---\ntitle: 随感0609\ndate: 2019-06-10 20:33:43\ncategories: 生活Life\n---\n\n三年前的今天，我做完了最后一份高三试卷。\n\n<!--more-->\n\n---\n\n这三年之中，我时不时地会想起高考。真的心有不甘。\n没有一个人会想到我数学只考了95。跟大学同学聊起来的时候，还有人问：“你们满分是150吗？”跟高中同学聊起来的时候，也会说：“你怎么才这么点？”每个人都说数学考砸了，可是没有一个考得比我差的。\n虽然每次聊起来都是嘻嘻哈哈的，我却始终不甘心，一直以来也试图去找一个答案：“为什么？”\n不知不觉三年了，这一次，我尝试着去回答自己。这些是我的思考，如果对你也有帮助，那就更好了。\n## “其实我从来没有真正地相信自己。”\n我说我要上浙大，可是我不敢真的说出口。想着放在心里，等到实现的那一天，或者说等待奇迹。\n我不是打心底地相信自己能。比起相信自己，我似乎更相信奇迹。甚至到了考试那天也是如此。我选择了相信奇迹，相信运气，而不是沉下心来，脚踏实地。\n其实呢没有什么奇迹，也不该赖着好运。可以相信和依赖的，只有我自己。\n班主任一天到晚和我们说着“踏实”，可惜了我到现在才理解“踏实”二字的含义。\n\n## “我的目标是努力”\n上了高三之后的每一天，我几乎都在努力。我因为失意而自怜，也因为得意而自喜。\n慢慢地，努力变成我的目标，却不去想努力能带给我什么，也忘了努力只是我实现目标的一个方式而已。\n每天重复的努力，最后变成了自我感动。却不肯承认自己有问题。拿着“我已经那么努力了，失败了也没有关系”做借口。\n\n## “我不知道自己想要什么”\n我不知道自己是个什么样的人，也不清楚自己的实力在哪。\n我只是去做别人叫我去做的事情。或者说，我只是去做，大家都在做的事情。又或者说，我只是去做，在我看来最方便的事情。\n于是，我选择了最好走的路。为一点小成就而沾沾自喜。选择了别人叫我走的路，有时候又因为心中萌生的那种自我觉醒而感到迷茫。选择了大家都在走的路，同样的，有时候因为那种突然的自我觉醒而感到迷茫。\n好像写跑了，而且这也太真实了。这里更多地体现在我的大学生活里。\n\n## 后记\n“命运偷走如果，只留下结果。”\n没有那么多如果，只有后悔吧。\n写下这篇，希望自己不挂念过去，不去想那么多如果。过去的过不去了，未来也已经来了。踏踏实实地，做好眼前的事情。\n自我觉醒是很难得的，萌生难得，发现难得，维持最难得。\n\n对了，我最近有了一个更明确的目标，或者说是梦想。\n\n这一次，不去相信奇迹，不去依靠运气，不去活成别人的期待。哪怕还是一场自我感动，我错也错得心甘情愿。\n","slug":"随感0609","published":1,"updated":"2019-06-10T12:33:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaghk003s38t427105sf5","content":"<p>三年前的今天，我做完了最后一份高三试卷。</p>\n<span id=\"more\"></span>\n\n<hr>\n<p>这三年之中，我时不时地会想起高考。真的心有不甘。<br>没有一个人会想到我数学只考了95。跟大学同学聊起来的时候，还有人问：“你们满分是150吗？”跟高中同学聊起来的时候，也会说：“你怎么才这么点？”每个人都说数学考砸了，可是没有一个考得比我差的。<br>虽然每次聊起来都是嘻嘻哈哈的，我却始终不甘心，一直以来也试图去找一个答案：“为什么？”<br>不知不觉三年了，这一次，我尝试着去回答自己。这些是我的思考，如果对你也有帮助，那就更好了。</p>\n<h2 id=\"“其实我从来没有真正地相信自己。”\"><a href=\"#“其实我从来没有真正地相信自己。”\" class=\"headerlink\" title=\"“其实我从来没有真正地相信自己。”\"></a>“其实我从来没有真正地相信自己。”</h2><p>我说我要上浙大，可是我不敢真的说出口。想着放在心里，等到实现的那一天，或者说等待奇迹。<br>我不是打心底地相信自己能。比起相信自己，我似乎更相信奇迹。甚至到了考试那天也是如此。我选择了相信奇迹，相信运气，而不是沉下心来，脚踏实地。<br>其实呢没有什么奇迹，也不该赖着好运。可以相信和依赖的，只有我自己。<br>班主任一天到晚和我们说着“踏实”，可惜了我到现在才理解“踏实”二字的含义。</p>\n<h2 id=\"“我的目标是努力”\"><a href=\"#“我的目标是努力”\" class=\"headerlink\" title=\"“我的目标是努力”\"></a>“我的目标是努力”</h2><p>上了高三之后的每一天，我几乎都在努力。我因为失意而自怜，也因为得意而自喜。<br>慢慢地，努力变成我的目标，却不去想努力能带给我什么，也忘了努力只是我实现目标的一个方式而已。<br>每天重复的努力，最后变成了自我感动。却不肯承认自己有问题。拿着“我已经那么努力了，失败了也没有关系”做借口。</p>\n<h2 id=\"“我不知道自己想要什么”\"><a href=\"#“我不知道自己想要什么”\" class=\"headerlink\" title=\"“我不知道自己想要什么”\"></a>“我不知道自己想要什么”</h2><p>我不知道自己是个什么样的人，也不清楚自己的实力在哪。<br>我只是去做别人叫我去做的事情。或者说，我只是去做，大家都在做的事情。又或者说，我只是去做，在我看来最方便的事情。<br>于是，我选择了最好走的路。为一点小成就而沾沾自喜。选择了别人叫我走的路，有时候又因为心中萌生的那种自我觉醒而感到迷茫。选择了大家都在走的路，同样的，有时候因为那种突然的自我觉醒而感到迷茫。<br>好像写跑了，而且这也太真实了。这里更多地体现在我的大学生活里。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>“命运偷走如果，只留下结果。”<br>没有那么多如果，只有后悔吧。<br>写下这篇，希望自己不挂念过去，不去想那么多如果。过去的过不去了，未来也已经来了。踏踏实实地，做好眼前的事情。<br>自我觉醒是很难得的，萌生难得，发现难得，维持最难得。</p>\n<p>对了，我最近有了一个更明确的目标，或者说是梦想。</p>\n<p>这一次，不去相信奇迹，不去依靠运气，不去活成别人的期待。哪怕还是一场自我感动，我错也错得心甘情愿。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>三年前的今天，我做完了最后一份高三试卷。</p>","more":"<hr>\n<p>这三年之中，我时不时地会想起高考。真的心有不甘。<br>没有一个人会想到我数学只考了95。跟大学同学聊起来的时候，还有人问：“你们满分是150吗？”跟高中同学聊起来的时候，也会说：“你怎么才这么点？”每个人都说数学考砸了，可是没有一个考得比我差的。<br>虽然每次聊起来都是嘻嘻哈哈的，我却始终不甘心，一直以来也试图去找一个答案：“为什么？”<br>不知不觉三年了，这一次，我尝试着去回答自己。这些是我的思考，如果对你也有帮助，那就更好了。</p>\n<h2 id=\"“其实我从来没有真正地相信自己。”\"><a href=\"#“其实我从来没有真正地相信自己。”\" class=\"headerlink\" title=\"“其实我从来没有真正地相信自己。”\"></a>“其实我从来没有真正地相信自己。”</h2><p>我说我要上浙大，可是我不敢真的说出口。想着放在心里，等到实现的那一天，或者说等待奇迹。<br>我不是打心底地相信自己能。比起相信自己，我似乎更相信奇迹。甚至到了考试那天也是如此。我选择了相信奇迹，相信运气，而不是沉下心来，脚踏实地。<br>其实呢没有什么奇迹，也不该赖着好运。可以相信和依赖的，只有我自己。<br>班主任一天到晚和我们说着“踏实”，可惜了我到现在才理解“踏实”二字的含义。</p>\n<h2 id=\"“我的目标是努力”\"><a href=\"#“我的目标是努力”\" class=\"headerlink\" title=\"“我的目标是努力”\"></a>“我的目标是努力”</h2><p>上了高三之后的每一天，我几乎都在努力。我因为失意而自怜，也因为得意而自喜。<br>慢慢地，努力变成我的目标，却不去想努力能带给我什么，也忘了努力只是我实现目标的一个方式而已。<br>每天重复的努力，最后变成了自我感动。却不肯承认自己有问题。拿着“我已经那么努力了，失败了也没有关系”做借口。</p>\n<h2 id=\"“我不知道自己想要什么”\"><a href=\"#“我不知道自己想要什么”\" class=\"headerlink\" title=\"“我不知道自己想要什么”\"></a>“我不知道自己想要什么”</h2><p>我不知道自己是个什么样的人，也不清楚自己的实力在哪。<br>我只是去做别人叫我去做的事情。或者说，我只是去做，大家都在做的事情。又或者说，我只是去做，在我看来最方便的事情。<br>于是，我选择了最好走的路。为一点小成就而沾沾自喜。选择了别人叫我走的路，有时候又因为心中萌生的那种自我觉醒而感到迷茫。选择了大家都在走的路，同样的，有时候因为那种突然的自我觉醒而感到迷茫。<br>好像写跑了，而且这也太真实了。这里更多地体现在我的大学生活里。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>“命运偷走如果，只留下结果。”<br>没有那么多如果，只有后悔吧。<br>写下这篇，希望自己不挂念过去，不去想那么多如果。过去的过不去了，未来也已经来了。踏踏实实地，做好眼前的事情。<br>自我觉醒是很难得的，萌生难得，发现难得，维持最难得。</p>\n<p>对了，我最近有了一个更明确的目标，或者说是梦想。</p>\n<p>这一次，不去相信奇迹，不去依靠运气，不去活成别人的期待。哪怕还是一场自我感动，我错也错得心甘情愿。</p>"},{"title":"随感0705","date":"2018-07-05T12:14:53.000Z","_content":"Don't miss the happiness of your past life. Don't fear the sadness of your future life. Just do yourself and do what you want to do now.\n<!--more-->\n---\n开头是石雷老师在博客中写的一段话。今天无意间发现了老师的个人博客（ [傻子石](http://www.thunder10.com/) ）。看了之后很有感触，将近二十年的点点滴滴都记录在上面，是一个人的成长，也是时代变化的缩影。\n（我还发现了老师六级挂了五次哈哈哈）\n然后就想到了我自己和这个博客。仔细回想起来，二十年了都没有做成一件事情，更多的是空有豪情和半途而废。希望自己也能在这个博客下记录自己的成长吧！\n其实很多时候，自己都无法想象十年后二十年后的我会变成什么样。这种未知挺让人害怕的。嘛，走一步算一步吧！\n\n再附上中岛敦先生的一段话,最近很喜欢：\n> “因为害怕自己并非明珠而不敢刻苦雕琢，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍，遂逐渐远离世间，疏避人群，结果在内心不断地用愤懑和羞怒饲育着自己懦弱的自尊心。世上每个人都是驯兽师，而那匹猛兽，就是每人各自的性情。\n\n>  如今想起来，我真是空费了自己那一点仅有的才能，徒然在口头上卖弄着什么‘人生一事不为则太长，欲为一事则太短’的警句，可事实是，唯恐暴露才华不足的卑怯的畏惧，和厌恶钻营刻苦的惰怠，就是我的全部了。”\n\n最后，与君共勉。","source":"_posts/随感0705.md","raw":"---\ntitle: 随感0705\ndate: 2018-07-05 20:14:53\ncategories: 生活Life\n---\nDon't miss the happiness of your past life. Don't fear the sadness of your future life. Just do yourself and do what you want to do now.\n<!--more-->\n---\n开头是石雷老师在博客中写的一段话。今天无意间发现了老师的个人博客（ [傻子石](http://www.thunder10.com/) ）。看了之后很有感触，将近二十年的点点滴滴都记录在上面，是一个人的成长，也是时代变化的缩影。\n（我还发现了老师六级挂了五次哈哈哈）\n然后就想到了我自己和这个博客。仔细回想起来，二十年了都没有做成一件事情，更多的是空有豪情和半途而废。希望自己也能在这个博客下记录自己的成长吧！\n其实很多时候，自己都无法想象十年后二十年后的我会变成什么样。这种未知挺让人害怕的。嘛，走一步算一步吧！\n\n再附上中岛敦先生的一段话,最近很喜欢：\n> “因为害怕自己并非明珠而不敢刻苦雕琢，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍，遂逐渐远离世间，疏避人群，结果在内心不断地用愤懑和羞怒饲育着自己懦弱的自尊心。世上每个人都是驯兽师，而那匹猛兽，就是每人各自的性情。\n\n>  如今想起来，我真是空费了自己那一点仅有的才能，徒然在口头上卖弄着什么‘人生一事不为则太长，欲为一事则太短’的警句，可事实是，唯恐暴露才华不足的卑怯的畏惧，和厌恶钻营刻苦的惰怠，就是我的全部了。”\n\n最后，与君共勉。","slug":"随感0705","published":1,"updated":"2018-07-05T12:14:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1jeaghk003t38t4f9jp4119","content":"<p>Don’t miss the happiness of your past life. Don’t fear the sadness of your future life. Just do yourself and do what you want to do now.</p>\n<span id=\"more\"></span>\n<hr>\n<p>开头是石雷老师在博客中写的一段话。今天无意间发现了老师的个人博客（ <a href=\"http://www.thunder10.com/\">傻子石</a> ）。看了之后很有感触，将近二十年的点点滴滴都记录在上面，是一个人的成长，也是时代变化的缩影。<br>（我还发现了老师六级挂了五次哈哈哈）<br>然后就想到了我自己和这个博客。仔细回想起来，二十年了都没有做成一件事情，更多的是空有豪情和半途而废。希望自己也能在这个博客下记录自己的成长吧！<br>其实很多时候，自己都无法想象十年后二十年后的我会变成什么样。这种未知挺让人害怕的。嘛，走一步算一步吧！</p>\n<p>再附上中岛敦先生的一段话,最近很喜欢：</p>\n<blockquote>\n<p>“因为害怕自己并非明珠而不敢刻苦雕琢，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍，遂逐渐远离世间，疏避人群，结果在内心不断地用愤懑和羞怒饲育着自己懦弱的自尊心。世上每个人都是驯兽师，而那匹猛兽，就是每人各自的性情。</p>\n</blockquote>\n<blockquote>\n<p> 如今想起来，我真是空费了自己那一点仅有的才能，徒然在口头上卖弄着什么‘人生一事不为则太长，欲为一事则太短’的警句，可事实是，唯恐暴露才华不足的卑怯的畏惧，和厌恶钻营刻苦的惰怠，就是我的全部了。”</p>\n</blockquote>\n<p>最后，与君共勉。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>Don’t miss the happiness of your past life. Don’t fear the sadness of your future life. Just do yourself and do what you want to do now.</p>","more":"<hr>\n<p>开头是石雷老师在博客中写的一段话。今天无意间发现了老师的个人博客（ <a href=\"http://www.thunder10.com/\">傻子石</a> ）。看了之后很有感触，将近二十年的点点滴滴都记录在上面，是一个人的成长，也是时代变化的缩影。<br>（我还发现了老师六级挂了五次哈哈哈）<br>然后就想到了我自己和这个博客。仔细回想起来，二十年了都没有做成一件事情，更多的是空有豪情和半途而废。希望自己也能在这个博客下记录自己的成长吧！<br>其实很多时候，自己都无法想象十年后二十年后的我会变成什么样。这种未知挺让人害怕的。嘛，走一步算一步吧！</p>\n<p>再附上中岛敦先生的一段话,最近很喜欢：</p>\n<blockquote>\n<p>“因为害怕自己并非明珠而不敢刻苦雕琢，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍，遂逐渐远离世间，疏避人群，结果在内心不断地用愤懑和羞怒饲育着自己懦弱的自尊心。世上每个人都是驯兽师，而那匹猛兽，就是每人各自的性情。</p>\n</blockquote>\n<blockquote>\n<p> 如今想起来，我真是空费了自己那一点仅有的才能，徒然在口头上卖弄着什么‘人生一事不为则太长，欲为一事则太短’的警句，可事实是，唯恐暴露才华不足的卑怯的畏惧，和厌恶钻营刻苦的惰怠，就是我的全部了。”</p>\n</blockquote>\n<p>最后，与君共勉。</p>"},{"title":"随笔0325","date":"2022-03-25T15:31:59.000Z","_content":"\n照片在家附近拍的。上一次发布随笔还是在2019年6月，好久没有写东西了，很是生疏。\n\n<!--more-->\n\n“看了红豆与树的公众号，记录的满是喜悦与憧憬，却让人看得悲从中来。\n\n用尽全力去爱人。”\n\n这是我在3月22日，MU5735空难的第二天，写下的话。在我看到了红豆与树的公众号文章之后写下的，公众号的作者就在那架飞机上。公众号记录的，都是他与爱人的点点滴滴。他在公众号中写：未来，还要带着樹子小姐去看更多展。这是他们领证后的第四个月，未来好像才刚刚拉开序幕，却突然，戛然而止。\n\n今天是3月25日，虽然悲痛，但一切都在意料之中的：MU5735上无一生还，甚至连遗体也不见。我又找出了红豆与树的文章来看。有些人的生命就永远停留在了那一天。没有人知道明天和意外哪个来得更早一些。\n\n他留下了文章，文字成为了载体，回忆的载体，爱的载体。一个人对于整个世界来说可能微不足道，但对于另一个人来说可能是生命般的存在。我可以被世界遗忘，但是你，我的爱人，我希望我们的记忆永恒。\n\n爱是世界上最美好的事物。人与人之间的爱永远璀璨。爱可以是爱情，可以是亲情，可以是友情。所以我想对自己说，用尽全力去爱人。\n\n我们需要记录，不能忘了记录。文字和相片，都不能少。世间一切瞬息万变，很多事情很多感受，都会被时间冲刷得模模糊糊。希望自己一直在记录。\n\n今天久违地听了五月天的歌，却听得很想哭。2016年，我刚上大学，拉着我高中室友去上海听五月天演唱会。那是我第一次听五月天的演唱会，也是我第一次听演唱会。自那以后，从没追过星的我，把五月天每首歌的歌词都记了下来。又不知道是在哪一场的结尾，阿信拿着话筒说：“不知道下一次见面，你又会带着什么新的人生故事呢？”现在，我已经不再是窝在宿舍被窝和室友偷偷用MP3听《如烟》的小女孩了，我也不再是穿着stayrealT恤到处跑的女大学生了。我被更多的无奈缠住。我面对着自己可能存在了好几年但从未如此凸显的问题。我开始焦虑不安，开始依赖短视频、碎片信息和无脑游戏带来的短暂而刺激的快乐，开始晚上睡不好觉。我开始心理咨询，开始想办法自救，开始尝试不那么依赖别人，开始试着相信自己，开始学习与自己和解。\n\n我相信，一切都在好起来。不管我是不是真的相信，我都一定要一直对自己说：一切都在好起来。\n\n一切都在好起来，不是吗？\n\n——2022年3月25日深夜 于家中","source":"_posts/随笔0325.md","raw":"---\ntitle: 随笔0325\ndate: 2022-03-25 23:31:59\ncategories: 生活Life\nphoto: https://forlwq.oss-cn-hangzhou.aliyuncs.com/ying-hua-0325.jpg\n---\n\n照片在家附近拍的。上一次发布随笔还是在2019年6月，好久没有写东西了，很是生疏。\n\n<!--more-->\n\n“看了红豆与树的公众号，记录的满是喜悦与憧憬，却让人看得悲从中来。\n\n用尽全力去爱人。”\n\n这是我在3月22日，MU5735空难的第二天，写下的话。在我看到了红豆与树的公众号文章之后写下的，公众号的作者就在那架飞机上。公众号记录的，都是他与爱人的点点滴滴。他在公众号中写：未来，还要带着樹子小姐去看更多展。这是他们领证后的第四个月，未来好像才刚刚拉开序幕，却突然，戛然而止。\n\n今天是3月25日，虽然悲痛，但一切都在意料之中的：MU5735上无一生还，甚至连遗体也不见。我又找出了红豆与树的文章来看。有些人的生命就永远停留在了那一天。没有人知道明天和意外哪个来得更早一些。\n\n他留下了文章，文字成为了载体，回忆的载体，爱的载体。一个人对于整个世界来说可能微不足道，但对于另一个人来说可能是生命般的存在。我可以被世界遗忘，但是你，我的爱人，我希望我们的记忆永恒。\n\n爱是世界上最美好的事物。人与人之间的爱永远璀璨。爱可以是爱情，可以是亲情，可以是友情。所以我想对自己说，用尽全力去爱人。\n\n我们需要记录，不能忘了记录。文字和相片，都不能少。世间一切瞬息万变，很多事情很多感受，都会被时间冲刷得模模糊糊。希望自己一直在记录。\n\n今天久违地听了五月天的歌，却听得很想哭。2016年，我刚上大学，拉着我高中室友去上海听五月天演唱会。那是我第一次听五月天的演唱会，也是我第一次听演唱会。自那以后，从没追过星的我，把五月天每首歌的歌词都记了下来。又不知道是在哪一场的结尾，阿信拿着话筒说：“不知道下一次见面，你又会带着什么新的人生故事呢？”现在，我已经不再是窝在宿舍被窝和室友偷偷用MP3听《如烟》的小女孩了，我也不再是穿着stayrealT恤到处跑的女大学生了。我被更多的无奈缠住。我面对着自己可能存在了好几年但从未如此凸显的问题。我开始焦虑不安，开始依赖短视频、碎片信息和无脑游戏带来的短暂而刺激的快乐，开始晚上睡不好觉。我开始心理咨询，开始想办法自救，开始尝试不那么依赖别人，开始试着相信自己，开始学习与自己和解。\n\n我相信，一切都在好起来。不管我是不是真的相信，我都一定要一直对自己说：一切都在好起来。\n\n一切都在好起来，不是吗？\n\n——2022年3月25日深夜 于家中","slug":"随笔0325","published":1,"updated":"2022-03-25T15:31:59.000Z","photos":["https://forlwq.oss-cn-hangzhou.aliyuncs.com/ying-hua-0325.jpg"],"comments":1,"layout":"post","link":"","_id":"cl1jeaghl003u38t448l62ocz","content":"<p>照片在家附近拍的。上一次发布随笔还是在2019年6月，好久没有写东西了，很是生疏。</p>\n<span id=\"more\"></span>\n\n<p>“看了红豆与树的公众号，记录的满是喜悦与憧憬，却让人看得悲从中来。</p>\n<p>用尽全力去爱人。”</p>\n<p>这是我在3月22日，MU5735空难的第二天，写下的话。在我看到了红豆与树的公众号文章之后写下的，公众号的作者就在那架飞机上。公众号记录的，都是他与爱人的点点滴滴。他在公众号中写：未来，还要带着樹子小姐去看更多展。这是他们领证后的第四个月，未来好像才刚刚拉开序幕，却突然，戛然而止。</p>\n<p>今天是3月25日，虽然悲痛，但一切都在意料之中的：MU5735上无一生还，甚至连遗体也不见。我又找出了红豆与树的文章来看。有些人的生命就永远停留在了那一天。没有人知道明天和意外哪个来得更早一些。</p>\n<p>他留下了文章，文字成为了载体，回忆的载体，爱的载体。一个人对于整个世界来说可能微不足道，但对于另一个人来说可能是生命般的存在。我可以被世界遗忘，但是你，我的爱人，我希望我们的记忆永恒。</p>\n<p>爱是世界上最美好的事物。人与人之间的爱永远璀璨。爱可以是爱情，可以是亲情，可以是友情。所以我想对自己说，用尽全力去爱人。</p>\n<p>我们需要记录，不能忘了记录。文字和相片，都不能少。世间一切瞬息万变，很多事情很多感受，都会被时间冲刷得模模糊糊。希望自己一直在记录。</p>\n<p>今天久违地听了五月天的歌，却听得很想哭。2016年，我刚上大学，拉着我高中室友去上海听五月天演唱会。那是我第一次听五月天的演唱会，也是我第一次听演唱会。自那以后，从没追过星的我，把五月天每首歌的歌词都记了下来。又不知道是在哪一场的结尾，阿信拿着话筒说：“不知道下一次见面，你又会带着什么新的人生故事呢？”现在，我已经不再是窝在宿舍被窝和室友偷偷用MP3听《如烟》的小女孩了，我也不再是穿着stayrealT恤到处跑的女大学生了。我被更多的无奈缠住。我面对着自己可能存在了好几年但从未如此凸显的问题。我开始焦虑不安，开始依赖短视频、碎片信息和无脑游戏带来的短暂而刺激的快乐，开始晚上睡不好觉。我开始心理咨询，开始想办法自救，开始尝试不那么依赖别人，开始试着相信自己，开始学习与自己和解。</p>\n<p>我相信，一切都在好起来。不管我是不是真的相信，我都一定要一直对自己说：一切都在好起来。</p>\n<p>一切都在好起来，不是吗？</p>\n<p>——2022年3月25日深夜 于家中</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>照片在家附近拍的。上一次发布随笔还是在2019年6月，好久没有写东西了，很是生疏。</p>","more":"<p>“看了红豆与树的公众号，记录的满是喜悦与憧憬，却让人看得悲从中来。</p>\n<p>用尽全力去爱人。”</p>\n<p>这是我在3月22日，MU5735空难的第二天，写下的话。在我看到了红豆与树的公众号文章之后写下的，公众号的作者就在那架飞机上。公众号记录的，都是他与爱人的点点滴滴。他在公众号中写：未来，还要带着樹子小姐去看更多展。这是他们领证后的第四个月，未来好像才刚刚拉开序幕，却突然，戛然而止。</p>\n<p>今天是3月25日，虽然悲痛，但一切都在意料之中的：MU5735上无一生还，甚至连遗体也不见。我又找出了红豆与树的文章来看。有些人的生命就永远停留在了那一天。没有人知道明天和意外哪个来得更早一些。</p>\n<p>他留下了文章，文字成为了载体，回忆的载体，爱的载体。一个人对于整个世界来说可能微不足道，但对于另一个人来说可能是生命般的存在。我可以被世界遗忘，但是你，我的爱人，我希望我们的记忆永恒。</p>\n<p>爱是世界上最美好的事物。人与人之间的爱永远璀璨。爱可以是爱情，可以是亲情，可以是友情。所以我想对自己说，用尽全力去爱人。</p>\n<p>我们需要记录，不能忘了记录。文字和相片，都不能少。世间一切瞬息万变，很多事情很多感受，都会被时间冲刷得模模糊糊。希望自己一直在记录。</p>\n<p>今天久违地听了五月天的歌，却听得很想哭。2016年，我刚上大学，拉着我高中室友去上海听五月天演唱会。那是我第一次听五月天的演唱会，也是我第一次听演唱会。自那以后，从没追过星的我，把五月天每首歌的歌词都记了下来。又不知道是在哪一场的结尾，阿信拿着话筒说：“不知道下一次见面，你又会带着什么新的人生故事呢？”现在，我已经不再是窝在宿舍被窝和室友偷偷用MP3听《如烟》的小女孩了，我也不再是穿着stayrealT恤到处跑的女大学生了。我被更多的无奈缠住。我面对着自己可能存在了好几年但从未如此凸显的问题。我开始焦虑不安，开始依赖短视频、碎片信息和无脑游戏带来的短暂而刺激的快乐，开始晚上睡不好觉。我开始心理咨询，开始想办法自救，开始尝试不那么依赖别人，开始试着相信自己，开始学习与自己和解。</p>\n<p>我相信，一切都在好起来。不管我是不是真的相信，我都一定要一直对自己说：一切都在好起来。</p>\n<p>一切都在好起来，不是吗？</p>\n<p>——2022年3月25日深夜 于家中</p>"},{"title":"牛客后端项目（2）-注册模块开发","date":"2022-07-05T09:23:31.000Z","updated":"2022-07-05T09:23:31.000Z","_content":"\n好久没更新啦！搞完科研搞项目了！！\n\n<!--more-->\n\n# 使用Spring发送邮件\n\n用到的依赖：[Spring Boot Starter Mail](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail)\n\n步骤：\n1. 在application.properties中配置。主要要配置：host、username、password及安全传输相关的配置。配置和相关内容见官方spring文档[2.7.0版本](https://docs.spring.io/spring-boot/docs/2.7.0/reference/htmlsingle/#io.email)\n\n```properties\nspring.mail.host=smtp.163.com\nspring.mail.username=name\nspring.mail.password=psw\nspring.mail.protocol=smtps\nspring.mail.properties.mail.smtp.ssl.enable=true\nspring.mail.properties.mail.smtp.starttls.enable=true\nspring.mail.properties.mail.smtp.starttls.required=true\nspring.mail.properties.mail.smtp.auth=true\n```\n2. 构建发送邮件的工具类。主要用到的类是JavaMailSender。\n3. 发送邮件。主要用到的类是MimeMessage\n\n## Spring中的Value注解\n\n工具类中需要用到邮箱名字（即username）。Value注解的作用就是将配置中的属性读出来。有`@Value(\"${}\")`和`@Value(\"#{}\")`两种方式，前者读的是配置文件中的内容，后者是SpEL表达式对应的内容（如，某个bean的属性），详见：[spring的@Value注解使用_菊花超人的博客-CSDN](https://blog.csdn.net/woheniccc/article/details/79804600)\n\n## 问题解决\n\n在发送html格式的邮件时出现了乱码问题。而且在控制台输出结果时就乱码了，那么就不是传输过程中的编码问题。又试了别的html文件，发现输出是正常的。那就是这个文件可能在创建的时候用了别的编码，我把idea中文件编码格式全部换成UTF-8，然后重新创建一个html文件，就不乱码了。\n\n展示！嘿嘿~\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/1.png)\n\n# 注册模块的开发\n\n> 复杂业务开发过程中，可以根据请求来拆解。\n\n1. 跳转到注册页面\n2. 注册用户。（1）需要提供的信息（用户名、密码、邮箱）；（2）信息的约束（用户名和邮箱不允许重复）；（3）返回的结果（错误信息提示与注册成功的跳转\n3. 激活账号。\n\n## 跳转到注册页面\n\n用一个控制器转发请求即可\n\n## 注册用户☆\n按照三层架构根据自己的理解整理了流程，先开发Service层处理逻辑我感觉比较好。\n![三层要干的事儿](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/2.JPG)\n\n\n### Service层\n\n按上图写就是了~\n\n随机字符串生成：UUID\n密码加密：对字符串后面接一个salt，再用MD5加密，MD5特点是无法解密；Spring中有对应方法实现了md5\n\n#### 问题解决\n**RequestMapping的路径书写**\n关于开头斜线的问题。之前写Servlet的时候好像一定得加，但是在Spring中可加可不加。因为在Spring中，web容器启动的时候spring会扫描并根据Controller注解找到所有Handler类，并且会遍历这些类找到所有带RequestMapping的方法，在这个过程中会对没有加斜线的路径自动拼接斜线。\n参考：[注解RequestMapping中的URI路径最前面到底需不需要加斜线？_hehuijava的博客-CSDN](https://blog.csdn.net/hehuihh/article/details/117371593)\n\n**密码、邮箱的合法性验证应在前端还是后端**\n在实现模块的时候，感觉合法性验证在开发中应该在前端的位置，这样用户体验感更好（能马上收到反馈），那这样一般在后端是不是就不需要实现了？\n查了一下资料：一般在前端和后端都需要实现。前端为了用户体验，后端是数据处理的环节，必须对数据合法性进行保证以满足业务要求。\n[前端验证还是后端验证 - 简书](https://www.jianshu.com/p/30e352e25c80)\n\n**常量定义在类还是接口中？**\n在开发项目的时候需要为数字定义一个有含义的名字，就需要定义常量。我看的视频中老师用的方法是“常量接口模式”，但这种方法可能会导入一些用不到的常量。\n而接口中声明的默认就是`public static final`的常量类型，所以代码会更简洁。而且生成的.class文件比类更小。\n最佳实践：将常量定义在一个接口中，然后直接用`接口名.常量名`进行调用即可。\n参考：[关于 \"java中常量定义在interface中好还是定义在class中好\" 的一些思考_voo00oov的博客-CSDN](https://blog.csdn.net/voo00oov/article/details/50433672)\n\n**其他**\n在开发过程中，卡得最多的地方是thymeleaf🤣虽然说实际应用中前后端分离不太会用它，但现在卡着也多少有点浪费时间😅\n主要会卡的地方：1. 总忘记加`th:`！！！2. 别的暂时没想到\n另外，开发经验太少，总有种不敢写的感觉，写得一多就担心会出错。。慢慢来吧，这好像也没办法，这种思维是要锻炼的。\n\n- 区分“程序错误”与“业务逻辑错误”，前者throw异常，后者返回信息\n#### 还可以优化的地方\n1. 验证码过期失效问题\n2. 激活成功后跳转应该自动登录了。\n\n### Controller层\n\n向Service传user，调用注册方法，如果有错误信息就要向视图送，没有的话就重定向。这个也不太复杂。\n\n## 激活邮箱\n在注册模块完成了激活邮件的发送，链接是这样式儿的：\n`网站名/verify-email?uid=169&code=22e08a5605f14d30a534fa1d3f9e0dcf`\nget传的参数直接作为controller的参数名\n\n注意要判断是不是已经激活了等，几个状态考虑全就行。\n","source":"_posts/牛客后端项目（2）-注册模块开发.md","raw":"---\ntitle: 牛客后端项目（2）-注册模块开发\ndate: 2022-07-05 17:23:31\nupdated: 2022-07-05 17:23:31\ncategories: 项目开发笔记\ntags: 牛客网后端\n---\n\n好久没更新啦！搞完科研搞项目了！！\n\n<!--more-->\n\n# 使用Spring发送邮件\n\n用到的依赖：[Spring Boot Starter Mail](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail)\n\n步骤：\n1. 在application.properties中配置。主要要配置：host、username、password及安全传输相关的配置。配置和相关内容见官方spring文档[2.7.0版本](https://docs.spring.io/spring-boot/docs/2.7.0/reference/htmlsingle/#io.email)\n\n```properties\nspring.mail.host=smtp.163.com\nspring.mail.username=name\nspring.mail.password=psw\nspring.mail.protocol=smtps\nspring.mail.properties.mail.smtp.ssl.enable=true\nspring.mail.properties.mail.smtp.starttls.enable=true\nspring.mail.properties.mail.smtp.starttls.required=true\nspring.mail.properties.mail.smtp.auth=true\n```\n2. 构建发送邮件的工具类。主要用到的类是JavaMailSender。\n3. 发送邮件。主要用到的类是MimeMessage\n\n## Spring中的Value注解\n\n工具类中需要用到邮箱名字（即username）。Value注解的作用就是将配置中的属性读出来。有`@Value(\"${}\")`和`@Value(\"#{}\")`两种方式，前者读的是配置文件中的内容，后者是SpEL表达式对应的内容（如，某个bean的属性），详见：[spring的@Value注解使用_菊花超人的博客-CSDN](https://blog.csdn.net/woheniccc/article/details/79804600)\n\n## 问题解决\n\n在发送html格式的邮件时出现了乱码问题。而且在控制台输出结果时就乱码了，那么就不是传输过程中的编码问题。又试了别的html文件，发现输出是正常的。那就是这个文件可能在创建的时候用了别的编码，我把idea中文件编码格式全部换成UTF-8，然后重新创建一个html文件，就不乱码了。\n\n展示！嘿嘿~\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/1.png)\n\n# 注册模块的开发\n\n> 复杂业务开发过程中，可以根据请求来拆解。\n\n1. 跳转到注册页面\n2. 注册用户。（1）需要提供的信息（用户名、密码、邮箱）；（2）信息的约束（用户名和邮箱不允许重复）；（3）返回的结果（错误信息提示与注册成功的跳转\n3. 激活账号。\n\n## 跳转到注册页面\n\n用一个控制器转发请求即可\n\n## 注册用户☆\n按照三层架构根据自己的理解整理了流程，先开发Service层处理逻辑我感觉比较好。\n![三层要干的事儿](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/2.JPG)\n\n\n### Service层\n\n按上图写就是了~\n\n随机字符串生成：UUID\n密码加密：对字符串后面接一个salt，再用MD5加密，MD5特点是无法解密；Spring中有对应方法实现了md5\n\n#### 问题解决\n**RequestMapping的路径书写**\n关于开头斜线的问题。之前写Servlet的时候好像一定得加，但是在Spring中可加可不加。因为在Spring中，web容器启动的时候spring会扫描并根据Controller注解找到所有Handler类，并且会遍历这些类找到所有带RequestMapping的方法，在这个过程中会对没有加斜线的路径自动拼接斜线。\n参考：[注解RequestMapping中的URI路径最前面到底需不需要加斜线？_hehuijava的博客-CSDN](https://blog.csdn.net/hehuihh/article/details/117371593)\n\n**密码、邮箱的合法性验证应在前端还是后端**\n在实现模块的时候，感觉合法性验证在开发中应该在前端的位置，这样用户体验感更好（能马上收到反馈），那这样一般在后端是不是就不需要实现了？\n查了一下资料：一般在前端和后端都需要实现。前端为了用户体验，后端是数据处理的环节，必须对数据合法性进行保证以满足业务要求。\n[前端验证还是后端验证 - 简书](https://www.jianshu.com/p/30e352e25c80)\n\n**常量定义在类还是接口中？**\n在开发项目的时候需要为数字定义一个有含义的名字，就需要定义常量。我看的视频中老师用的方法是“常量接口模式”，但这种方法可能会导入一些用不到的常量。\n而接口中声明的默认就是`public static final`的常量类型，所以代码会更简洁。而且生成的.class文件比类更小。\n最佳实践：将常量定义在一个接口中，然后直接用`接口名.常量名`进行调用即可。\n参考：[关于 \"java中常量定义在interface中好还是定义在class中好\" 的一些思考_voo00oov的博客-CSDN](https://blog.csdn.net/voo00oov/article/details/50433672)\n\n**其他**\n在开发过程中，卡得最多的地方是thymeleaf🤣虽然说实际应用中前后端分离不太会用它，但现在卡着也多少有点浪费时间😅\n主要会卡的地方：1. 总忘记加`th:`！！！2. 别的暂时没想到\n另外，开发经验太少，总有种不敢写的感觉，写得一多就担心会出错。。慢慢来吧，这好像也没办法，这种思维是要锻炼的。\n\n- 区分“程序错误”与“业务逻辑错误”，前者throw异常，后者返回信息\n#### 还可以优化的地方\n1. 验证码过期失效问题\n2. 激活成功后跳转应该自动登录了。\n\n### Controller层\n\n向Service传user，调用注册方法，如果有错误信息就要向视图送，没有的话就重定向。这个也不太复杂。\n\n## 激活邮箱\n在注册模块完成了激活邮件的发送，链接是这样式儿的：\n`网站名/verify-email?uid=169&code=22e08a5605f14d30a534fa1d3f9e0dcf`\nget传的参数直接作为controller的参数名\n\n注意要判断是不是已经激活了等，几个状态考虑全就行。\n","slug":"牛客后端项目（2）-注册模块开发","published":1,"_id":"cl57yu4510000got48n3k9rvf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>好久没更新啦！搞完科研搞项目了！！</p>\n<span id=\"more\"></span>\n\n<h1 id=\"使用Spring发送邮件\"><a href=\"#使用Spring发送邮件\" class=\"headerlink\" title=\"使用Spring发送邮件\"></a>使用Spring发送邮件</h1><p>用到的依赖：<a href=\"https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail\">Spring Boot Starter Mail</a></p>\n<p>步骤：</p>\n<ol>\n<li>在application.properties中配置。主要要配置：host、username、password及安全传输相关的配置。配置和相关内容见官方spring文档<a href=\"https://docs.spring.io/spring-boot/docs/2.7.0/reference/htmlsingle/#io.email\">2.7.0版本</a></li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.mail.host</span>=<span class=\"string\">smtp.163.com</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.username</span>=<span class=\"string\">name</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.password</span>=<span class=\"string\">psw</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.protocol</span>=<span class=\"string\">smtps</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.properties.mail.smtp.ssl.enable</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.properties.mail.smtp.starttls.enable</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.properties.mail.smtp.starttls.required</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.properties.mail.smtp.auth</span>=<span class=\"string\">true</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>构建发送邮件的工具类。主要用到的类是JavaMailSender。</li>\n<li>发送邮件。主要用到的类是MimeMessage</li>\n</ol>\n<h2 id=\"Spring中的Value注解\"><a href=\"#Spring中的Value注解\" class=\"headerlink\" title=\"Spring中的Value注解\"></a>Spring中的Value注解</h2><p>工具类中需要用到邮箱名字（即username）。Value注解的作用就是将配置中的属性读出来。有<code>@Value(&quot;$&#123;&#125;&quot;)</code>和<code>@Value(&quot;#&#123;&#125;&quot;)</code>两种方式，前者读的是配置文件中的内容，后者是SpEL表达式对应的内容（如，某个bean的属性），详见：<a href=\"https://blog.csdn.net/woheniccc/article/details/79804600\">spring的@Value注解使用_菊花超人的博客-CSDN</a></p>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><p>在发送html格式的邮件时出现了乱码问题。而且在控制台输出结果时就乱码了，那么就不是传输过程中的编码问题。又试了别的html文件，发现输出是正常的。那就是这个文件可能在创建的时候用了别的编码，我把idea中文件编码格式全部换成UTF-8，然后重新创建一个html文件，就不乱码了。</p>\n<p>展示！嘿嘿~<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/1.png\" alt=\"Img\"></p>\n<h1 id=\"注册模块的开发\"><a href=\"#注册模块的开发\" class=\"headerlink\" title=\"注册模块的开发\"></a>注册模块的开发</h1><blockquote>\n<p>复杂业务开发过程中，可以根据请求来拆解。</p>\n</blockquote>\n<ol>\n<li>跳转到注册页面</li>\n<li>注册用户。（1）需要提供的信息（用户名、密码、邮箱）；（2）信息的约束（用户名和邮箱不允许重复）；（3）返回的结果（错误信息提示与注册成功的跳转</li>\n<li>激活账号。</li>\n</ol>\n<h2 id=\"跳转到注册页面\"><a href=\"#跳转到注册页面\" class=\"headerlink\" title=\"跳转到注册页面\"></a>跳转到注册页面</h2><p>用一个控制器转发请求即可</p>\n<h2 id=\"注册用户☆\"><a href=\"#注册用户☆\" class=\"headerlink\" title=\"注册用户☆\"></a>注册用户☆</h2><p>按照三层架构根据自己的理解整理了流程，先开发Service层处理逻辑我感觉比较好。<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/2.JPG\" alt=\"三层要干的事儿\"></p>\n<h3 id=\"Service层\"><a href=\"#Service层\" class=\"headerlink\" title=\"Service层\"></a>Service层</h3><p>按上图写就是了~</p>\n<p>随机字符串生成：UUID<br>密码加密：对字符串后面接一个salt，再用MD5加密，MD5特点是无法解密；Spring中有对应方法实现了md5</p>\n<h4 id=\"问题解决-1\"><a href=\"#问题解决-1\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h4><p><strong>RequestMapping的路径书写</strong><br>关于开头斜线的问题。之前写Servlet的时候好像一定得加，但是在Spring中可加可不加。因为在Spring中，web容器启动的时候spring会扫描并根据Controller注解找到所有Handler类，并且会遍历这些类找到所有带RequestMapping的方法，在这个过程中会对没有加斜线的路径自动拼接斜线。<br>参考：<a href=\"https://blog.csdn.net/hehuihh/article/details/117371593\">注解RequestMapping中的URI路径最前面到底需不需要加斜线？_hehuijava的博客-CSDN</a></p>\n<p><strong>密码、邮箱的合法性验证应在前端还是后端</strong><br>在实现模块的时候，感觉合法性验证在开发中应该在前端的位置，这样用户体验感更好（能马上收到反馈），那这样一般在后端是不是就不需要实现了？<br>查了一下资料：一般在前端和后端都需要实现。前端为了用户体验，后端是数据处理的环节，必须对数据合法性进行保证以满足业务要求。<br><a href=\"https://www.jianshu.com/p/30e352e25c80\">前端验证还是后端验证 - 简书</a></p>\n<p><strong>常量定义在类还是接口中？</strong><br>在开发项目的时候需要为数字定义一个有含义的名字，就需要定义常量。我看的视频中老师用的方法是“常量接口模式”，但这种方法可能会导入一些用不到的常量。<br>而接口中声明的默认就是<code>public static final</code>的常量类型，所以代码会更简洁。而且生成的.class文件比类更小。<br>最佳实践：将常量定义在一个接口中，然后直接用<code>接口名.常量名</code>进行调用即可。<br>参考：<a href=\"https://blog.csdn.net/voo00oov/article/details/50433672\">关于 “java中常量定义在interface中好还是定义在class中好” 的一些思考_voo00oov的博客-CSDN</a></p>\n<p><strong>其他</strong><br>在开发过程中，卡得最多的地方是thymeleaf🤣虽然说实际应用中前后端分离不太会用它，但现在卡着也多少有点浪费时间😅<br>主要会卡的地方：1. 总忘记加<code>th:</code>！！！2. 别的暂时没想到<br>另外，开发经验太少，总有种不敢写的感觉，写得一多就担心会出错。。慢慢来吧，这好像也没办法，这种思维是要锻炼的。</p>\n<ul>\n<li>区分“程序错误”与“业务逻辑错误”，前者throw异常，后者返回信息<h4 id=\"还可以优化的地方\"><a href=\"#还可以优化的地方\" class=\"headerlink\" title=\"还可以优化的地方\"></a>还可以优化的地方</h4></li>\n</ul>\n<ol>\n<li>验证码过期失效问题</li>\n<li>激活成功后跳转应该自动登录了。</li>\n</ol>\n<h3 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h3><p>向Service传user，调用注册方法，如果有错误信息就要向视图送，没有的话就重定向。这个也不太复杂。</p>\n<h2 id=\"激活邮箱\"><a href=\"#激活邮箱\" class=\"headerlink\" title=\"激活邮箱\"></a>激活邮箱</h2><p>在注册模块完成了激活邮件的发送，链接是这样式儿的：<br><code>网站名/verify-email?uid=169&amp;code=22e08a5605f14d30a534fa1d3f9e0dcf</code><br>get传的参数直接作为controller的参数名</p>\n<p>注意要判断是不是已经激活了等，几个状态考虑全就行。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>好久没更新啦！搞完科研搞项目了！！</p>","more":"<h1 id=\"使用Spring发送邮件\"><a href=\"#使用Spring发送邮件\" class=\"headerlink\" title=\"使用Spring发送邮件\"></a>使用Spring发送邮件</h1><p>用到的依赖：<a href=\"https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail\">Spring Boot Starter Mail</a></p>\n<p>步骤：</p>\n<ol>\n<li>在application.properties中配置。主要要配置：host、username、password及安全传输相关的配置。配置和相关内容见官方spring文档<a href=\"https://docs.spring.io/spring-boot/docs/2.7.0/reference/htmlsingle/#io.email\">2.7.0版本</a></li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.mail.host</span>=<span class=\"string\">smtp.163.com</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.username</span>=<span class=\"string\">name</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.password</span>=<span class=\"string\">psw</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.protocol</span>=<span class=\"string\">smtps</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.properties.mail.smtp.ssl.enable</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.properties.mail.smtp.starttls.enable</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.properties.mail.smtp.starttls.required</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"meta\">spring.mail.properties.mail.smtp.auth</span>=<span class=\"string\">true</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>构建发送邮件的工具类。主要用到的类是JavaMailSender。</li>\n<li>发送邮件。主要用到的类是MimeMessage</li>\n</ol>\n<h2 id=\"Spring中的Value注解\"><a href=\"#Spring中的Value注解\" class=\"headerlink\" title=\"Spring中的Value注解\"></a>Spring中的Value注解</h2><p>工具类中需要用到邮箱名字（即username）。Value注解的作用就是将配置中的属性读出来。有<code>@Value(&quot;$&#123;&#125;&quot;)</code>和<code>@Value(&quot;#&#123;&#125;&quot;)</code>两种方式，前者读的是配置文件中的内容，后者是SpEL表达式对应的内容（如，某个bean的属性），详见：<a href=\"https://blog.csdn.net/woheniccc/article/details/79804600\">spring的@Value注解使用_菊花超人的博客-CSDN</a></p>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><p>在发送html格式的邮件时出现了乱码问题。而且在控制台输出结果时就乱码了，那么就不是传输过程中的编码问题。又试了别的html文件，发现输出是正常的。那就是这个文件可能在创建的时候用了别的编码，我把idea中文件编码格式全部换成UTF-8，然后重新创建一个html文件，就不乱码了。</p>\n<p>展示！嘿嘿~<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/1.png\" alt=\"Img\"></p>\n<h1 id=\"注册模块的开发\"><a href=\"#注册模块的开发\" class=\"headerlink\" title=\"注册模块的开发\"></a>注册模块的开发</h1><blockquote>\n<p>复杂业务开发过程中，可以根据请求来拆解。</p>\n</blockquote>\n<ol>\n<li>跳转到注册页面</li>\n<li>注册用户。（1）需要提供的信息（用户名、密码、邮箱）；（2）信息的约束（用户名和邮箱不允许重复）；（3）返回的结果（错误信息提示与注册成功的跳转</li>\n<li>激活账号。</li>\n</ol>\n<h2 id=\"跳转到注册页面\"><a href=\"#跳转到注册页面\" class=\"headerlink\" title=\"跳转到注册页面\"></a>跳转到注册页面</h2><p>用一个控制器转发请求即可</p>\n<h2 id=\"注册用户☆\"><a href=\"#注册用户☆\" class=\"headerlink\" title=\"注册用户☆\"></a>注册用户☆</h2><p>按照三层架构根据自己的理解整理了流程，先开发Service层处理逻辑我感觉比较好。<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/2.JPG\" alt=\"三层要干的事儿\"></p>\n<h3 id=\"Service层\"><a href=\"#Service层\" class=\"headerlink\" title=\"Service层\"></a>Service层</h3><p>按上图写就是了~</p>\n<p>随机字符串生成：UUID<br>密码加密：对字符串后面接一个salt，再用MD5加密，MD5特点是无法解密；Spring中有对应方法实现了md5</p>\n<h4 id=\"问题解决-1\"><a href=\"#问题解决-1\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h4><p><strong>RequestMapping的路径书写</strong><br>关于开头斜线的问题。之前写Servlet的时候好像一定得加，但是在Spring中可加可不加。因为在Spring中，web容器启动的时候spring会扫描并根据Controller注解找到所有Handler类，并且会遍历这些类找到所有带RequestMapping的方法，在这个过程中会对没有加斜线的路径自动拼接斜线。<br>参考：<a href=\"https://blog.csdn.net/hehuihh/article/details/117371593\">注解RequestMapping中的URI路径最前面到底需不需要加斜线？_hehuijava的博客-CSDN</a></p>\n<p><strong>密码、邮箱的合法性验证应在前端还是后端</strong><br>在实现模块的时候，感觉合法性验证在开发中应该在前端的位置，这样用户体验感更好（能马上收到反馈），那这样一般在后端是不是就不需要实现了？<br>查了一下资料：一般在前端和后端都需要实现。前端为了用户体验，后端是数据处理的环节，必须对数据合法性进行保证以满足业务要求。<br><a href=\"https://www.jianshu.com/p/30e352e25c80\">前端验证还是后端验证 - 简书</a></p>\n<p><strong>常量定义在类还是接口中？</strong><br>在开发项目的时候需要为数字定义一个有含义的名字，就需要定义常量。我看的视频中老师用的方法是“常量接口模式”，但这种方法可能会导入一些用不到的常量。<br>而接口中声明的默认就是<code>public static final</code>的常量类型，所以代码会更简洁。而且生成的.class文件比类更小。<br>最佳实践：将常量定义在一个接口中，然后直接用<code>接口名.常量名</code>进行调用即可。<br>参考：<a href=\"https://blog.csdn.net/voo00oov/article/details/50433672\">关于 “java中常量定义在interface中好还是定义在class中好” 的一些思考_voo00oov的博客-CSDN</a></p>\n<p><strong>其他</strong><br>在开发过程中，卡得最多的地方是thymeleaf🤣虽然说实际应用中前后端分离不太会用它，但现在卡着也多少有点浪费时间😅<br>主要会卡的地方：1. 总忘记加<code>th:</code>！！！2. 别的暂时没想到<br>另外，开发经验太少，总有种不敢写的感觉，写得一多就担心会出错。。慢慢来吧，这好像也没办法，这种思维是要锻炼的。</p>\n<ul>\n<li>区分“程序错误”与“业务逻辑错误”，前者throw异常，后者返回信息<h4 id=\"还可以优化的地方\"><a href=\"#还可以优化的地方\" class=\"headerlink\" title=\"还可以优化的地方\"></a>还可以优化的地方</h4></li>\n</ul>\n<ol>\n<li>验证码过期失效问题</li>\n<li>激活成功后跳转应该自动登录了。</li>\n</ol>\n<h3 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h3><p>向Service传user，调用注册方法，如果有错误信息就要向视图送，没有的话就重定向。这个也不太复杂。</p>\n<h2 id=\"激活邮箱\"><a href=\"#激活邮箱\" class=\"headerlink\" title=\"激活邮箱\"></a>激活邮箱</h2><p>在注册模块完成了激活邮件的发送，链接是这样式儿的：<br><code>网站名/verify-email?uid=169&amp;code=22e08a5605f14d30a534fa1d3f9e0dcf</code><br>get传的参数直接作为controller的参数名</p>\n<p>注意要判断是不是已经激活了等，几个状态考虑全就行。</p>"},{"title":"牛客后端项目（3）-登录模块开发","date":"2022-07-08T08:22:07.000Z","updated":"2022-07-08T08:22:07.000Z","_content":"\n登录模块，比注册做起来熟练了，项目开发中的小细节很多\n\n<!--more-->\n\n# 会话管理\n\nCookie是HTTP的标准，Session是JavaEE的标准，Session还是基于Cookie的。\n\n**设置Cookie**：一个cookie是一个键值对，需要对response添加cookie才会送到浏览器去。生存时间默认是关了浏览器就不在了。\n\n**设置Session**：SpringMVC的控制器方法中作为参数直接获得，首次访问服务器时会生成一个sessionId并作为cookie保存到浏览器，下一次访问服务器时会携带这个sessionId对session内容进行读取\n\nSession在**分布式服务器**遇到的问题：分布式服务器一般会使用负载均衡策略，当浏览器首次访问时，假设此时在服务器A上创建了一个Session，而浏览器再次访问时可能会由其他服务器B进行处理，而服务器B可能没有session，此时就会出错。\n解决办法：\n1. 对于同一个浏览器请求，每次由同一个服务器处理。缺点：有悖“负载均衡”\n2. 在所有服务器上都有一个Session备份。缺点：同步耗时、占用空间\n3. 把所有Session存在一个单体服务器上。缺点：有悖“分布式”，只能访问一个服务器不仅会产生性能瓶颈，还有挂掉的风险\n4. **将数据放到数据库上，同时为了减小例如Mysql数据库要读硬盘的性能影响，用NoSql数据库，如Redis。**\n\n\n# 登录模块\n\n**需求**：用户输入用户名、密码、验证码，进行验证与登录。\n\n设计一个数据结构来记录登录状态，ticket作为登录凭证，用expired记录过期时间，login_ticket表结构\n字段名：id, user_id, ticket, status, expired\n\n![登录流程图](./FILES/牛客后端项目（3）-登录模块开发.md/img-20220708145518.JPG)\n\n跟着流程写就行，注意：\n1. 验证码在controller处判断即可，如果有错可以提前返回；\n2. “记住我”选项，无非就是控制登录有效时间的长短；\n3. 合法性判断不要漏情况了\n\n## 密码加密问题\n\n看视频的时候下面有同学留言说前端向后端传输时的密码依然可以被抓包，于是去查了一下资料。\n1. 后端的加密是必须的，不然一旦数据泄露，数据库信息就是裸露的，密码就透露出去了。后端的操作聚焦于密码存储的安全性。\n2. 虽然使用https传输时是密文传输，但中间人可以通过伪造证书来抓包。此时可以在前端用一个加密，比如RSA\n参考：[目前主流靠谱的登录密码加密流程是怎样的？ - SegmentFault 思否](https://segmentfault.com/q/1010000014454702)\n\n# 显示登录信息\n\n需求：导航栏功能显示会与登录状态相关，eg. 登录后就不显示注册功能了；登录后才显示个人信息。\n\n## 拦截器\n\n当很多请求都需要完成相同的功能时，可以用spring中的拦截器拦截请求进行处理。\n\n拦截器，实现接口HandlerInterceptor，有三个方法preHandle、postHandle、afterCompletion，分别是进入控制器前，控制器完成后而视图解析前，全部完成后。\n\n### 问题\n1. 每次请求时都要新建一个ThreadLocal来放User，这样性能影响会大吗？\nThreadLocal创建一个线程局部变量，可以说就是个变量，不会很大影响性能的。\n\n2. 拦截器与过滤器的区别\n在JavaWeb中学过过滤器，想了一下不知道两者有啥区别，查了资料，看得一知半解...：\n[过滤器 和 拦截器 6个区别，别再傻傻分不清了 - SegmentFault 思否](https://segmentfault.com/a/1190000022833940)\n\n\n# 账号设置\n\n## 上传头像\n\n一些细节：\n1. 在表单处声明文件类型，multipart/form-data\n2. 用SpringMVC的Multipartfile方法，然后这个方法是视图层的，所以不要写到Service层了。\n3. 图像存在服务器，但是访问时是根据web访问路径。根据web访问路径的话需要有特定的控制器来处理。\n4. 在读取图像的时候，可以设置一个缓冲区来输出，能快一点\n\n\n### 图像合法性验证\n\n参考：[在SpringBoot中验证用户上传的图片资源 - 掘金](https://juejin.cn/post/6850418117882052615)\n\n\n\n## 密码修改\n\nService：输入userid、原密码和新密码，判断原密码和数据库中的是否相等；相等再继续，向数据库中修改新密码。\n\n# 检查登录状态\n\n需求：有的页面如果没登录是不能访问的，如账号设置等，一个一个页面添加规则有点麻烦，可以对**需要拦截的方法**进行注解。然后在拦截器中对这些被注解的方法进行拦截。\n\n- 项目中有多个拦截器时，按照注册顺序来执行\n\n自定义注解时用元注解来注解。\n常用元注解：@Target, @Retenion, @Document, @Inherited。前两个是必须的，Target描述注解的范围，即注解可以用在哪。Retention用于描述注解的生命周期，表示需要在什么级别保存该注解，即保留的时间长短\n参考：[Java 元注解 - 傻不拉几猫 - 博客园](https://www.cnblogs.com/kingsonfu/p/10634174.html)\n\n\n\n","source":"_posts/牛客后端项目（3）-登录模块开发.md","raw":"---\ntitle: 牛客后端项目（3）-登录模块开发\ndate: 2022-07-08 16:22:07\nupdated: 2022-07-08 16:22:07\ncategories: 项目开发笔记\ntags: 牛客网后端\n---\n\n登录模块，比注册做起来熟练了，项目开发中的小细节很多\n\n<!--more-->\n\n# 会话管理\n\nCookie是HTTP的标准，Session是JavaEE的标准，Session还是基于Cookie的。\n\n**设置Cookie**：一个cookie是一个键值对，需要对response添加cookie才会送到浏览器去。生存时间默认是关了浏览器就不在了。\n\n**设置Session**：SpringMVC的控制器方法中作为参数直接获得，首次访问服务器时会生成一个sessionId并作为cookie保存到浏览器，下一次访问服务器时会携带这个sessionId对session内容进行读取\n\nSession在**分布式服务器**遇到的问题：分布式服务器一般会使用负载均衡策略，当浏览器首次访问时，假设此时在服务器A上创建了一个Session，而浏览器再次访问时可能会由其他服务器B进行处理，而服务器B可能没有session，此时就会出错。\n解决办法：\n1. 对于同一个浏览器请求，每次由同一个服务器处理。缺点：有悖“负载均衡”\n2. 在所有服务器上都有一个Session备份。缺点：同步耗时、占用空间\n3. 把所有Session存在一个单体服务器上。缺点：有悖“分布式”，只能访问一个服务器不仅会产生性能瓶颈，还有挂掉的风险\n4. **将数据放到数据库上，同时为了减小例如Mysql数据库要读硬盘的性能影响，用NoSql数据库，如Redis。**\n\n\n# 登录模块\n\n**需求**：用户输入用户名、密码、验证码，进行验证与登录。\n\n设计一个数据结构来记录登录状态，ticket作为登录凭证，用expired记录过期时间，login_ticket表结构\n字段名：id, user_id, ticket, status, expired\n\n![登录流程图](./FILES/牛客后端项目（3）-登录模块开发.md/img-20220708145518.JPG)\n\n跟着流程写就行，注意：\n1. 验证码在controller处判断即可，如果有错可以提前返回；\n2. “记住我”选项，无非就是控制登录有效时间的长短；\n3. 合法性判断不要漏情况了\n\n## 密码加密问题\n\n看视频的时候下面有同学留言说前端向后端传输时的密码依然可以被抓包，于是去查了一下资料。\n1. 后端的加密是必须的，不然一旦数据泄露，数据库信息就是裸露的，密码就透露出去了。后端的操作聚焦于密码存储的安全性。\n2. 虽然使用https传输时是密文传输，但中间人可以通过伪造证书来抓包。此时可以在前端用一个加密，比如RSA\n参考：[目前主流靠谱的登录密码加密流程是怎样的？ - SegmentFault 思否](https://segmentfault.com/q/1010000014454702)\n\n# 显示登录信息\n\n需求：导航栏功能显示会与登录状态相关，eg. 登录后就不显示注册功能了；登录后才显示个人信息。\n\n## 拦截器\n\n当很多请求都需要完成相同的功能时，可以用spring中的拦截器拦截请求进行处理。\n\n拦截器，实现接口HandlerInterceptor，有三个方法preHandle、postHandle、afterCompletion，分别是进入控制器前，控制器完成后而视图解析前，全部完成后。\n\n### 问题\n1. 每次请求时都要新建一个ThreadLocal来放User，这样性能影响会大吗？\nThreadLocal创建一个线程局部变量，可以说就是个变量，不会很大影响性能的。\n\n2. 拦截器与过滤器的区别\n在JavaWeb中学过过滤器，想了一下不知道两者有啥区别，查了资料，看得一知半解...：\n[过滤器 和 拦截器 6个区别，别再傻傻分不清了 - SegmentFault 思否](https://segmentfault.com/a/1190000022833940)\n\n\n# 账号设置\n\n## 上传头像\n\n一些细节：\n1. 在表单处声明文件类型，multipart/form-data\n2. 用SpringMVC的Multipartfile方法，然后这个方法是视图层的，所以不要写到Service层了。\n3. 图像存在服务器，但是访问时是根据web访问路径。根据web访问路径的话需要有特定的控制器来处理。\n4. 在读取图像的时候，可以设置一个缓冲区来输出，能快一点\n\n\n### 图像合法性验证\n\n参考：[在SpringBoot中验证用户上传的图片资源 - 掘金](https://juejin.cn/post/6850418117882052615)\n\n\n\n## 密码修改\n\nService：输入userid、原密码和新密码，判断原密码和数据库中的是否相等；相等再继续，向数据库中修改新密码。\n\n# 检查登录状态\n\n需求：有的页面如果没登录是不能访问的，如账号设置等，一个一个页面添加规则有点麻烦，可以对**需要拦截的方法**进行注解。然后在拦截器中对这些被注解的方法进行拦截。\n\n- 项目中有多个拦截器时，按照注册顺序来执行\n\n自定义注解时用元注解来注解。\n常用元注解：@Target, @Retenion, @Document, @Inherited。前两个是必须的，Target描述注解的范围，即注解可以用在哪。Retention用于描述注解的生命周期，表示需要在什么级别保存该注解，即保留的时间长短\n参考：[Java 元注解 - 傻不拉几猫 - 博客园](https://www.cnblogs.com/kingsonfu/p/10634174.html)\n\n\n\n","slug":"牛客后端项目（3）-登录模块开发","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl5c6xktr0000cct49ouq31m2","content":"<p>登录模块，比注册做起来熟练了，项目开发中的小细节很多</p>\n<span id=\"more\"></span>\n\n<h1 id=\"会话管理\"><a href=\"#会话管理\" class=\"headerlink\" title=\"会话管理\"></a>会话管理</h1><p>Cookie是HTTP的标准，Session是JavaEE的标准，Session还是基于Cookie的。</p>\n<p><strong>设置Cookie</strong>：一个cookie是一个键值对，需要对response添加cookie才会送到浏览器去。生存时间默认是关了浏览器就不在了。</p>\n<p><strong>设置Session</strong>：SpringMVC的控制器方法中作为参数直接获得，首次访问服务器时会生成一个sessionId并作为cookie保存到浏览器，下一次访问服务器时会携带这个sessionId对session内容进行读取</p>\n<p>Session在<strong>分布式服务器</strong>遇到的问题：分布式服务器一般会使用负载均衡策略，当浏览器首次访问时，假设此时在服务器A上创建了一个Session，而浏览器再次访问时可能会由其他服务器B进行处理，而服务器B可能没有session，此时就会出错。<br>解决办法：</p>\n<ol>\n<li>对于同一个浏览器请求，每次由同一个服务器处理。缺点：有悖“负载均衡”</li>\n<li>在所有服务器上都有一个Session备份。缺点：同步耗时、占用空间</li>\n<li>把所有Session存在一个单体服务器上。缺点：有悖“分布式”，只能访问一个服务器不仅会产生性能瓶颈，还有挂掉的风险</li>\n<li><strong>将数据放到数据库上，同时为了减小例如Mysql数据库要读硬盘的性能影响，用NoSql数据库，如Redis。</strong></li>\n</ol>\n<h1 id=\"登录模块\"><a href=\"#登录模块\" class=\"headerlink\" title=\"登录模块\"></a>登录模块</h1><p><strong>需求</strong>：用户输入用户名、密码、验证码，进行验证与登录。</p>\n<p>设计一个数据结构来记录登录状态，ticket作为登录凭证，用expired记录过期时间，login_ticket表结构<br>字段名：id, user_id, ticket, status, expired</p>\n<p><img src=\"./FILES/%E7%89%9B%E5%AE%A2%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%EF%BC%883%EF%BC%89-%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91.md/img-20220708145518.JPG\" alt=\"登录流程图\"></p>\n<p>跟着流程写就行，注意：</p>\n<ol>\n<li>验证码在controller处判断即可，如果有错可以提前返回；</li>\n<li>“记住我”选项，无非就是控制登录有效时间的长短；</li>\n<li>合法性判断不要漏情况了</li>\n</ol>\n<h2 id=\"密码加密问题\"><a href=\"#密码加密问题\" class=\"headerlink\" title=\"密码加密问题\"></a>密码加密问题</h2><p>看视频的时候下面有同学留言说前端向后端传输时的密码依然可以被抓包，于是去查了一下资料。</p>\n<ol>\n<li>后端的加密是必须的，不然一旦数据泄露，数据库信息就是裸露的，密码就透露出去了。后端的操作聚焦于密码存储的安全性。</li>\n<li>虽然使用https传输时是密文传输，但中间人可以通过伪造证书来抓包。此时可以在前端用一个加密，比如RSA<br>参考：<a href=\"https://segmentfault.com/q/1010000014454702\">目前主流靠谱的登录密码加密流程是怎样的？ - SegmentFault 思否</a></li>\n</ol>\n<h1 id=\"显示登录信息\"><a href=\"#显示登录信息\" class=\"headerlink\" title=\"显示登录信息\"></a>显示登录信息</h1><p>需求：导航栏功能显示会与登录状态相关，eg. 登录后就不显示注册功能了；登录后才显示个人信息。</p>\n<h2 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h2><p>当很多请求都需要完成相同的功能时，可以用spring中的拦截器拦截请求进行处理。</p>\n<p>拦截器，实现接口HandlerInterceptor，有三个方法preHandle、postHandle、afterCompletion，分别是进入控制器前，控制器完成后而视图解析前，全部完成后。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ol>\n<li><p>每次请求时都要新建一个ThreadLocal来放User，这样性能影响会大吗？<br>ThreadLocal创建一个线程局部变量，可以说就是个变量，不会很大影响性能的。</p>\n</li>\n<li><p>拦截器与过滤器的区别<br>在JavaWeb中学过过滤器，想了一下不知道两者有啥区别，查了资料，看得一知半解…：<br><a href=\"https://segmentfault.com/a/1190000022833940\">过滤器 和 拦截器 6个区别，别再傻傻分不清了 - SegmentFault 思否</a></p>\n</li>\n</ol>\n<h1 id=\"账号设置\"><a href=\"#账号设置\" class=\"headerlink\" title=\"账号设置\"></a>账号设置</h1><h2 id=\"上传头像\"><a href=\"#上传头像\" class=\"headerlink\" title=\"上传头像\"></a>上传头像</h2><p>一些细节：</p>\n<ol>\n<li>在表单处声明文件类型，multipart/form-data</li>\n<li>用SpringMVC的Multipartfile方法，然后这个方法是视图层的，所以不要写到Service层了。</li>\n<li>图像存在服务器，但是访问时是根据web访问路径。根据web访问路径的话需要有特定的控制器来处理。</li>\n<li>在读取图像的时候，可以设置一个缓冲区来输出，能快一点</li>\n</ol>\n<h3 id=\"图像合法性验证\"><a href=\"#图像合法性验证\" class=\"headerlink\" title=\"图像合法性验证\"></a>图像合法性验证</h3><p>参考：<a href=\"https://juejin.cn/post/6850418117882052615\">在SpringBoot中验证用户上传的图片资源 - 掘金</a></p>\n<h2 id=\"密码修改\"><a href=\"#密码修改\" class=\"headerlink\" title=\"密码修改\"></a>密码修改</h2><p>Service：输入userid、原密码和新密码，判断原密码和数据库中的是否相等；相等再继续，向数据库中修改新密码。</p>\n<h1 id=\"检查登录状态\"><a href=\"#检查登录状态\" class=\"headerlink\" title=\"检查登录状态\"></a>检查登录状态</h1><p>需求：有的页面如果没登录是不能访问的，如账号设置等，一个一个页面添加规则有点麻烦，可以对<strong>需要拦截的方法</strong>进行注解。然后在拦截器中对这些被注解的方法进行拦截。</p>\n<ul>\n<li>项目中有多个拦截器时，按照注册顺序来执行</li>\n</ul>\n<p>自定义注解时用元注解来注解。<br>常用元注解：@Target, @Retenion, @Document, @Inherited。前两个是必须的，Target描述注解的范围，即注解可以用在哪。Retention用于描述注解的生命周期，表示需要在什么级别保存该注解，即保留的时间长短<br>参考：<a href=\"https://www.cnblogs.com/kingsonfu/p/10634174.html\">Java 元注解 - 傻不拉几猫 - 博客园</a></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>登录模块，比注册做起来熟练了，项目开发中的小细节很多</p>","more":"<h1 id=\"会话管理\"><a href=\"#会话管理\" class=\"headerlink\" title=\"会话管理\"></a>会话管理</h1><p>Cookie是HTTP的标准，Session是JavaEE的标准，Session还是基于Cookie的。</p>\n<p><strong>设置Cookie</strong>：一个cookie是一个键值对，需要对response添加cookie才会送到浏览器去。生存时间默认是关了浏览器就不在了。</p>\n<p><strong>设置Session</strong>：SpringMVC的控制器方法中作为参数直接获得，首次访问服务器时会生成一个sessionId并作为cookie保存到浏览器，下一次访问服务器时会携带这个sessionId对session内容进行读取</p>\n<p>Session在<strong>分布式服务器</strong>遇到的问题：分布式服务器一般会使用负载均衡策略，当浏览器首次访问时，假设此时在服务器A上创建了一个Session，而浏览器再次访问时可能会由其他服务器B进行处理，而服务器B可能没有session，此时就会出错。<br>解决办法：</p>\n<ol>\n<li>对于同一个浏览器请求，每次由同一个服务器处理。缺点：有悖“负载均衡”</li>\n<li>在所有服务器上都有一个Session备份。缺点：同步耗时、占用空间</li>\n<li>把所有Session存在一个单体服务器上。缺点：有悖“分布式”，只能访问一个服务器不仅会产生性能瓶颈，还有挂掉的风险</li>\n<li><strong>将数据放到数据库上，同时为了减小例如Mysql数据库要读硬盘的性能影响，用NoSql数据库，如Redis。</strong></li>\n</ol>\n<h1 id=\"登录模块\"><a href=\"#登录模块\" class=\"headerlink\" title=\"登录模块\"></a>登录模块</h1><p><strong>需求</strong>：用户输入用户名、密码、验证码，进行验证与登录。</p>\n<p>设计一个数据结构来记录登录状态，ticket作为登录凭证，用expired记录过期时间，login_ticket表结构<br>字段名：id, user_id, ticket, status, expired</p>\n<p><img src=\"./FILES/%E7%89%9B%E5%AE%A2%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%EF%BC%883%EF%BC%89-%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91.md/img-20220708145518.JPG\" alt=\"登录流程图\"></p>\n<p>跟着流程写就行，注意：</p>\n<ol>\n<li>验证码在controller处判断即可，如果有错可以提前返回；</li>\n<li>“记住我”选项，无非就是控制登录有效时间的长短；</li>\n<li>合法性判断不要漏情况了</li>\n</ol>\n<h2 id=\"密码加密问题\"><a href=\"#密码加密问题\" class=\"headerlink\" title=\"密码加密问题\"></a>密码加密问题</h2><p>看视频的时候下面有同学留言说前端向后端传输时的密码依然可以被抓包，于是去查了一下资料。</p>\n<ol>\n<li>后端的加密是必须的，不然一旦数据泄露，数据库信息就是裸露的，密码就透露出去了。后端的操作聚焦于密码存储的安全性。</li>\n<li>虽然使用https传输时是密文传输，但中间人可以通过伪造证书来抓包。此时可以在前端用一个加密，比如RSA<br>参考：<a href=\"https://segmentfault.com/q/1010000014454702\">目前主流靠谱的登录密码加密流程是怎样的？ - SegmentFault 思否</a></li>\n</ol>\n<h1 id=\"显示登录信息\"><a href=\"#显示登录信息\" class=\"headerlink\" title=\"显示登录信息\"></a>显示登录信息</h1><p>需求：导航栏功能显示会与登录状态相关，eg. 登录后就不显示注册功能了；登录后才显示个人信息。</p>\n<h2 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h2><p>当很多请求都需要完成相同的功能时，可以用spring中的拦截器拦截请求进行处理。</p>\n<p>拦截器，实现接口HandlerInterceptor，有三个方法preHandle、postHandle、afterCompletion，分别是进入控制器前，控制器完成后而视图解析前，全部完成后。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ol>\n<li><p>每次请求时都要新建一个ThreadLocal来放User，这样性能影响会大吗？<br>ThreadLocal创建一个线程局部变量，可以说就是个变量，不会很大影响性能的。</p>\n</li>\n<li><p>拦截器与过滤器的区别<br>在JavaWeb中学过过滤器，想了一下不知道两者有啥区别，查了资料，看得一知半解…：<br><a href=\"https://segmentfault.com/a/1190000022833940\">过滤器 和 拦截器 6个区别，别再傻傻分不清了 - SegmentFault 思否</a></p>\n</li>\n</ol>\n<h1 id=\"账号设置\"><a href=\"#账号设置\" class=\"headerlink\" title=\"账号设置\"></a>账号设置</h1><h2 id=\"上传头像\"><a href=\"#上传头像\" class=\"headerlink\" title=\"上传头像\"></a>上传头像</h2><p>一些细节：</p>\n<ol>\n<li>在表单处声明文件类型，multipart/form-data</li>\n<li>用SpringMVC的Multipartfile方法，然后这个方法是视图层的，所以不要写到Service层了。</li>\n<li>图像存在服务器，但是访问时是根据web访问路径。根据web访问路径的话需要有特定的控制器来处理。</li>\n<li>在读取图像的时候，可以设置一个缓冲区来输出，能快一点</li>\n</ol>\n<h3 id=\"图像合法性验证\"><a href=\"#图像合法性验证\" class=\"headerlink\" title=\"图像合法性验证\"></a>图像合法性验证</h3><p>参考：<a href=\"https://juejin.cn/post/6850418117882052615\">在SpringBoot中验证用户上传的图片资源 - 掘金</a></p>\n<h2 id=\"密码修改\"><a href=\"#密码修改\" class=\"headerlink\" title=\"密码修改\"></a>密码修改</h2><p>Service：输入userid、原密码和新密码，判断原密码和数据库中的是否相等；相等再继续，向数据库中修改新密码。</p>\n<h1 id=\"检查登录状态\"><a href=\"#检查登录状态\" class=\"headerlink\" title=\"检查登录状态\"></a>检查登录状态</h1><p>需求：有的页面如果没登录是不能访问的，如账号设置等，一个一个页面添加规则有点麻烦，可以对<strong>需要拦截的方法</strong>进行注解。然后在拦截器中对这些被注解的方法进行拦截。</p>\n<ul>\n<li>项目中有多个拦截器时，按照注册顺序来执行</li>\n</ul>\n<p>自定义注解时用元注解来注解。<br>常用元注解：@Target, @Retenion, @Document, @Inherited。前两个是必须的，Target描述注解的范围，即注解可以用在哪。Retention用于描述注解的生命周期，表示需要在什么级别保存该注解，即保留的时间长短<br>参考：<a href=\"https://www.cnblogs.com/kingsonfu/p/10634174.html\">Java 元注解 - 傻不拉几猫 - 博客园</a></p>"},{"title":"牛客后端项目（4）-帖子模块开发","date":"2022-07-25T03:42:47.000Z","updated":"2022-07-25T03:42:47.000Z","_content":"\n核心功能开发完成~\n\n<!--more-->\n\n# 过滤敏感词\n\nTrie树\n树的节点包括：子节点（用Map<String, TrieNode>表示），是否是单词结尾的标志（boolean isEnd）\n两个关键方法：\n1. 向Trie树添加字符串\n2. 对字符串进行敏感词过滤（要注意start指针要一位一位移动，否则会漏判，除了start-end是一个敏感词，start直接跳到end+1）\n\n\n- 注意要跳过敏感词中的符号，比如❤福❤彩❤：\n用`CharUtils.isAsciiAlphanumeric`判断字符是否是0-9a-zA-Z范围内（[参考文档](https://www.educative.io/answers/what-is-charutilsisasciialphanumeric-in-java)），以及是否是0x2e80~0x9FF之间（这是东亚文字的区间）\n\n# 发布帖子\n\n## AJAX\n\n1. 在页面中引入jQuery：\n```xml\n<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\" crossorigin=\"anonymous\"></script>\n```\n2. 页面中写异步请求发送的方法，举个例子：\n```js\nfunction send(){\n    $.post(\n        \"/community/ajax\",\n        {\"name\": \"liz\", \"age\": 24},\n        function (data){\n            console.log(typeof data);\n            console.log(data);\n\n            data = $.parseJSON(data);\n            console.log(typeof data);\n            console.log(data);\n        }\n    );\n}\n```\n\n## 发布帖子\ndao层：insert方法\nservice层：处理标题和内容，insert\ncontroller层：从前端获取title和content，创建DiscussPost对象，之后调用service，返回是否成功的结果\n视图：处理返回结果，发布成功时刷新，失败时留在发布界面\n注意：\n1. 帖子的标题和内容需要合法性处理\n2. 帖子内容如果有html标签，要转义一下，避免内容对页面的损害。用`HtmlUtils.htmlEscape`方法即可\n\n# 帖子详情\n\ndao：selectById方法\nservice：调用dao的selectById方法\ncontroller：postId在路径中传，调用service的select方法，找到的DiscussPost和相关的User对象，送入Model，传到前端视图中显示。\n\n# 事务\n\n事务：一组操作，要么全部执行，要么全部不执行\n四个性质：ACID，原子性、一致性、隔离性、持久性\n隔离性：事务与事务之间的操作是相互隔离的。主要解决**并发异常**问题。\n**常见的并发异常**：1. 第一类丢失更新、第二类丢失更新；2. 脏读、不可重复度、幻读\n**常见的隔离级别**：\nRead Uncommitted\nRead Committed\n\n## 并发异常问题与事务隔离级别\n**第一类丢失更新**：事务A和事务B同时对同一个数据操作，事务A更新完了，但是事务B发现进行了回滚，那么对于事务A的更新就丢失了。（B回滚导致A丢失）\n图片来源：[牛客网课程](https://www.nowcoder.com/study/live/246/3/13)\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153249.png)\n\n**第二类丢失更新**：\nB提交导致A丢失\n图片来源：[牛客网课程](https://www.nowcoder.com/study/live/246/3/13)\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153432.png)\n\n**脏读**：事务A读了事务B还**没有提交但修改**了的数据\n\n**不可重复读**：事务B在修改数据，事务A两次读同一个数据但读到了**不一样**的数据。\n\n**幻读**：事务B在插入数据，事务A两次读但是读到了**不一样多**的数据\n\n**事务隔离级别**：\nY表示问题会出现，N表示问题不会出现\n图片来源：[牛客网课程](https://www.nowcoder.com/study/live/246/3/13)\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153824.png)\n\n## 实现机制-锁🔒\n\n**数据库自带：悲观锁**（即出现并发就一定会有问题，所以一定要加锁）\n1. 共享锁（S锁）：事务A对数据加了共享锁后，其他事务只能加共享锁，不能加排它锁\n2. 排它锁（X锁）：事务A对数据加了排他锁后，其他事务什么锁都不能加\n\n**自定义：乐观锁**（即认为出现并发不一定会有问题）\n用时间戳或版本号等来实现。当要更新数据的时候，发现版本号发生变化了，就取消更新，不然就更新数据（当然也要更新一下版本号）。\n\n扩展：[MVCC到底是什么？这一篇博客就够啦_flying$的博客-CSDN](https://blog.csdn.net/flying_hengfei/article/details/106965517)\n[MySQL中MVCC的正确打开方式（源码佐证）_Waves___的博客-CSDN博客](https://blog.csdn.net/Waves___/article/details/105295060)\n\n## Spring的事务管理\n\n对任意数据库，有一套统一的API来使用🙆‍♀️\n两种实现方法：1. 声明式，通过xml或注解配置；2.编程式，通过TransactionTemplate，再用接口回调。\n\n@Transactinoal\nisolation选择事务隔离等级\npropagation选择事务传播机制，一个方法同时调用serviceA和serivceB，如果涉及事务就需要考虑A和B之间事务的关系是什么\nREQUIRED：保持当前事务，如果没有则创建新事务\nREQUIRES_NEW：创建新事务，并暂停当前事务\nNESTED：如果存在当前事务，则嵌套在其中执行（对B会有单独的提交和回滚）；没有就和REQUIRED一样\n\n更多Propagation的解读：[spring事务-说说Propagation及其实现原理_那个天真的人的博客-CSDN](https://blog.csdn.net/yanyan19880509/article/details/53041564)\n\n# 显示评论\n\n**数据结构**：设计一张表来保存所有评论，由于帖子、帖子的评论都可以有评论，为了减少冗余，把它们都存放在同一张表里，并用`entity type`来指明是帖子或评论的评论，`entity id`指明（帖子或评论的）id\n\n**dao**：（1）用`entity type`和`entity id`查询评论列表（分页）；（2）用`entity type`和`entity id`查询评论数量\n**service**：读取某个帖子对应的所有评论，注意评论中还有对某个评论的回复。\n**controller**：通过访问/discuss/{discussPostId}来访问所有评论，用service读，注意要**分页**，replyList就不用了。设计一个ViewObject返回要显示在网页上的内容，用List保存评论`commentList`，其中每个元素是一个map，包括一条评论所有相关的内容，即评论内容`comment`、发表评论的用户`user`（需要用户名、id和headerUrl）、该评论的回复`replyList`，其中`replyList`是和`commentList`相同的结构，用for循环保存起来，需要注意的是回复有`target id`，即回复的是哪一条评论。另外还要保存replyList的评论数量，commentList的数量可以用discussPost.commentCount来读取，省得在数据库中搜索浪费时间了。\n\n注意：\n- 视图处理上要仔细，别的没啥。难点在于返回网页的内容处理上\n\n## 问题解决\n\n 1. controller层和service层的内容，该交给哪个层去完成感觉总是弄混。比如说这里要封装一个给视图显示的viewObject。为什么不交给Service层去处理？我的理解：Service层应具有高可复用性，如果交给service去处理的话，返回一个视图显示对象，这是不太合理的。\n\n# 回复评论\n\ndao层：插入一条评论；更新帖子的回复数量\nservice层：DiscussPostService更新帖子的回复数量。CommentService插入一条评论（注意要html转义、敏感词处理）、调用DiscussPostService方法更新帖子的回复数量。\n视图层：controller得到comment，前端传回content、targetId、entityType、entityId，剩下的补充一下。调用service方法完成添加评论后要重定向到当前页面，从而进行刷新。\n\n注意：\n- CommentService的插入评论方法，同时对数据库有两次修改，需要放在一个**事务**中处理。\n\n# 私信\n\n数据结构：message表，`from_id`和`to_id`分别表示发送用户和接受用户；为了便于查询，将两者拼接为一个字符串表示会话id即`conversation_id`；其他还有创建时间、内容、状态。注意用户之间的会话，两者不分谁发送谁接收，这个会话是他们共有的。\n\n## 私信列表\n\n私信列表包括朋友私信和系统通知，两者逻辑可以复用。\n对于朋友私信而言，列表的每一个元素是一个用户，显示该用户头像、用户名（User），以及最近一次会话的内容和时间（Message），以及所有会话数量和未读会话数量。整个列表是当前用户拥有的所有会话（无论当前用户是发送方还是接收方）\n推出dao层需要的方法：\n1. UserMapper：根据id查询用户\n2. MessageMapper：（1）分页查询会话中的最近一次消息（用会话id和limit）；（2）查询和某个用户之间的会话数量（用会话id和status）；（3）为了分页，查询该用户的所有未删除的会话数量（用userId和status）\n\nservice：直接把dao层封装一下\ncontroller：封装一个传给视图层的列表\n\n**注意**：\n1. 在统计未读消息的时候，只有对于接收方是未读的消息才要统计，对于发送方而言这条消息不是未读的！\n2. 在写sql语句的时候，因为只需要会话中的最近一次消息，用max(id)并按照conversationId分组即可\n\n## 私信详情\n\n即一个会话的多个消息。用分页展示。其他和私信列表类似。私信的信息注意用户保存的是发送方，可以提前保存起来。\n\n## 发送私信\n\ndao：insert一条message\nservice：内容的合法性要处理，\n\n# 统一的异常处理\n\n1. 用户登录验证。有些方法只有在用户登录之后才可以使用（如回帖、发消息等）\n2. 不存在的网页（404）和服务器出错的网页（500）\n\n## 用户登录验证\n\n使用**拦截器Interceptor**，对需要登录才可以继续的方法进行拦截。为了方便，可以对这些方法统一使用相同的注释来标记（eg. LoginRequired)，在拦截器中判断方法是否包含该注释，再判断用户是否已登录，如果没有登录就重定向到登录页。\n\n## 404和500页面\n\n直接把404页面放到template/error文件夹下面，spring会自动处理。如果没有使用模板引擎，就可以把404页面放到error文件夹中，error文件夹再放到static文件夹下即可。\n\n而对于500页面，是服务器异常，我们需要把这些异常记录到日志中去，不能直接交给spring boot自动处理。\n我们使用@ControllerAdvice注解定义一个新的类，从而统一扩增控制器的功能。@ControllerAdvice注解和@ExceptionHandler搭配使用，可以统一处理异常。而@ControllerAdvice中的参数可以指定需要对哪些控制器进行功能增强，如`@ControllerAdvice(annotations = Controller.class)`对标有Controller注解的所有类进行增强。\n\n# 统一的日志记录\n\n## AOP\n\n面向切面编程。是一种OOP编程的扩展。将项目中多个模块共有的业务看做一个切面，如下图所示（图片来源：[牛客网课程](https://www.nowcoder.com/study/live/246/3/33)）\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220720111820.png)\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220725110805.png)\n\nJoinpoint：连接点，指明aspect是在哪个位置织入。可以是属性或方法等。\nTarget：目标对象，Spring中就是一个Bean\nWeaving（织入）：有三种织入方式，分别是（1）编译时织入；（2）装载时织入；（3）运行时织入\nAspect：方面组件，我理解是在要实现的统一方法是什么（如我们要实现的就是日志这个功能）。其中由包括Pointcut和Advice，前者说明这个Aspect可以在哪里加入，后者是具体逻辑。\n\n## AOP的实现\n\n1. AspectJ：是一种扩展了Java的**新语言**；在**编译时**进行织入\n2. Spring AOP：用Java实现；在**运行时**通过动态代理进行织入；但只支持方法类型的连接点\n\n## 日志功能\n\n用Spring AOP来实现。\nSpring AOP的代理有两种方式：\n1. JDK动态代理。是默认方法；如果target是接口，就用JDK动态代理来进行织入\n2. CGLib动态代理。在没有接口的情况下，就用这个方式来代理\n\n具体实现：\n1. 类用@Component、@Aspect标注。\n2. 定义切入点：`@Pointcut(\"execution(* com.nowcoder.community.service.*.*(..))\")`\n3. 定义通知逻辑。根据在织入点前后处理，可以分为Before、AfterReturning，以及Around、AfterThrowing等\n\n","source":"_posts/牛客后端项目（4）-帖子模块开发.md","raw":"---\ntitle: 牛客后端项目（4）-帖子模块开发\ndate: 2022-07-25 11:42:47\nupdated: 2022-07-25 11:42:47\ncategories: 项目开发笔记\ntags: 牛客网后端\n---\n\n核心功能开发完成~\n\n<!--more-->\n\n# 过滤敏感词\n\nTrie树\n树的节点包括：子节点（用Map<String, TrieNode>表示），是否是单词结尾的标志（boolean isEnd）\n两个关键方法：\n1. 向Trie树添加字符串\n2. 对字符串进行敏感词过滤（要注意start指针要一位一位移动，否则会漏判，除了start-end是一个敏感词，start直接跳到end+1）\n\n\n- 注意要跳过敏感词中的符号，比如❤福❤彩❤：\n用`CharUtils.isAsciiAlphanumeric`判断字符是否是0-9a-zA-Z范围内（[参考文档](https://www.educative.io/answers/what-is-charutilsisasciialphanumeric-in-java)），以及是否是0x2e80~0x9FF之间（这是东亚文字的区间）\n\n# 发布帖子\n\n## AJAX\n\n1. 在页面中引入jQuery：\n```xml\n<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\" crossorigin=\"anonymous\"></script>\n```\n2. 页面中写异步请求发送的方法，举个例子：\n```js\nfunction send(){\n    $.post(\n        \"/community/ajax\",\n        {\"name\": \"liz\", \"age\": 24},\n        function (data){\n            console.log(typeof data);\n            console.log(data);\n\n            data = $.parseJSON(data);\n            console.log(typeof data);\n            console.log(data);\n        }\n    );\n}\n```\n\n## 发布帖子\ndao层：insert方法\nservice层：处理标题和内容，insert\ncontroller层：从前端获取title和content，创建DiscussPost对象，之后调用service，返回是否成功的结果\n视图：处理返回结果，发布成功时刷新，失败时留在发布界面\n注意：\n1. 帖子的标题和内容需要合法性处理\n2. 帖子内容如果有html标签，要转义一下，避免内容对页面的损害。用`HtmlUtils.htmlEscape`方法即可\n\n# 帖子详情\n\ndao：selectById方法\nservice：调用dao的selectById方法\ncontroller：postId在路径中传，调用service的select方法，找到的DiscussPost和相关的User对象，送入Model，传到前端视图中显示。\n\n# 事务\n\n事务：一组操作，要么全部执行，要么全部不执行\n四个性质：ACID，原子性、一致性、隔离性、持久性\n隔离性：事务与事务之间的操作是相互隔离的。主要解决**并发异常**问题。\n**常见的并发异常**：1. 第一类丢失更新、第二类丢失更新；2. 脏读、不可重复度、幻读\n**常见的隔离级别**：\nRead Uncommitted\nRead Committed\n\n## 并发异常问题与事务隔离级别\n**第一类丢失更新**：事务A和事务B同时对同一个数据操作，事务A更新完了，但是事务B发现进行了回滚，那么对于事务A的更新就丢失了。（B回滚导致A丢失）\n图片来源：[牛客网课程](https://www.nowcoder.com/study/live/246/3/13)\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153249.png)\n\n**第二类丢失更新**：\nB提交导致A丢失\n图片来源：[牛客网课程](https://www.nowcoder.com/study/live/246/3/13)\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153432.png)\n\n**脏读**：事务A读了事务B还**没有提交但修改**了的数据\n\n**不可重复读**：事务B在修改数据，事务A两次读同一个数据但读到了**不一样**的数据。\n\n**幻读**：事务B在插入数据，事务A两次读但是读到了**不一样多**的数据\n\n**事务隔离级别**：\nY表示问题会出现，N表示问题不会出现\n图片来源：[牛客网课程](https://www.nowcoder.com/study/live/246/3/13)\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153824.png)\n\n## 实现机制-锁🔒\n\n**数据库自带：悲观锁**（即出现并发就一定会有问题，所以一定要加锁）\n1. 共享锁（S锁）：事务A对数据加了共享锁后，其他事务只能加共享锁，不能加排它锁\n2. 排它锁（X锁）：事务A对数据加了排他锁后，其他事务什么锁都不能加\n\n**自定义：乐观锁**（即认为出现并发不一定会有问题）\n用时间戳或版本号等来实现。当要更新数据的时候，发现版本号发生变化了，就取消更新，不然就更新数据（当然也要更新一下版本号）。\n\n扩展：[MVCC到底是什么？这一篇博客就够啦_flying$的博客-CSDN](https://blog.csdn.net/flying_hengfei/article/details/106965517)\n[MySQL中MVCC的正确打开方式（源码佐证）_Waves___的博客-CSDN博客](https://blog.csdn.net/Waves___/article/details/105295060)\n\n## Spring的事务管理\n\n对任意数据库，有一套统一的API来使用🙆‍♀️\n两种实现方法：1. 声明式，通过xml或注解配置；2.编程式，通过TransactionTemplate，再用接口回调。\n\n@Transactinoal\nisolation选择事务隔离等级\npropagation选择事务传播机制，一个方法同时调用serviceA和serivceB，如果涉及事务就需要考虑A和B之间事务的关系是什么\nREQUIRED：保持当前事务，如果没有则创建新事务\nREQUIRES_NEW：创建新事务，并暂停当前事务\nNESTED：如果存在当前事务，则嵌套在其中执行（对B会有单独的提交和回滚）；没有就和REQUIRED一样\n\n更多Propagation的解读：[spring事务-说说Propagation及其实现原理_那个天真的人的博客-CSDN](https://blog.csdn.net/yanyan19880509/article/details/53041564)\n\n# 显示评论\n\n**数据结构**：设计一张表来保存所有评论，由于帖子、帖子的评论都可以有评论，为了减少冗余，把它们都存放在同一张表里，并用`entity type`来指明是帖子或评论的评论，`entity id`指明（帖子或评论的）id\n\n**dao**：（1）用`entity type`和`entity id`查询评论列表（分页）；（2）用`entity type`和`entity id`查询评论数量\n**service**：读取某个帖子对应的所有评论，注意评论中还有对某个评论的回复。\n**controller**：通过访问/discuss/{discussPostId}来访问所有评论，用service读，注意要**分页**，replyList就不用了。设计一个ViewObject返回要显示在网页上的内容，用List保存评论`commentList`，其中每个元素是一个map，包括一条评论所有相关的内容，即评论内容`comment`、发表评论的用户`user`（需要用户名、id和headerUrl）、该评论的回复`replyList`，其中`replyList`是和`commentList`相同的结构，用for循环保存起来，需要注意的是回复有`target id`，即回复的是哪一条评论。另外还要保存replyList的评论数量，commentList的数量可以用discussPost.commentCount来读取，省得在数据库中搜索浪费时间了。\n\n注意：\n- 视图处理上要仔细，别的没啥。难点在于返回网页的内容处理上\n\n## 问题解决\n\n 1. controller层和service层的内容，该交给哪个层去完成感觉总是弄混。比如说这里要封装一个给视图显示的viewObject。为什么不交给Service层去处理？我的理解：Service层应具有高可复用性，如果交给service去处理的话，返回一个视图显示对象，这是不太合理的。\n\n# 回复评论\n\ndao层：插入一条评论；更新帖子的回复数量\nservice层：DiscussPostService更新帖子的回复数量。CommentService插入一条评论（注意要html转义、敏感词处理）、调用DiscussPostService方法更新帖子的回复数量。\n视图层：controller得到comment，前端传回content、targetId、entityType、entityId，剩下的补充一下。调用service方法完成添加评论后要重定向到当前页面，从而进行刷新。\n\n注意：\n- CommentService的插入评论方法，同时对数据库有两次修改，需要放在一个**事务**中处理。\n\n# 私信\n\n数据结构：message表，`from_id`和`to_id`分别表示发送用户和接受用户；为了便于查询，将两者拼接为一个字符串表示会话id即`conversation_id`；其他还有创建时间、内容、状态。注意用户之间的会话，两者不分谁发送谁接收，这个会话是他们共有的。\n\n## 私信列表\n\n私信列表包括朋友私信和系统通知，两者逻辑可以复用。\n对于朋友私信而言，列表的每一个元素是一个用户，显示该用户头像、用户名（User），以及最近一次会话的内容和时间（Message），以及所有会话数量和未读会话数量。整个列表是当前用户拥有的所有会话（无论当前用户是发送方还是接收方）\n推出dao层需要的方法：\n1. UserMapper：根据id查询用户\n2. MessageMapper：（1）分页查询会话中的最近一次消息（用会话id和limit）；（2）查询和某个用户之间的会话数量（用会话id和status）；（3）为了分页，查询该用户的所有未删除的会话数量（用userId和status）\n\nservice：直接把dao层封装一下\ncontroller：封装一个传给视图层的列表\n\n**注意**：\n1. 在统计未读消息的时候，只有对于接收方是未读的消息才要统计，对于发送方而言这条消息不是未读的！\n2. 在写sql语句的时候，因为只需要会话中的最近一次消息，用max(id)并按照conversationId分组即可\n\n## 私信详情\n\n即一个会话的多个消息。用分页展示。其他和私信列表类似。私信的信息注意用户保存的是发送方，可以提前保存起来。\n\n## 发送私信\n\ndao：insert一条message\nservice：内容的合法性要处理，\n\n# 统一的异常处理\n\n1. 用户登录验证。有些方法只有在用户登录之后才可以使用（如回帖、发消息等）\n2. 不存在的网页（404）和服务器出错的网页（500）\n\n## 用户登录验证\n\n使用**拦截器Interceptor**，对需要登录才可以继续的方法进行拦截。为了方便，可以对这些方法统一使用相同的注释来标记（eg. LoginRequired)，在拦截器中判断方法是否包含该注释，再判断用户是否已登录，如果没有登录就重定向到登录页。\n\n## 404和500页面\n\n直接把404页面放到template/error文件夹下面，spring会自动处理。如果没有使用模板引擎，就可以把404页面放到error文件夹中，error文件夹再放到static文件夹下即可。\n\n而对于500页面，是服务器异常，我们需要把这些异常记录到日志中去，不能直接交给spring boot自动处理。\n我们使用@ControllerAdvice注解定义一个新的类，从而统一扩增控制器的功能。@ControllerAdvice注解和@ExceptionHandler搭配使用，可以统一处理异常。而@ControllerAdvice中的参数可以指定需要对哪些控制器进行功能增强，如`@ControllerAdvice(annotations = Controller.class)`对标有Controller注解的所有类进行增强。\n\n# 统一的日志记录\n\n## AOP\n\n面向切面编程。是一种OOP编程的扩展。将项目中多个模块共有的业务看做一个切面，如下图所示（图片来源：[牛客网课程](https://www.nowcoder.com/study/live/246/3/33)）\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220720111820.png)\n![Img](https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220725110805.png)\n\nJoinpoint：连接点，指明aspect是在哪个位置织入。可以是属性或方法等。\nTarget：目标对象，Spring中就是一个Bean\nWeaving（织入）：有三种织入方式，分别是（1）编译时织入；（2）装载时织入；（3）运行时织入\nAspect：方面组件，我理解是在要实现的统一方法是什么（如我们要实现的就是日志这个功能）。其中由包括Pointcut和Advice，前者说明这个Aspect可以在哪里加入，后者是具体逻辑。\n\n## AOP的实现\n\n1. AspectJ：是一种扩展了Java的**新语言**；在**编译时**进行织入\n2. Spring AOP：用Java实现；在**运行时**通过动态代理进行织入；但只支持方法类型的连接点\n\n## 日志功能\n\n用Spring AOP来实现。\nSpring AOP的代理有两种方式：\n1. JDK动态代理。是默认方法；如果target是接口，就用JDK动态代理来进行织入\n2. CGLib动态代理。在没有接口的情况下，就用这个方式来代理\n\n具体实现：\n1. 类用@Component、@Aspect标注。\n2. 定义切入点：`@Pointcut(\"execution(* com.nowcoder.community.service.*.*(..))\")`\n3. 定义通知逻辑。根据在织入点前后处理，可以分为Before、AfterReturning，以及Around、AfterThrowing等\n\n","slug":"牛客后端项目（4）-帖子模块开发","published":1,"_id":"cl607fqzw000044t45ki0hwao","comments":1,"layout":"post","photos":[],"link":"","content":"<p>核心功能开发完成~</p>\n<span id=\"more\"></span>\n\n<h1 id=\"过滤敏感词\"><a href=\"#过滤敏感词\" class=\"headerlink\" title=\"过滤敏感词\"></a>过滤敏感词</h1><p>Trie树<br>树的节点包括：子节点（用Map&lt;String, TrieNode&gt;表示），是否是单词结尾的标志（boolean isEnd）<br>两个关键方法：</p>\n<ol>\n<li>向Trie树添加字符串</li>\n<li>对字符串进行敏感词过滤（要注意start指针要一位一位移动，否则会漏判，除了start-end是一个敏感词，start直接跳到end+1）</li>\n</ol>\n<ul>\n<li>注意要跳过敏感词中的符号，比如❤福❤彩❤：<br>用<code>CharUtils.isAsciiAlphanumeric</code>判断字符是否是0-9a-zA-Z范围内（<a href=\"https://www.educative.io/answers/what-is-charutilsisasciialphanumeric-in-java\">参考文档</a>），以及是否是0x2e80~0x9FF之间（这是东亚文字的区间）</li>\n</ul>\n<h1 id=\"发布帖子\"><a href=\"#发布帖子\" class=\"headerlink\" title=\"发布帖子\"></a>发布帖子</h1><h2 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h2><ol>\n<li>在页面中引入jQuery：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;</span> <span class=\"attr\">crossorigin</span>=<span class=\"string\">&quot;anonymous&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>页面中写异步请求发送的方法，举个例子：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">send</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    $.post(</span><br><span class=\"line\">        <span class=\"string\">&quot;/community/ajax&quot;</span>,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;liz&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">24</span>&#125;,</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> data);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\"></span><br><span class=\"line\">            data = $.parseJSON(data);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> data);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"发布帖子-1\"><a href=\"#发布帖子-1\" class=\"headerlink\" title=\"发布帖子\"></a>发布帖子</h2><p>dao层：insert方法<br>service层：处理标题和内容，insert<br>controller层：从前端获取title和content，创建DiscussPost对象，之后调用service，返回是否成功的结果<br>视图：处理返回结果，发布成功时刷新，失败时留在发布界面<br>注意：</p>\n<ol>\n<li>帖子的标题和内容需要合法性处理</li>\n<li>帖子内容如果有html标签，要转义一下，避免内容对页面的损害。用<code>HtmlUtils.htmlEscape</code>方法即可</li>\n</ol>\n<h1 id=\"帖子详情\"><a href=\"#帖子详情\" class=\"headerlink\" title=\"帖子详情\"></a>帖子详情</h1><p>dao：selectById方法<br>service：调用dao的selectById方法<br>controller：postId在路径中传，调用service的select方法，找到的DiscussPost和相关的User对象，送入Model，传到前端视图中显示。</p>\n<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><p>事务：一组操作，要么全部执行，要么全部不执行<br>四个性质：ACID，原子性、一致性、隔离性、持久性<br>隔离性：事务与事务之间的操作是相互隔离的。主要解决<strong>并发异常</strong>问题。<br><strong>常见的并发异常</strong>：1. 第一类丢失更新、第二类丢失更新；2. 脏读、不可重复度、幻读<br><strong>常见的隔离级别</strong>：<br>Read Uncommitted<br>Read Committed</p>\n<h2 id=\"并发异常问题与事务隔离级别\"><a href=\"#并发异常问题与事务隔离级别\" class=\"headerlink\" title=\"并发异常问题与事务隔离级别\"></a>并发异常问题与事务隔离级别</h2><p><strong>第一类丢失更新</strong>：事务A和事务B同时对同一个数据操作，事务A更新完了，但是事务B发现进行了回滚，那么对于事务A的更新就丢失了。（B回滚导致A丢失）<br>图片来源：<a href=\"https://www.nowcoder.com/study/live/246/3/13\">牛客网课程</a><br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153249.png\" alt=\"Img\"></p>\n<p><strong>第二类丢失更新</strong>：<br>B提交导致A丢失<br>图片来源：<a href=\"https://www.nowcoder.com/study/live/246/3/13\">牛客网课程</a><br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153432.png\" alt=\"Img\"></p>\n<p><strong>脏读</strong>：事务A读了事务B还<strong>没有提交但修改</strong>了的数据</p>\n<p><strong>不可重复读</strong>：事务B在修改数据，事务A两次读同一个数据但读到了<strong>不一样</strong>的数据。</p>\n<p><strong>幻读</strong>：事务B在插入数据，事务A两次读但是读到了<strong>不一样多</strong>的数据</p>\n<p><strong>事务隔离级别</strong>：<br>Y表示问题会出现，N表示问题不会出现<br>图片来源：<a href=\"https://www.nowcoder.com/study/live/246/3/13\">牛客网课程</a><br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153824.png\" alt=\"Img\"></p>\n<h2 id=\"实现机制-锁🔒\"><a href=\"#实现机制-锁🔒\" class=\"headerlink\" title=\"实现机制-锁🔒\"></a>实现机制-锁🔒</h2><p><strong>数据库自带：悲观锁</strong>（即出现并发就一定会有问题，所以一定要加锁）</p>\n<ol>\n<li>共享锁（S锁）：事务A对数据加了共享锁后，其他事务只能加共享锁，不能加排它锁</li>\n<li>排它锁（X锁）：事务A对数据加了排他锁后，其他事务什么锁都不能加</li>\n</ol>\n<p><strong>自定义：乐观锁</strong>（即认为出现并发不一定会有问题）<br>用时间戳或版本号等来实现。当要更新数据的时候，发现版本号发生变化了，就取消更新，不然就更新数据（当然也要更新一下版本号）。</p>\n<p>扩展：<a href=\"https://blog.csdn.net/flying_hengfei/article/details/106965517\">MVCC到底是什么？这一篇博客就够啦_flying$的博客-CSDN</a><br><a href=\"https://blog.csdn.net/Waves___/article/details/105295060\">MySQL中MVCC的正确打开方式（源码佐证）_Waves___的博客-CSDN博客</a></p>\n<h2 id=\"Spring的事务管理\"><a href=\"#Spring的事务管理\" class=\"headerlink\" title=\"Spring的事务管理\"></a>Spring的事务管理</h2><p>对任意数据库，有一套统一的API来使用🙆‍♀️<br>两种实现方法：1. 声明式，通过xml或注解配置；2.编程式，通过TransactionTemplate，再用接口回调。</p>\n<p>@Transactinoal<br>isolation选择事务隔离等级<br>propagation选择事务传播机制，一个方法同时调用serviceA和serivceB，如果涉及事务就需要考虑A和B之间事务的关系是什么<br>REQUIRED：保持当前事务，如果没有则创建新事务<br>REQUIRES_NEW：创建新事务，并暂停当前事务<br>NESTED：如果存在当前事务，则嵌套在其中执行（对B会有单独的提交和回滚）；没有就和REQUIRED一样</p>\n<p>更多Propagation的解读：<a href=\"https://blog.csdn.net/yanyan19880509/article/details/53041564\">spring事务-说说Propagation及其实现原理_那个天真的人的博客-CSDN</a></p>\n<h1 id=\"显示评论\"><a href=\"#显示评论\" class=\"headerlink\" title=\"显示评论\"></a>显示评论</h1><p><strong>数据结构</strong>：设计一张表来保存所有评论，由于帖子、帖子的评论都可以有评论，为了减少冗余，把它们都存放在同一张表里，并用<code>entity type</code>来指明是帖子或评论的评论，<code>entity id</code>指明（帖子或评论的）id</p>\n<p><strong>dao</strong>：（1）用<code>entity type</code>和<code>entity id</code>查询评论列表（分页）；（2）用<code>entity type</code>和<code>entity id</code>查询评论数量<br><strong>service</strong>：读取某个帖子对应的所有评论，注意评论中还有对某个评论的回复。<br><strong>controller</strong>：通过访问/discuss/{discussPostId}来访问所有评论，用service读，注意要<strong>分页</strong>，replyList就不用了。设计一个ViewObject返回要显示在网页上的内容，用List保存评论<code>commentList</code>，其中每个元素是一个map，包括一条评论所有相关的内容，即评论内容<code>comment</code>、发表评论的用户<code>user</code>（需要用户名、id和headerUrl）、该评论的回复<code>replyList</code>，其中<code>replyList</code>是和<code>commentList</code>相同的结构，用for循环保存起来，需要注意的是回复有<code>target id</code>，即回复的是哪一条评论。另外还要保存replyList的评论数量，commentList的数量可以用discussPost.commentCount来读取，省得在数据库中搜索浪费时间了。</p>\n<p>注意：</p>\n<ul>\n<li>视图处理上要仔细，别的没啥。难点在于返回网页的内容处理上</li>\n</ul>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><ol>\n<li>controller层和service层的内容，该交给哪个层去完成感觉总是弄混。比如说这里要封装一个给视图显示的viewObject。为什么不交给Service层去处理？我的理解：Service层应具有高可复用性，如果交给service去处理的话，返回一个视图显示对象，这是不太合理的。</li>\n</ol>\n<h1 id=\"回复评论\"><a href=\"#回复评论\" class=\"headerlink\" title=\"回复评论\"></a>回复评论</h1><p>dao层：插入一条评论；更新帖子的回复数量<br>service层：DiscussPostService更新帖子的回复数量。CommentService插入一条评论（注意要html转义、敏感词处理）、调用DiscussPostService方法更新帖子的回复数量。<br>视图层：controller得到comment，前端传回content、targetId、entityType、entityId，剩下的补充一下。调用service方法完成添加评论后要重定向到当前页面，从而进行刷新。</p>\n<p>注意：</p>\n<ul>\n<li>CommentService的插入评论方法，同时对数据库有两次修改，需要放在一个<strong>事务</strong>中处理。</li>\n</ul>\n<h1 id=\"私信\"><a href=\"#私信\" class=\"headerlink\" title=\"私信\"></a>私信</h1><p>数据结构：message表，<code>from_id</code>和<code>to_id</code>分别表示发送用户和接受用户；为了便于查询，将两者拼接为一个字符串表示会话id即<code>conversation_id</code>；其他还有创建时间、内容、状态。注意用户之间的会话，两者不分谁发送谁接收，这个会话是他们共有的。</p>\n<h2 id=\"私信列表\"><a href=\"#私信列表\" class=\"headerlink\" title=\"私信列表\"></a>私信列表</h2><p>私信列表包括朋友私信和系统通知，两者逻辑可以复用。<br>对于朋友私信而言，列表的每一个元素是一个用户，显示该用户头像、用户名（User），以及最近一次会话的内容和时间（Message），以及所有会话数量和未读会话数量。整个列表是当前用户拥有的所有会话（无论当前用户是发送方还是接收方）<br>推出dao层需要的方法：</p>\n<ol>\n<li>UserMapper：根据id查询用户</li>\n<li>MessageMapper：（1）分页查询会话中的最近一次消息（用会话id和limit）；（2）查询和某个用户之间的会话数量（用会话id和status）；（3）为了分页，查询该用户的所有未删除的会话数量（用userId和status）</li>\n</ol>\n<p>service：直接把dao层封装一下<br>controller：封装一个传给视图层的列表</p>\n<p><strong>注意</strong>：</p>\n<ol>\n<li>在统计未读消息的时候，只有对于接收方是未读的消息才要统计，对于发送方而言这条消息不是未读的！</li>\n<li>在写sql语句的时候，因为只需要会话中的最近一次消息，用max(id)并按照conversationId分组即可</li>\n</ol>\n<h2 id=\"私信详情\"><a href=\"#私信详情\" class=\"headerlink\" title=\"私信详情\"></a>私信详情</h2><p>即一个会话的多个消息。用分页展示。其他和私信列表类似。私信的信息注意用户保存的是发送方，可以提前保存起来。</p>\n<h2 id=\"发送私信\"><a href=\"#发送私信\" class=\"headerlink\" title=\"发送私信\"></a>发送私信</h2><p>dao：insert一条message<br>service：内容的合法性要处理，</p>\n<h1 id=\"统一的异常处理\"><a href=\"#统一的异常处理\" class=\"headerlink\" title=\"统一的异常处理\"></a>统一的异常处理</h1><ol>\n<li>用户登录验证。有些方法只有在用户登录之后才可以使用（如回帖、发消息等）</li>\n<li>不存在的网页（404）和服务器出错的网页（500）</li>\n</ol>\n<h2 id=\"用户登录验证\"><a href=\"#用户登录验证\" class=\"headerlink\" title=\"用户登录验证\"></a>用户登录验证</h2><p>使用<strong>拦截器Interceptor</strong>，对需要登录才可以继续的方法进行拦截。为了方便，可以对这些方法统一使用相同的注释来标记（eg. LoginRequired)，在拦截器中判断方法是否包含该注释，再判断用户是否已登录，如果没有登录就重定向到登录页。</p>\n<h2 id=\"404和500页面\"><a href=\"#404和500页面\" class=\"headerlink\" title=\"404和500页面\"></a>404和500页面</h2><p>直接把404页面放到template/error文件夹下面，spring会自动处理。如果没有使用模板引擎，就可以把404页面放到error文件夹中，error文件夹再放到static文件夹下即可。</p>\n<p>而对于500页面，是服务器异常，我们需要把这些异常记录到日志中去，不能直接交给spring boot自动处理。<br>我们使用@ControllerAdvice注解定义一个新的类，从而统一扩增控制器的功能。@ControllerAdvice注解和@ExceptionHandler搭配使用，可以统一处理异常。而@ControllerAdvice中的参数可以指定需要对哪些控制器进行功能增强，如<code>@ControllerAdvice(annotations = Controller.class)</code>对标有Controller注解的所有类进行增强。</p>\n<h1 id=\"统一的日志记录\"><a href=\"#统一的日志记录\" class=\"headerlink\" title=\"统一的日志记录\"></a>统一的日志记录</h1><h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p>面向切面编程。是一种OOP编程的扩展。将项目中多个模块共有的业务看做一个切面，如下图所示（图片来源：<a href=\"https://www.nowcoder.com/study/live/246/3/33\">牛客网课程</a>）<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220720111820.png\" alt=\"Img\"><br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220725110805.png\" alt=\"Img\"></p>\n<p>Joinpoint：连接点，指明aspect是在哪个位置织入。可以是属性或方法等。<br>Target：目标对象，Spring中就是一个Bean<br>Weaving（织入）：有三种织入方式，分别是（1）编译时织入；（2）装载时织入；（3）运行时织入<br>Aspect：方面组件，我理解是在要实现的统一方法是什么（如我们要实现的就是日志这个功能）。其中由包括Pointcut和Advice，前者说明这个Aspect可以在哪里加入，后者是具体逻辑。</p>\n<h2 id=\"AOP的实现\"><a href=\"#AOP的实现\" class=\"headerlink\" title=\"AOP的实现\"></a>AOP的实现</h2><ol>\n<li>AspectJ：是一种扩展了Java的<strong>新语言</strong>；在<strong>编译时</strong>进行织入</li>\n<li>Spring AOP：用Java实现；在<strong>运行时</strong>通过动态代理进行织入；但只支持方法类型的连接点</li>\n</ol>\n<h2 id=\"日志功能\"><a href=\"#日志功能\" class=\"headerlink\" title=\"日志功能\"></a>日志功能</h2><p>用Spring AOP来实现。<br>Spring AOP的代理有两种方式：</p>\n<ol>\n<li>JDK动态代理。是默认方法；如果target是接口，就用JDK动态代理来进行织入</li>\n<li>CGLib动态代理。在没有接口的情况下，就用这个方式来代理</li>\n</ol>\n<p>具体实现：</p>\n<ol>\n<li>类用@Component、@Aspect标注。</li>\n<li>定义切入点：<code>@Pointcut(&quot;execution(* com.nowcoder.community.service.*.*(..))&quot;)</code></li>\n<li>定义通知逻辑。根据在织入点前后处理，可以分为Before、AfterReturning，以及Around、AfterThrowing等</li>\n</ol>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/blossom-wallpaper.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  background-size: cover;\n}\n.popup {\n  opacity: 0.9;\n}\n.header-inner {\n  opacity: 0.95;\n}\n.sidebar {\n  transition-duration: 0.4s;\n  opacity: 0.9;\n}\n.posts-expand .post-title-link {\n  color: #222;\n}\n.post-block {\n  background: #fff;\n  border-radius: initial;\n  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n  padding: 40px;\n  opacity: 0.92;\n}\n","project":{"Apple 官网临摹":{"title":"Apple 官网临摹","subTitle":"根据美版apple官网临摹","img_link":"http://o7bkkhiex.bkt.clouddn.com/item-apple.jpg","use":["jQuery"],"link":"http://haojen.github.io/apple-linmo/","data":"2016.3","direction":"临摹 2016 年三月份 Apple 美版单页面。"},"Anisina (阿尼丝娜)":{"title":"Anisina","subTitle":"基于 Hexo 制作的个人博客主题","img_link":"http://o7bkkhiex.bkt.clouddn.com/Anisina.png","use":["jQuery","Bootstrap","Node.js","EJS","Hexo","SASS"],"link":"http://haojen.github.io/","data":"2016.5","direction":"Hexo 是某位台湾友人基于 Node.js 编写的博客框架"}}}},"excerpt":"<p>核心功能开发完成~</p>","more":"<h1 id=\"过滤敏感词\"><a href=\"#过滤敏感词\" class=\"headerlink\" title=\"过滤敏感词\"></a>过滤敏感词</h1><p>Trie树<br>树的节点包括：子节点（用Map&lt;String, TrieNode&gt;表示），是否是单词结尾的标志（boolean isEnd）<br>两个关键方法：</p>\n<ol>\n<li>向Trie树添加字符串</li>\n<li>对字符串进行敏感词过滤（要注意start指针要一位一位移动，否则会漏判，除了start-end是一个敏感词，start直接跳到end+1）</li>\n</ol>\n<ul>\n<li>注意要跳过敏感词中的符号，比如❤福❤彩❤：<br>用<code>CharUtils.isAsciiAlphanumeric</code>判断字符是否是0-9a-zA-Z范围内（<a href=\"https://www.educative.io/answers/what-is-charutilsisasciialphanumeric-in-java\">参考文档</a>），以及是否是0x2e80~0x9FF之间（这是东亚文字的区间）</li>\n</ul>\n<h1 id=\"发布帖子\"><a href=\"#发布帖子\" class=\"headerlink\" title=\"发布帖子\"></a>发布帖子</h1><h2 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h2><ol>\n<li>在页面中引入jQuery：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;</span> <span class=\"attr\">crossorigin</span>=<span class=\"string\">&quot;anonymous&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>页面中写异步请求发送的方法，举个例子：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">send</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    $.post(</span><br><span class=\"line\">        <span class=\"string\">&quot;/community/ajax&quot;</span>,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;liz&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">24</span>&#125;,</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> data);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\"></span><br><span class=\"line\">            data = $.parseJSON(data);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> data);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"发布帖子-1\"><a href=\"#发布帖子-1\" class=\"headerlink\" title=\"发布帖子\"></a>发布帖子</h2><p>dao层：insert方法<br>service层：处理标题和内容，insert<br>controller层：从前端获取title和content，创建DiscussPost对象，之后调用service，返回是否成功的结果<br>视图：处理返回结果，发布成功时刷新，失败时留在发布界面<br>注意：</p>\n<ol>\n<li>帖子的标题和内容需要合法性处理</li>\n<li>帖子内容如果有html标签，要转义一下，避免内容对页面的损害。用<code>HtmlUtils.htmlEscape</code>方法即可</li>\n</ol>\n<h1 id=\"帖子详情\"><a href=\"#帖子详情\" class=\"headerlink\" title=\"帖子详情\"></a>帖子详情</h1><p>dao：selectById方法<br>service：调用dao的selectById方法<br>controller：postId在路径中传，调用service的select方法，找到的DiscussPost和相关的User对象，送入Model，传到前端视图中显示。</p>\n<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><p>事务：一组操作，要么全部执行，要么全部不执行<br>四个性质：ACID，原子性、一致性、隔离性、持久性<br>隔离性：事务与事务之间的操作是相互隔离的。主要解决<strong>并发异常</strong>问题。<br><strong>常见的并发异常</strong>：1. 第一类丢失更新、第二类丢失更新；2. 脏读、不可重复度、幻读<br><strong>常见的隔离级别</strong>：<br>Read Uncommitted<br>Read Committed</p>\n<h2 id=\"并发异常问题与事务隔离级别\"><a href=\"#并发异常问题与事务隔离级别\" class=\"headerlink\" title=\"并发异常问题与事务隔离级别\"></a>并发异常问题与事务隔离级别</h2><p><strong>第一类丢失更新</strong>：事务A和事务B同时对同一个数据操作，事务A更新完了，但是事务B发现进行了回滚，那么对于事务A的更新就丢失了。（B回滚导致A丢失）<br>图片来源：<a href=\"https://www.nowcoder.com/study/live/246/3/13\">牛客网课程</a><br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153249.png\" alt=\"Img\"></p>\n<p><strong>第二类丢失更新</strong>：<br>B提交导致A丢失<br>图片来源：<a href=\"https://www.nowcoder.com/study/live/246/3/13\">牛客网课程</a><br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153432.png\" alt=\"Img\"></p>\n<p><strong>脏读</strong>：事务A读了事务B还<strong>没有提交但修改</strong>了的数据</p>\n<p><strong>不可重复读</strong>：事务B在修改数据，事务A两次读同一个数据但读到了<strong>不一样</strong>的数据。</p>\n<p><strong>幻读</strong>：事务B在插入数据，事务A两次读但是读到了<strong>不一样多</strong>的数据</p>\n<p><strong>事务隔离级别</strong>：<br>Y表示问题会出现，N表示问题不会出现<br>图片来源：<a href=\"https://www.nowcoder.com/study/live/246/3/13\">牛客网课程</a><br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220711153824.png\" alt=\"Img\"></p>\n<h2 id=\"实现机制-锁🔒\"><a href=\"#实现机制-锁🔒\" class=\"headerlink\" title=\"实现机制-锁🔒\"></a>实现机制-锁🔒</h2><p><strong>数据库自带：悲观锁</strong>（即出现并发就一定会有问题，所以一定要加锁）</p>\n<ol>\n<li>共享锁（S锁）：事务A对数据加了共享锁后，其他事务只能加共享锁，不能加排它锁</li>\n<li>排它锁（X锁）：事务A对数据加了排他锁后，其他事务什么锁都不能加</li>\n</ol>\n<p><strong>自定义：乐观锁</strong>（即认为出现并发不一定会有问题）<br>用时间戳或版本号等来实现。当要更新数据的时候，发现版本号发生变化了，就取消更新，不然就更新数据（当然也要更新一下版本号）。</p>\n<p>扩展：<a href=\"https://blog.csdn.net/flying_hengfei/article/details/106965517\">MVCC到底是什么？这一篇博客就够啦_flying$的博客-CSDN</a><br><a href=\"https://blog.csdn.net/Waves___/article/details/105295060\">MySQL中MVCC的正确打开方式（源码佐证）_Waves___的博客-CSDN博客</a></p>\n<h2 id=\"Spring的事务管理\"><a href=\"#Spring的事务管理\" class=\"headerlink\" title=\"Spring的事务管理\"></a>Spring的事务管理</h2><p>对任意数据库，有一套统一的API来使用🙆‍♀️<br>两种实现方法：1. 声明式，通过xml或注解配置；2.编程式，通过TransactionTemplate，再用接口回调。</p>\n<p>@Transactinoal<br>isolation选择事务隔离等级<br>propagation选择事务传播机制，一个方法同时调用serviceA和serivceB，如果涉及事务就需要考虑A和B之间事务的关系是什么<br>REQUIRED：保持当前事务，如果没有则创建新事务<br>REQUIRES_NEW：创建新事务，并暂停当前事务<br>NESTED：如果存在当前事务，则嵌套在其中执行（对B会有单独的提交和回滚）；没有就和REQUIRED一样</p>\n<p>更多Propagation的解读：<a href=\"https://blog.csdn.net/yanyan19880509/article/details/53041564\">spring事务-说说Propagation及其实现原理_那个天真的人的博客-CSDN</a></p>\n<h1 id=\"显示评论\"><a href=\"#显示评论\" class=\"headerlink\" title=\"显示评论\"></a>显示评论</h1><p><strong>数据结构</strong>：设计一张表来保存所有评论，由于帖子、帖子的评论都可以有评论，为了减少冗余，把它们都存放在同一张表里，并用<code>entity type</code>来指明是帖子或评论的评论，<code>entity id</code>指明（帖子或评论的）id</p>\n<p><strong>dao</strong>：（1）用<code>entity type</code>和<code>entity id</code>查询评论列表（分页）；（2）用<code>entity type</code>和<code>entity id</code>查询评论数量<br><strong>service</strong>：读取某个帖子对应的所有评论，注意评论中还有对某个评论的回复。<br><strong>controller</strong>：通过访问/discuss/{discussPostId}来访问所有评论，用service读，注意要<strong>分页</strong>，replyList就不用了。设计一个ViewObject返回要显示在网页上的内容，用List保存评论<code>commentList</code>，其中每个元素是一个map，包括一条评论所有相关的内容，即评论内容<code>comment</code>、发表评论的用户<code>user</code>（需要用户名、id和headerUrl）、该评论的回复<code>replyList</code>，其中<code>replyList</code>是和<code>commentList</code>相同的结构，用for循环保存起来，需要注意的是回复有<code>target id</code>，即回复的是哪一条评论。另外还要保存replyList的评论数量，commentList的数量可以用discussPost.commentCount来读取，省得在数据库中搜索浪费时间了。</p>\n<p>注意：</p>\n<ul>\n<li>视图处理上要仔细，别的没啥。难点在于返回网页的内容处理上</li>\n</ul>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><ol>\n<li>controller层和service层的内容，该交给哪个层去完成感觉总是弄混。比如说这里要封装一个给视图显示的viewObject。为什么不交给Service层去处理？我的理解：Service层应具有高可复用性，如果交给service去处理的话，返回一个视图显示对象，这是不太合理的。</li>\n</ol>\n<h1 id=\"回复评论\"><a href=\"#回复评论\" class=\"headerlink\" title=\"回复评论\"></a>回复评论</h1><p>dao层：插入一条评论；更新帖子的回复数量<br>service层：DiscussPostService更新帖子的回复数量。CommentService插入一条评论（注意要html转义、敏感词处理）、调用DiscussPostService方法更新帖子的回复数量。<br>视图层：controller得到comment，前端传回content、targetId、entityType、entityId，剩下的补充一下。调用service方法完成添加评论后要重定向到当前页面，从而进行刷新。</p>\n<p>注意：</p>\n<ul>\n<li>CommentService的插入评论方法，同时对数据库有两次修改，需要放在一个<strong>事务</strong>中处理。</li>\n</ul>\n<h1 id=\"私信\"><a href=\"#私信\" class=\"headerlink\" title=\"私信\"></a>私信</h1><p>数据结构：message表，<code>from_id</code>和<code>to_id</code>分别表示发送用户和接受用户；为了便于查询，将两者拼接为一个字符串表示会话id即<code>conversation_id</code>；其他还有创建时间、内容、状态。注意用户之间的会话，两者不分谁发送谁接收，这个会话是他们共有的。</p>\n<h2 id=\"私信列表\"><a href=\"#私信列表\" class=\"headerlink\" title=\"私信列表\"></a>私信列表</h2><p>私信列表包括朋友私信和系统通知，两者逻辑可以复用。<br>对于朋友私信而言，列表的每一个元素是一个用户，显示该用户头像、用户名（User），以及最近一次会话的内容和时间（Message），以及所有会话数量和未读会话数量。整个列表是当前用户拥有的所有会话（无论当前用户是发送方还是接收方）<br>推出dao层需要的方法：</p>\n<ol>\n<li>UserMapper：根据id查询用户</li>\n<li>MessageMapper：（1）分页查询会话中的最近一次消息（用会话id和limit）；（2）查询和某个用户之间的会话数量（用会话id和status）；（3）为了分页，查询该用户的所有未删除的会话数量（用userId和status）</li>\n</ol>\n<p>service：直接把dao层封装一下<br>controller：封装一个传给视图层的列表</p>\n<p><strong>注意</strong>：</p>\n<ol>\n<li>在统计未读消息的时候，只有对于接收方是未读的消息才要统计，对于发送方而言这条消息不是未读的！</li>\n<li>在写sql语句的时候，因为只需要会话中的最近一次消息，用max(id)并按照conversationId分组即可</li>\n</ol>\n<h2 id=\"私信详情\"><a href=\"#私信详情\" class=\"headerlink\" title=\"私信详情\"></a>私信详情</h2><p>即一个会话的多个消息。用分页展示。其他和私信列表类似。私信的信息注意用户保存的是发送方，可以提前保存起来。</p>\n<h2 id=\"发送私信\"><a href=\"#发送私信\" class=\"headerlink\" title=\"发送私信\"></a>发送私信</h2><p>dao：insert一条message<br>service：内容的合法性要处理，</p>\n<h1 id=\"统一的异常处理\"><a href=\"#统一的异常处理\" class=\"headerlink\" title=\"统一的异常处理\"></a>统一的异常处理</h1><ol>\n<li>用户登录验证。有些方法只有在用户登录之后才可以使用（如回帖、发消息等）</li>\n<li>不存在的网页（404）和服务器出错的网页（500）</li>\n</ol>\n<h2 id=\"用户登录验证\"><a href=\"#用户登录验证\" class=\"headerlink\" title=\"用户登录验证\"></a>用户登录验证</h2><p>使用<strong>拦截器Interceptor</strong>，对需要登录才可以继续的方法进行拦截。为了方便，可以对这些方法统一使用相同的注释来标记（eg. LoginRequired)，在拦截器中判断方法是否包含该注释，再判断用户是否已登录，如果没有登录就重定向到登录页。</p>\n<h2 id=\"404和500页面\"><a href=\"#404和500页面\" class=\"headerlink\" title=\"404和500页面\"></a>404和500页面</h2><p>直接把404页面放到template/error文件夹下面，spring会自动处理。如果没有使用模板引擎，就可以把404页面放到error文件夹中，error文件夹再放到static文件夹下即可。</p>\n<p>而对于500页面，是服务器异常，我们需要把这些异常记录到日志中去，不能直接交给spring boot自动处理。<br>我们使用@ControllerAdvice注解定义一个新的类，从而统一扩增控制器的功能。@ControllerAdvice注解和@ExceptionHandler搭配使用，可以统一处理异常。而@ControllerAdvice中的参数可以指定需要对哪些控制器进行功能增强，如<code>@ControllerAdvice(annotations = Controller.class)</code>对标有Controller注解的所有类进行增强。</p>\n<h1 id=\"统一的日志记录\"><a href=\"#统一的日志记录\" class=\"headerlink\" title=\"统一的日志记录\"></a>统一的日志记录</h1><h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p>面向切面编程。是一种OOP编程的扩展。将项目中多个模块共有的业务看做一个切面，如下图所示（图片来源：<a href=\"https://www.nowcoder.com/study/live/246/3/33\">牛客网课程</a>）<br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220720111820.png\" alt=\"Img\"><br><img src=\"https://forlwq.oss-cn-hangzhou.aliyuncs.com/ProjectNowCoder/img-20220725110805.png\" alt=\"Img\"></p>\n<p>Joinpoint：连接点，指明aspect是在哪个位置织入。可以是属性或方法等。<br>Target：目标对象，Spring中就是一个Bean<br>Weaving（织入）：有三种织入方式，分别是（1）编译时织入；（2）装载时织入；（3）运行时织入<br>Aspect：方面组件，我理解是在要实现的统一方法是什么（如我们要实现的就是日志这个功能）。其中由包括Pointcut和Advice，前者说明这个Aspect可以在哪里加入，后者是具体逻辑。</p>\n<h2 id=\"AOP的实现\"><a href=\"#AOP的实现\" class=\"headerlink\" title=\"AOP的实现\"></a>AOP的实现</h2><ol>\n<li>AspectJ：是一种扩展了Java的<strong>新语言</strong>；在<strong>编译时</strong>进行织入</li>\n<li>Spring AOP：用Java实现；在<strong>运行时</strong>通过动态代理进行织入；但只支持方法类型的连接点</li>\n</ol>\n<h2 id=\"日志功能\"><a href=\"#日志功能\" class=\"headerlink\" title=\"日志功能\"></a>日志功能</h2><p>用Spring AOP来实现。<br>Spring AOP的代理有两种方式：</p>\n<ol>\n<li>JDK动态代理。是默认方法；如果target是接口，就用JDK动态代理来进行织入</li>\n<li>CGLib动态代理。在没有接口的情况下，就用这个方式来代理</li>\n</ol>\n<p>具体实现：</p>\n<ol>\n<li>类用@Component、@Aspect标注。</li>\n<li>定义切入点：<code>@Pointcut(&quot;execution(* com.nowcoder.community.service.*.*(..))&quot;)</code></li>\n<li>定义通知逻辑。根据在织入点前后处理，可以分为Before、AfterReturning，以及Around、AfterThrowing等</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cl1jeaggd000338t49h8d2vhi","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeaggm000d38t49viq21qv"},{"post_id":"cl1jeaggl000b38t43bbidcjd","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeaggn000h38t48pr51yu8"},{"post_id":"cl1jeaggl000c38t4806q7usz","category_id":"cl1jeaggm000f38t41si5adk1","_id":"cl1jeaggp000o38t4e5291im7"},{"post_id":"cl1jeaggm000e38t47rep5v3s","category_id":"cl1jeaggo000k38t47a3r0276","_id":"cl1jeaggs000u38t450cd3fzs"},{"post_id":"cl1jeaggr000q38t49w1qbpoo","category_id":"cl1jeaggm000f38t41si5adk1","_id":"cl1jeaggt000y38t4cdr295y8"},{"post_id":"cl1jeaggn000g38t45z0y5z1y","category_id":"cl1jeaggm000f38t41si5adk1","_id":"cl1jeaggu001238t40zyn7oo0"},{"post_id":"cl1jeaggr000s38t4htqkdhl1","category_id":"cl1jeaggm000f38t41si5adk1","_id":"cl1jeaggu001638t44z216ngi"},{"post_id":"cl1jeaggn000i38t440891tb6","category_id":"cl1jeaggo000k38t47a3r0276","_id":"cl1jeaggv001938t4diy69jwn"},{"post_id":"cl1jeaggn000j38t4578k7aie","category_id":"cl1jeaggt001038t42ejq8uba","_id":"cl1jeaggw001d38t43iko7uo1"},{"post_id":"cl1jeaggp000m38t49n155h63","category_id":"cl1jeaggu001738t4018q12qk","_id":"cl1jeaggx001k38t46f284qff"},{"post_id":"cl1jeaggv001b38t47t8v348q","category_id":"cl1jeaggo000k38t47a3r0276","_id":"cl1jeaggy001n38t4d48cfhp6"},{"post_id":"cl1jeaggw001f38t4bqw56nhz","category_id":"cl1jeaggt001038t42ejq8uba","_id":"cl1jeaggz001q38t434yk262n"},{"post_id":"cl1jeaggp000n38t40lpj5z3m","category_id":"cl1jeaggu001738t4018q12qk","_id":"cl1jeaggz001u38t4gpdo1n0c"},{"post_id":"cl1jeaggx001i38t4esl674mw","category_id":"cl1jeaggt001038t42ejq8uba","_id":"cl1jeagh0001y38t4ao9b8c77"},{"post_id":"cl1jeaggx001l38t4fw1l86zl","category_id":"cl1jeaggt001038t42ejq8uba","_id":"cl1jeagh1002138t4ew980jov"},{"post_id":"cl1jeaggy001o38t4043hczxk","category_id":"cl1jeaggt001038t42ejq8uba","_id":"cl1jeagh2002438t45gjq3dn6"},{"post_id":"cl1jeaggt000x38t41sbfcjco","category_id":"cl1jeaggx001j38t4gqnsf2n7","_id":"cl1jeagh2002838t4fdjn7kp5"},{"post_id":"cl1jeaggz001r38t46jcq2ma7","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeagh5002a38t4bmf00pcn"},{"post_id":"cl1jeaggt001138t4cdh382hs","category_id":"cl1jeaggx001j38t4gqnsf2n7","_id":"cl1jeagh5002e38t467074rb1"},{"post_id":"cl1jeagh1002238t485qu3g18","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeagh6002g38t47f3r4dpb"},{"post_id":"cl1jeaggu001538t4b1ze9yan","category_id":"cl1jeaggx001j38t4gqnsf2n7","_id":"cl1jeagh7002k38t40a0u3bks"},{"post_id":"cl1jeagh2002538t4akyh7g0u","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeagh7002m38t4hrll6ctz"},{"post_id":"cl1jeagh2002938t44b61gr7h","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeagh8002p38t4c6kl0in8"},{"post_id":"cl1jeaggv001838t4bqwsdy97","category_id":"cl1jeaggx001j38t4gqnsf2n7","_id":"cl1jeagh9002t38t4ech8disa"},{"post_id":"cl1jeagh5002b38t4e7uobrld","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeaghb002w38t4d5i8eyqf"},{"post_id":"cl1jeagh5002f38t40xv53ean","category_id":"cl1jeaggo000k38t47a3r0276","_id":"cl1jeaghb002z38t45s5ea1pr"},{"post_id":"cl1jeaggz001v38t48fz0fmd2","category_id":"cl1jeagh5002c38t4fufg6mh1","_id":"cl1jeaghc003338t4elebd2di"},{"post_id":"cl1jeagh7002l38t4947r8tny","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeaghd003638t4462k8n26"},{"post_id":"cl1jeagh0001z38t4en2dhju1","category_id":"cl1jeagh5002c38t4fufg6mh1","_id":"cl1jeaghe003838t43mbe8saq"},{"post_id":"cl1jeagh6002h38t4enc57zy7","category_id":"cl1jeagh8002o38t42txycyf3","_id":"cl1jeaghe003b38t4cxci45xv"},{"post_id":"cl1jeaghb002x38t46tos9s1z","category_id":"cl1jeaghb002v38t4fch894gx","_id":"cl1jeaghf003e38t4hrgudyu1"},{"post_id":"cl1jeagh8002n38t46bsic2zm","category_id":"cl1jeaghb002v38t4fch894gx","_id":"cl1jeaghg003i38t4ggjyelgy"},{"post_id":"cl1jeaghc003038t4c0dr6z0o","category_id":"cl1jeaghb002v38t4fch894gx","_id":"cl1jeaghg003j38t40xlb3s5q"},{"post_id":"cl1jeagh9002q38t4359gbz2n","category_id":"cl1jeaghc003238t4aweqhjx5","_id":"cl1jeaghh003l38t4906w8tg9"},{"post_id":"cl1jeaghc003438t4esnj3t60","category_id":"cl1jeaghe003a38t46aee2fh9","_id":"cl1jeaghh003m38t492z044kd"},{"post_id":"cl1jeaghf003f38t4d8rsdzd0","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeaghi003o38t4b9ya42jn"},{"post_id":"cl1jeaghd003738t498x5g338","category_id":"cl1jeaghf003g38t41plt0lin","_id":"cl1jeaghi003p38t4c1hn0eqg"},{"post_id":"cl1jeaghe003938t4bsklhkaj","category_id":"cl1jeaghh003k38t491blhajg","_id":"cl1jeaghi003q38t48ql39qbh"},{"post_id":"cl1jeaghe003c38t49yywhnh1","category_id":"cl1jeaghh003n38t470xkcsyb","_id":"cl1jeaghi003r38t4g0or251t"},{"post_id":"cl1jeaghk003s38t427105sf5","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeaghm003v38t473nbfimo"},{"post_id":"cl1jeaghk003t38t4f9jp4119","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeaghm003w38t43wqhafty"},{"post_id":"cl1jeaghl003u38t448l62ocz","category_id":"cl1jeaggg000638t43y8g67h4","_id":"cl1jeaghm003x38t42qeu56v7"},{"post_id":"cl57yu4510000got48n3k9rvf","category_id":"cl57yu4530001got472ap57zr","_id":"cl57yu45b0004got4ekfhdaf5"},{"post_id":"cl5c6xktr0000cct49ouq31m2","category_id":"cl57yu4530001got472ap57zr","_id":"cl5c6xktv0002cct4b8w57b9l"},{"post_id":"cl607fqzw000044t45ki0hwao","category_id":"cl57yu4530001got472ap57zr","_id":"cl607fr00000244t4dl5290cl"}],"PostTag":[{"post_id":"cl1jeaggn000i38t440891tb6","tag_id":"cl1jeaggo000l38t4dydw1swx","_id":"cl1jeaggt000z38t4fq44dlit"},{"post_id":"cl1jeaggn000i38t440891tb6","tag_id":"cl1jeaggr000r38t45h7ybbx4","_id":"cl1jeaggu001338t4hrpdh2ji"},{"post_id":"cl1jeaggr000q38t49w1qbpoo","tag_id":"cl1jeaggs000w38t478xt0cpo","_id":"cl1jeaggw001c38t41z5415k3"},{"post_id":"cl1jeaggr000q38t49w1qbpoo","tag_id":"cl1jeaggu001438t43l1dd9l2","_id":"cl1jeaggw001g38t47euc2fh9"},{"post_id":"cl1jeaggr000s38t4htqkdhl1","tag_id":"cl1jeaggs000w38t478xt0cpo","_id":"cl1jeaggz001p38t4bfah21o1"},{"post_id":"cl1jeaggr000s38t4htqkdhl1","tag_id":"cl1jeaggu001438t43l1dd9l2","_id":"cl1jeaggz001t38t4dmnd3ub6"},{"post_id":"cl1jeaggt000x38t41sbfcjco","tag_id":"cl1jeaggy001m38t4gbxj7pdz","_id":"cl1jeagh0001x38t46yjy84la"},{"post_id":"cl1jeaggt001138t4cdh382hs","tag_id":"cl1jeagh0001w38t4484r1xfu","_id":"cl1jeagh2002638t45a6khb4g"},{"post_id":"cl1jeaggu001538t4b1ze9yan","tag_id":"cl1jeagh1002338t42457b3cm","_id":"cl1jeagh5002d38t47r185dqk"},{"post_id":"cl1jeagh5002f38t40xv53ean","tag_id":"cl1jeagh7002j38t416ef1gqy","_id":"cl1jeagh9002s38t4e6pkeexj"},{"post_id":"cl1jeagh6002h38t4enc57zy7","tag_id":"cl1jeagh9002r38t4bzvmccvg","_id":"cl1jeaghc003138t4en8kdmrt"},{"post_id":"cl1jeagh8002n38t46bsic2zm","tag_id":"cl1jeaghb002y38t4080i9v5k","_id":"cl1jeaghf003d38t4ga0u7smy"},{"post_id":"cl1jeagh8002n38t46bsic2zm","tag_id":"cl1jeaghd003538t4e6ix4g9p","_id":"cl1jeaghf003h38t4bvz21ly3"},{"post_id":"cl57yu4510000got48n3k9rvf","tag_id":"cl57yu45a0002got4cizje3di","_id":"cl57yu45b0003got42k160063"},{"post_id":"cl5c6xktr0000cct49ouq31m2","tag_id":"cl57yu45a0002got4cizje3di","_id":"cl5c6xktu0001cct4c5lx1anj"},{"post_id":"cl607fqzw000044t45ki0hwao","tag_id":"cl57yu45a0002got4cizje3di","_id":"cl607fqzz000144t47o0rdy6o"}],"Tag":[{"name":"Colab","_id":"cl1jeaggo000l38t4dydw1swx"},{"name":"Python","_id":"cl1jeaggr000r38t45h7ybbx4"},{"name":"刷题","_id":"cl1jeaggs000w38t478xt0cpo"},{"name":"Leetcode简单题","_id":"cl1jeaggu001438t43l1dd9l2"},{"name":"双指针","_id":"cl1jeaggy001m38t4gbxj7pdz"},{"name":"模拟","_id":"cl1jeagh0001w38t4484r1xfu"},{"name":"滑动窗口","_id":"cl1jeagh1002338t42457b3cm"},{"name":"搭建博客","_id":"cl1jeagh7002j38t416ef1gqy"},{"name":"转载","_id":"cl1jeagh9002r38t4bzvmccvg"},{"name":"小样本","_id":"cl1jeaghb002y38t4080i9v5k"},{"name":"数据扩增","_id":"cl1jeaghd003538t4e6ix4g9p"},{"name":"牛客网后端","_id":"cl57yu45a0002got4cizje3di"}]}}